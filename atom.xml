<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Nolboo's Blog]]></title>
  <link href="http://nolboo.github.io/atom.xml" rel="self"/>
  <link href="http://nolboo.github.io/"/>
  <updated>2013-10-22T15:17:17+09:00</updated>
  <id>http://nolboo.github.io/</id>
  <author>
    <name><![CDATA[Nolboo Kim]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Harp로 블로그 만들기]]></title>
    <link href="http://nolboo.github.io/blog/2013/10/17/start-blog-with-harp/"/>
    <updated>2013-10-17T17:07:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/10/17/start-blog-with-harp</id>
    <content type="html"><![CDATA[<p>원문 : <a href="http://kennethormandy.com/journal/start-a-blog-with-harp">Start a blog with Harp</a></p>

<p>참조 :  <a href="http://sintaxi.com/introducing-harp">Intoducing Harp</a></p>

<h2 id="install-harp">Install Harp</h2>

<pre><code>sudo npm install harp -g
</code></pre>

<p>하프를 글로벌로 설치한다.</p>

<pre><code>cd ~/Sites
harp init my-harp-blog
</code></pre>

<!-- more -->

<p><code>harp init</code>이 다음과 같은 디폴트앱을 만든다.</p>

<pre><code>▾ /
  ▪ _layout.jade
  ▪ 404.jade
  ▪ index.jade
  ▪ main.less
</code></pre>

<p>이제 웹서버를 시작하여 하프앱을 눈으로 보자.</p>

<pre><code>harp server my-harp-blog
</code></pre>

<p><a href="localhost:9000">localhost:9000</a>에서 로컬에서 실행된 <code>my-harp-blog</code>를 볼 수 있다.</p>

<p><img src="http://kennethormandy.com/images/start-a-blog-with-harp/1.png" alt="" /></p>

<h2 id="start-with-markdown">Start with Markdown</h2>

<p>마크다운 화일을 추가하여 새 페이지를 만들어보자. 루트 디렉토리에 <code>about.md</code>를 만들어 아래와 같은 형식으로 자신에 대한 것을 적는다.</p>

<pre><code># About Kenneth

Hi, I’m Kenneth. Sometimes I write about building things with [Harp](http://harpjs.com).
</code></pre>

<p>화일을 저장하고 <a href="localhost:9000/about">localhost:9000/about</a>를 방문하면 about 페이지를 볼 수 있다. 하프를 재시작할 필요도, 무언가를 설정할 필요도 없다.</p>

<p><code>about.md</code> 화일을 변경하고 저장하고 브라우저를 새로고침하면, 변경된 것이 이미 반영된다.</p>

<p><img src="http://kennethormandy.com/images/start-a-blog-with-harp/2.png" alt="" /></p>

<p>정적 사이트 제너레이터를 경험해 본 적이 있다면 화일 watcher를 시작하고 정지시키는 작업을 했을 것이다. 하프에선 그럴 필요가 없다; 서버가 작동하고 있는 한, 변경사항이 바로 브라우저로 전달된다. 이 프로세스는 매우 빠르다: 화일이 제대로 준비된다면, 하나의 화일이 변경되었을 때 전체 앱을 다시 빌드할 필요가 없다.</p>

<p>하프는 순수 HTML로 about 페이지를 렌더링하지 않는 것을 주목해야한다. 대신, 먼저 레이아웃 화일을 통과하여 인덱스 페이지와 매칭한다.</p>

<h2 id="layouts">Layouts</h2>

<p>레이아웃은 헤더와 푸터 등 또는 더 복잡하게 반복되는 구조를 만들기 위해서 사용된다. <code>_layout</code> 화일은 마크업을 포함한다. <a href="http://harpjs.com/docs/development/rules">규약</a>에 의하면, 하프는 밑줄(<code>_</code>)로 시작되는 화일이나 폴더는 서비스하지 않는다. 특별히, 이 <code>_layout.jade</code>은 화일을 위한 wrapper로서 <em>서비스 된다</em>.</p>

<p><code>about.md</code>, <code>404.jade</code>, <code>index.jade</code>의 모든 컨텐츠는 <code>yield</code> 변수로 사용하여 레이아웃의 어디에든 가져올 수 있다.</p>

<pre><code>!!!
html
  head
    link(rel="stylesheet", href="http://nolboo.github.io/main.css")
  body
    != yield
</code></pre>

<p>Jade의 명쾌함은 강력하다. 처음에 친숙하지 않더라도 사용해 볼 것을 권한다. 당신이 <code>HTML</code>을 고수하려한다면, 하프는 <code>EJS</code>도 지원한다.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="cp">&lt;!DOCTYPE html&gt;</span>
</span><span class="line"><span class="nt">&lt;html&gt;</span>
</span><span class="line">  <span class="nt">&lt;head&gt;</span>
</span><span class="line">    <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">href=</span><span class="s">&quot;main.css&quot;</span> <span class="nt">/&gt;</span>
</span><span class="line">  <span class="nt">&lt;/head&gt;</span>
</span><span class="line">  <span class="nt">&lt;body&gt;</span>
</span><span class="line">    <span class="err">&lt;</span>%- yield %&gt;
</span><span class="line">  <span class="nt">&lt;/body&gt;</span>
</span><span class="line"><span class="nt">&lt;/html&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Jade에서, 감탄부호(<code>!</code>)는 <code>yield</code>가 예외처리되지 않게 한다. <code>EJS</code>에서 하이픈(<code>-</code>)과 같다.</p>

<p>어느 쪽이든, <code>main.css</code>가 참조된 것을 주의한다. 폴더에 실제로 그 화일이 없더라도;<code>main.less</code>가 있다. 하프는 프리프로세싱이 내장되어 있다. <code>LESS</code> 화일을 업데이트하고 저장하면 변경사항이 브라우저에 바로 변경된다. 디폴트 스타일시트에 조금 추가한 것이 있다. 같은 것을 사용하고 싶다면, <a href="https://github.com/kennethormandy/my-harp-blog/blob/master/main.less">여기</a>에 있다.</p>

<p><img src="http://kennethormandy.com/images/start-a-blog-with-harp/3.png" alt="" /></p>

<h2 id="adding-articles">Adding Articles</h2>

<p>나는 <code>localhost:9000/articles/another-article</code>에서 내 첫번째 글을 액세스하고 싶다. 그래서 <code>article</code> 디렉토리를 만들 것이다. 폴더가 그대로 URL이 된다; 원하는 대로 <code>URL</code>을 반영하는 디렉토리 구조를 만들어라.</p>

<pre><code>▾ /
  ▪ _layout.jade
  ▪ 404.jade
  ▪ index.jade
  ▪ main.less
  ▾ articles/
    ▪ _data.json
    ▪ a-simple-article.md
    ▪ another-article.md
</code></pre>

<p>추가한 글은 마크다운이면 된다. 글 자체를 넘어서는 글에 관한 정보는 <code>_data.json</code> 안에 담긴다.</p>

<h2 id="flexible-metadata">Flexible Metadata</h2>

<p>각각의 <code>.md</code> 화일이 아닌  _data.json` 안의 메타데이타를 유지하는 것은 몇 가지 이유로 잘 작동된다.</p>

<ol>
  <li>하나의 화일에 어떤 크기의 메타데이타를 가질 수 있으므로, 당신의 글을 방해하지 않는다.</li>
  <li>포스트, 이미지, 비디오 혹은 다른 어떤 것의 메타데이타가 같은 방식으로 추가될 수 있다.</li>
  <li>다른 화일들도 이 <code>_data.json</code>을 쉽게 사용할 수 있다.</li>
  <li>정보의 순서를 화일명으로 요구하기보다 <code>_data.json</code>에서 정할 수 있다.</li>
</ol>

<p>글 자체 안이 아닌 <code>_data.json</code> 화일에 제목, 날짜, 혹은 다른 정보를 추가하여, 마크다운을 사용하는 이점을 최대한으로 얻을 수 있으며 단지 글쓰기에 대해서만 고민하면 된다.</p>

<p>이 블로그를 위해, 내 <code>_data.json</code> 화일에 아래와 같이 추가하기로 했다:</p>

<pre><code>{
  "a-good-article": {
    "title": "A Good Article"
  },
  "a-complicated-article": {
    "title": "Another Article"
  }
}
</code></pre>

<p>Jade를 사용하여, 이 메타데이타를 반복할 수 있고, 모든 글을 목록화했다. <code>index.jade</code>에 다음을 추가했다.</p>

<pre><code>ul
  each article, slug in public.articles.data
    li
      a(href="/articles/#{ slug }") #{ article.title }
</code></pre>

<p>기대한대로, 홈페이지에 이제 글 목록이 있다.</p>

<p><img src="http://kennethormandy.com/images/start-a-blog-with-harp/4.png" alt="" /></p>

<p>이 블로그는 아직 내비게이션할 방법이 빠져있다. 레이아웃에 헤더뿐만 아니라 푸터에 내비를 넣는 것이 좋을 것이다. 하프의 <code>partial</code> 함수로 같은 마크업을 여러 번 반복하지 않을 수 있다.</p>

<h2 id="partials">Partials</h2>

<p><code>partial()</code>은 하나의 화일에서 다른 화일로 가져다 사용할 수 있다. 앱에서 하나의 partial로 어떤 텍스트 기반 화일을 사용할 수 있다. 일반적으로 전체 페이지보다는 하나의 코드 스니핏으로 가져오길 원할 것이다. 그러나, 각각에 <code>partial()</code>을 사용할 수도 있다. <code>_layout</code> 화일을 사용할 때, 화일명의 시작에 밑줄을 추가하면 자신의 페이지가 제너레이트되지 않을 것이다. 코드 스니핏일 때 훌륭하다. 이 규약은 폴더에서도 적용된다:밑줄로 시작되는 폴더는 그 안의 어떤 것도 제너레이트되지 않는다. 밑줄로 시작되는 폴더는 partial을 저장하기에 좋은 장소이다. 이를 위해 <code>_shared</code> 폴더를 만들었다.</p>

<p><code>_shared/</code> 안에 <code>nav.jade</code>란 새 화일을 만들었다.</p>

<pre><code>nav
  a(href="/") Home
  a(href="/about") About
</code></pre>

<p>이제 <code>_layout.jade</code> 안에 <code>partial()</code>로 다음 화일을 사용했다:</p>

<pre><code>!!!
html
  head
    link(rel="stylesheet", href="http://nolboo.github.io/main.css")
  body
    != partial("_shared/nav")
    != yield
    footer
      != partial("_shared/nav")
</code></pre>

<p>이제, 중복된 마크업을 사용하지 않고 내비가 블로그 포스트의 위와 아래에 나타난다. 이건 단순한 예제이다. 그러나, 유용한 partial들이 블로그의 부분들로 얼마나 유용하게 어디서나 재사용될 수 있는지 상상할 수 있을 것이다.</p>

<p><img src="http://kennethormandy.com/images/start-a-blog-with-harp/5.png" alt="" /></p>

<h2 id="getting-it-out-there">Getting it out there</h2>

<p>이제 블로그가 첫번째 버전을 온라인으로 올릴 만하게 보인다. 하프앱은 <code>HTML</code>, <code>CSS</code> &amp; <code>JavaScript</code>로 변환하여 원하는 어떤 곳에도 발행할 수 있다.</p>

<pre><code>harp compile
</code></pre>

<p>이 명령은 블로그의 <code>HTML</code>, <code>CSS</code> &amp; <code>JavaScript</code>이 들어있는 <code>www</code> 폴더를 제너레이트한다. 아마존 S3, <a href="http://harpjs.com/docs/deployment/github-pages">GitHub Pages</a>, <a href="http://kennethormandy.com/journal/harpjs.com/docs/deployment/heroku">Heroku</a>, Nodejitsu 혹은 Apache Cordova/PhoneGap를 포함한 어떤 곳에서도 훌륭히 작동된다.</p>

<p>컴파일 단계를 완전히 생략하고, 드랍박스에 앱을 올릴 수 있는 <a href="http://harp.io/">하프플랫폼</a>에서도 작업할 수 있다.</p>

<p>하프로 사이트를 만들 때 <code>LESS</code>, 마크다운, <code>Jade</code>와 작업하는 것이 덜 어렵다는 것을 알았다.</p>

<p><em>블로그 소스코드는 <a href="http://github.com/kennethormandy/my-harp-blog">GitHub</a>에 올려져있다.</em></p>

<h2 id="section">역자 참조 링크</h2>

<ul>
  <li>계속해서 깃허브 등에 적용하는 포스트가 올라올 것으로 생각되지만, 바로 자신의 블로그를 만들어서 깃허브에 적용하려면 <a href="http://nolboo.github.io/blog/2013/10/15/free-blog-with-github-jekyll/">지킬로 깃허브에 무료 블로그 만들기</a>와 <a href="http://nolboo.github.io/blog/2013/10/06/github-for-beginner/">완전 초보를 위한 깃허브</a>를 참조하면 쉽게 올릴 수 있을 것으로 생각한다.</li>
  <li>마크다운에 익숙하지 않는 분은 <a href="http://nolboo.github.io/blog/2013/09/07/john-gruber-markdown/">존 그루버 마크다운 페이지 번역</a>을 참조하시면 글쓰기의 신천지를 경험할 수 있다.</li>
  <li>이 블로그는 <a href="http://nolboo.github.io/blog/2013/07/21/start-octopress/">옥토프레스</a>로 만들어졌으며, 다양한 블로깅 플랫폼을 탐색하는 중이다.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[지킬로 깃허브에 무료 블로그 만들기]]></title>
    <link href="http://nolboo.github.io/blog/2013/10/15/free-blog-with-github-jekyll/"/>
    <updated>2013-10-15T19:58:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/10/15/free-blog-with-github-jekyll</id>
    <content type="html"><![CDATA[<p><a href="http://jekyllrb.com/">Jekyll</a>은 여러(특히 마크다운) 형태의 텍스트와 테마를 소스로 하여 정적 HTML 웹사이트를 제너레이트하는 툴이다. Ruby 스크립트로 만들어져 있으나, 블로그를 만드는 데에는 루비를 전혀 몰라도 된다. 워드프레스를 사용하여 블로그를 만드는 노력이면 워드프레스보다 훨씬 더 빠르고 보안에도 뛰어난 블로그를 깃허브에 무료로 만들 수 있고, 별도의 페이지를 만들기도 쉽다. 또한, HTML과 CSS에 대한 약간의 지식만 있으면 페이지는 물론 각 포스트마다 다른 레이아웃을 줄 수도 있다.</p>

<!-- more -->

<h2 id="section">설치</h2>

<p>맥 OS X에는 루비가 이미 설치되어 있으므로 터미널에서 <code>ruby -v</code>를 입력하여 루비 버전을 체크한 후 다음 명령으로 지킬을 설치한다.</p>

<pre><code>[sudo] gem install jekyll
</code></pre>

<p><code>[sudo]</code>가 필요한 경우엔 <code>[]</code>없이 <code>sudo gem install jekyll</code>을 입력한다. 만약, RubyGems 버전과 관련한 에러가 나면 <code>sudo gem update --system</code>으로 업데이트한 후 설치하면 대부분 해결할 수 있다.</p>

<p>이제 로컬 디렉토리에 지킬을 설치하고 온라인 깃허브에 자신의 블로그를 올릴 차례이다. 이 블로그 주소와 같이 <code>nolboo.github.io</code> 계정주소로 생성하는 경우와 <code>nolboo.github.io/blog</code>처럼 프로젝트 페이지 주소로 생성하는 경우가 있다. 전자의 경우가 훨씬 사용하기 쉽다.</p>

<h2 id="section-1">계정 주소 페이지</h2>

<pre><code>jekyll new 깃허브사용자명.github.com // 깃허브사용자명.github.com 디렉토리를 만들어 기본 디렉토리와 화일을 생성한다.
</code></pre>

<p>깃허브사용자명.github.com으로 만들면 별도의 비용없이도 자신의 블로그 주소를 가질 수 있다. 자신의 경우에 맞게 <code>깃허브사용명</code>을 입력한다.</p>

<pre><code>cd 깃허브사용자명.github.com
jekyll serve --watch
</code></pre>

<p>이제 웹브라우저 주소창에 <code>localhost:4000</code>을 입력하면 내 컴퓨터(로컬)에서 디폴트 페이지로 생성된 지킬 사이트를 볼 수 있다.</p>

<p><a href="http://www.flickr.com/photos/55689896@N03/10289345933/" title="지킬 첫모습"><img src="http://farm8.staticflickr.com/7413/10289345933_7fefe3a053.jpg" width="500" height="325" alt="basic-jekyll" /></a></p>

<p>지킬은 웹서버를 내장하고 있어 아파치나 NgineX와 같은 별도의 웹서버를 띄우지 않고도 사이트를 확인할 수 있다. <code>--watch</code>는 사이트를 변경하는 대로 백그라운드에서 제너레이트하여 브라우저에서 변경사항을 바로 확인할 수 있는 옵션이다.</p>

<ul>
  <li><em>리눅스와 윈도우는 놀부가 직접 테스트해 볼 수가 없으니 <a href="http://jekyllrb.com/docs/installation/">공식문서</a>와 <a href="http://www.madhur.co.in/blog/2011/09/01/runningjekyllwindows.html">추천글</a>로 대치한다.</em></li>
</ul>

<p>깃허브에서 <code>깃허브사용자명.github.com</code>이란 이름으로 새로운 온라인 저장소를 만든다. 깃허브나 커맨드 라인이 생소하면 <a href="http://j.mp/18GPAt2">완전초보를 위한 깃허브</a>를 참조한다.</p>

<pre><code>git init
git remote add origin 저장소URL
git add .
git commit -m "Initialize blog"
git push origin master
</code></pre>

<p>이제 끝났다. 지킬에서 페이지를 생성하는 것이 시간이 걸리는 경우가 있기 때문에 보통 10분 정도 기다리면(바로 반영되는 경우도 많다.) <code>깃허브사용자명.gthub.io</code>에서 내 블로그를 볼 수 있다. 약간 복잡한 프로젝트 주소로 설정하는 것에 관심없는 사람은 </p>

<h2 id="section-2">프로젝트 주소 페이지</h2>

<p>프로젝트 페이지로 만들 때 상대경로를 써야하기 때문에 조금 더 복잡해진다.</p>

<pre><code>jekyll new blog // blog 디렉토리를 만들어 기본 디렉토리와 화일을 생성한다.
cd blog
jekyll serve --watch
</code></pre>

<p>여기까지는 거의 동일하다.</p>

<pre><code>git init
git checkout --orphan gh-pages
</code></pre>

<p>깃허브에 <code>blog</code>란 이름으로 새 저장소를 만들고(로컬 디렉토리와 같은 이름으로 만드는 것이 나중에 기억하거나 유지보수하기가 좋다.) 저장소url을 복사한다.</p>

<pre><code>git remote add origin 저장소url
git add .
git commit -m "Initialize blog"
git push origin gh-pages  // 반드시 gh-pages 브랜치로 푸시해야 깃허브가 블로그 페이지를 만들어 준다. 
</code></pre>

<p>이제 <code>깃허브사용자명.github.io/blog</code>의 주소로 가면 자신의 블로그를 볼 수 있다.</p>

<p><a href="http://www.flickr.com/photos/55689896@N03/10289218326/" title="상대주소가 지정안된 화면"><img src="http://farm6.staticflickr.com/5532/10289218326_e4a2f03264.jpg" width="500" height="425" alt="project-no-css" /></a></p>

<p>이런! 그러나, 기본 CSS 스타일이 적용되지 않았다. 이제부터 조금 수고를 해줘야한다.(템플릿 등이 익숙하지 않은 사람에겐 <strong>계정주소</strong>로 설정하는 것이 좋다.)</p>

<h3 id="section-3">상대주소 지정</h3>

<p><code>_config.yml</code>화일을 텍스트에디터로 열어 baseurl 값을 저장소이름과 동일하게 설정한다.</p>

<pre><code>name: Your New Jekyll Site // 자신이 원하는 멋진 블로그 이름으로 변경한다.
markdown: redcarpet
pygments: true

baseurl: "/blog" // 이 부분을 반드시 추가하여야 한다.
</code></pre>

<p><code>index.html</code> 화일을 다음과 같이 변경하여 상대경로로 변경한다.</p>

<p><a href="http://www.flickr.com/photos/55689896@N03/10289443045/" title="index.html by n0lb00, on Flickr"><img src="http://farm4.staticflickr.com/3786/10289443045_20c91b2f4d_z.jpg" width="640" height="235" alt="index.html" /></a></p>

<p><code>_layout</code> 디렉토리 안의 <code>default.html</code>의 <code>head</code> 태그의 스타일 시트의 경로를 상대경로로 변경하여야 한다.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;head&gt;</span>
</span><span class="line">    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">&quot;utf-8&quot;</span><span class="nt">&gt;</span>
</span><span class="line">    <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">&quot;X-UA-Compatible&quot;</span> <span class="na">content=</span><span class="s">&quot;IE=edge,chrome=1&quot;</span><span class="nt">&gt;</span>
</span><span class="line">    <span class="nt">&lt;title&gt;</span>지킬로 깃허브에 무료 블로그 만들기<span class="nt">&lt;/title&gt;</span>
</span><span class="line">    <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">&quot;viewport&quot;</span> <span class="na">content=</span><span class="s">&quot;width=device-width&quot;</span><span class="nt">&gt;</span>
</span><span class="line">
</span><span class="line">    <span class="c">&lt;!-- syntax highlighting CSS --&gt;</span>
</span><span class="line">    <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">href=</span><span class="s">&quot;/css/syntax.css&quot;</span><span class="nt">&gt;</span> <span class="c">&lt;!-- /css 앞에 을 추가한다. --&gt;</span>
</span><span class="line">
</span><span class="line">    <span class="c">&lt;!-- Custom CSS --&gt;</span>
</span><span class="line">    <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">href=</span><span class="s">&quot;/css/main.css&quot;</span><span class="nt">&gt;</span> <span class="c">&lt;!-- /css 앞에 을 추가한다. --&gt;</span>
</span><span class="line">
</span><span class="line"><span class="nt">&lt;/head&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>저장한 후에 로컬에서 지킬을 실행할 때 다음과 같이 <code>-baseurl ''</code> 옵션을 주어 상대경로를 없애야 <code>localhost:4000</code>의 로컬 주소에서 블로그를 볼 수 있다.</p>

<pre><code>jekyll serve --baseurl '' --watch
</code></pre>

<p>블로그 제목과 계정 등을 텍스트에디터로 추가적으로 변경하고 깃허브로 푸시(업로드)한다.</p>

<pre><code>git add .
git commit -m "Change url method"
git push origin gh-pages
</code></pre>

<p>이제 <code>깃허브사용자명.github.io/blog</code>에서 자신의 블로그를 볼 수 있다.(10분 정도의 시간이 걸릴 수 있다)</p>

<p>복잡하다고 생각되는 사람은 제가 올려놓은 <a href="https://github.com/nolboo/Jekyll-Github-Page-blog">깃허브 소스</a>를 포크하여 자신의 로컬 디렉토리로 클론하여 시작할 수 있다. 깃허브에서 포크한 후 다음과 같은 터미널 명령어를 입력한다.</p>

<pre><code>git clone https://github.com/깃허브사용자명/blog
</code></pre>

<p>그러나, 이 경우에도 <code>_config.yml</code>에 <code>baseurl: /blog</code>는 직접 추가해야 한다.</p>

<h2 id="section-4">필수 엔진 설치</h2>

<h3 id="rdiscount-kramdown-redcarpet2">마크다운 프로세싱 엔진 설치 : rdiscount, kramdown, redcarpet2</h3>

<p>RDiscount는 C로된 마크다운 프로세싱 엔진이다. <code>[sudo] gem install rdiscount</code>로 설치한다. kramdown과 redcarpet2 등도 동일한 방법으로 설치할 수 있다. 기본 마크다운을 사용한다면 차후에 좀 더 필요성을 느낄 때 설치하여도 된다.</p>

<h3 id="pygmentshttppygmentsorg"><a href="http://pygments.org/">Pygments</a></h3>

<p>Pygments는 파이썬 기반 구문 하일라이터이며, 코드를 이쁘게 보여준다. <code>[sudo] easy_install Pygments</code>로 설치한다.</p>

<h2 id="section-5">지킬 기본 디렉토리 구조</h2>

<p>디렉토리와 설정화일인 <code>_config.yml</code>은 구조와 설명은 참고적으로 설명한다. 그러나, <strong>자신이 작성할 블로그글을 <code>_post</code> 안에 <code>YYYY-MM-DD-[POST SLUG].[FORMAT</code> 형식으로 포스트 화일명을 지정하는 것은 엄격하게 지켜야 한다.</strong></p>

<ul>
  <li>_config.yml // 전역 환경설정 화일</li>
  <li>_layouts // 기본 레이아웃
    <ul>
      <li>default.html</li>
      <li>post.html</li>
    </ul>
  </li>
  <li>_posts
    <ul>
      <li>2013-09-14-welcome-to-jekyll.markdown // 기본 블로그 포스팅</li>
    </ul>
  </li>
  <li>_site // 제너레이트된 블로그가 위치하는 곳</li>
  <li>css
    <ul>
      <li>main.css</li>
      <li>syntax.css // 코드 하일라이트 스타일링</li>
    </ul>
  </li>
  <li>index.html</li>
</ul>

<h3 id="configyml">_config.yml</h3>

<p>환경설정은 <a href="https://en.wikipedia.org/wiki/YAML">YAML 형식</a>을 사용한다.</p>

<p><code>name</code>과 <code>description</code>의 따옴표 안에 자신의 것을 넣어 준다. 특수문자를 포함하지 않으면 따옴표를 사용할 필요도 없다.</p>

<h3 id="includes">_includes</h3>

<p><code>template partials</code>(혹은 워드프레스의 <code>get_header()</code> 명령)에 친숙하다면 includes 디렉토리는 같은 일을 한다. 헤더와 푸터 같이 공통의 화일을 같는 포스트와 페이지의 테마 빌더이다. 디렉토리나 화일 앞의 <code>_</code>을 붙이면 웹사이트를 제너레이트할 때 복사되지 않는다.</p>

<h3 id="layouts">_layouts</h3>

<p>이것도 테마에 사용되는 폴더이다. 포스트의 레이아웃 화일을 저장한다. 여러 개의 레이이웃을 사용할 수 있으며, 대부분의 블로그 포스트는 <code>post</code> 레이아웃을 사용하고, 각 포스트의 텍스트 컨텐츠, 공유버튼, Disqus 댓글 등을 포함한다. 댓글과 공유버튼이 없는 <code>posts-no-comments</code>라는 레이아웃을 사용하는 페이지도 있다. 너비가 꽉차는 포트폴리오 레이아웃을 사용하기도 한다.</p>

<h3 id="posts">_posts</h3>

<p>마크다운(또는 HTML/Textile) 블로그 포스트 화일을 넣는 곳이다.</p>

<h3 id="site">_site</h3>

<p>컴파일된 블로그 사이트는 <code>_site</code>에 옮겨진다.</p>

<h2 id="section-6">블로그 포스트 추가</h2>

<h3 id="front-matter">Front-matter</h3>

<p>프론트매터는 지킬에게 이 화일을 처리해야할 방법을 알려주는 일종의 메타데이타이다. 화일의 제일 앞에 위치해야 한다. <strong>지킬은 front matter 블록으로 시작되는 화일(.html이라고 할지라도)만 처리한다.</strong></p>

<pre><code>---
layout: post
title: Blogging Like a Hacker
---
</code></pre>

<p>각 블로그 포스트의 front matter에는 “title”과 “layout” 필드는 반드시 들어가야 한다. date는 화일 이름에 들어가니 필수는 아니다.</p>

<h3 id="section-7">마크다운으로 포스트 작성하기</h3>

<p><code>_posts</code> 폴더에 모든 블로그 포스트 컨텐츠와 메타데이타가 있다. 지킬은 매우 스마트해서 이 폴더에 Markdown, HTML 과 다른 포맷을 섞어 넣을 수도 있다.</p>

<p>블로그를 포스트하려면 마크다운 화일을 <code>_posts</code> 폴더에 떨어뜨리면 된다. 그러나, 포스트와 화일의 이름은 다음과 같은 이름 구조를 가져야한다:</p>

<p><code>YYYY-MM-DD-[POST SLUG].[FORMAT]</code></p>

<p>예로, 2013년 9월 14일에 마크다운 포맷으로 “best-blog-platforms”(한글은 피해야 한다.)에 대한 포스트를 썼다면 다음과 같이 이름붙인다.</p>

<p><code>2013-10-15-best-blog-platforms.md</code></p>

<p><a href="https://en.wikipedia.org/wiki/Clean_URL#Slug">post slug</a>는 포스트 이름의 URL 친화적인 형식을 말한다. 스페이스나 이상한 문자와 URL에서 보통 허용되지 않는 것을 쓰지말라는 것이다. 표준 관례는 모든 문자는 소문자, 스페이스 대신 <code>-</code>를, 비교적 짧은 slug를 사용하는 것을 포함한다.</p>

<p>이제 깃허브에 나만의 주소를 가진 블로그를 만들고 마크다운으로 블로그 포스트를 작성할 수 있다! 모든 문서를 텍스트에디터에서 작성할 수 있는 마크다운이 익숙하지 않은 분들은 <a href="http://j.mp/157wQmp">존 그루버 마크다운 페이지 번역</a>을 보면 쉽게 따라 할 수 있다.</p>

<h2 id="httpjekyllrbcomdocsmigrations"><a href="http://jekyllrb.com/docs/migrations/">마이그레이션</a></h2>

<p>지킬은 워드프레스, Blogger, Tumblr, Posterous, 드루팔, Movable Type, Typo, TextPattern, Mephisto 등에서 블로그를 <a href="http://jekyllrb.com/docs/migrations/">마이그레이션</a>할 수 있다.</p>

<h2 id="section-8">기타 참고 사항</h2>

<ul>
  <li><a href="http://jekyllthemes.org/">지킬 테마 모음</a></li>
  <li><a href="http://www.richbray.me/muffin/">Sass기반 지킬 블로그 테마: 머핀</a></li>
  <li>지킬 기반 블로그 플랫폼
    <ol>
      <li><a href="http://octopress.org/">옥토프레스</a> : 이 블로그는 여러 편의 때문에 옥토프레스로 먼저 만들어졌다. 설치방법은 <a href="http://j.mp/1b4M9AD">옥토프레스로 블로깅하기</a> 참조.</li>
      <li><a href="http://jekyllbootstrap.com/">지킬 부트스트랩</a></li>
    </ol>
  </li>
  <li>지킬을 깃허브에 적용할 때 아쉬운 점은 보안상의 문제로 플러그인을 사용할 수 없다는 것이다. 그러나 사이트를 아예 제너레이트한 다음 깃허브로 푸시하면 대부분 문제없이 사용할 수 있다. 다양한 플러그인은 <a href="http://jekyllrb.com/docs/plugins/">지킬 사이트</a>와 <a href="http://www.jekyll-plugins.com/">이곳</a>에서 볼 수 있다. </li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[완전 초보를 위한 깃허브]]></title>
    <link href="http://nolboo.github.io/blog/2013/10/06/github-for-beginner/"/>
    <updated>2013-10-06T20:14:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/10/06/github-for-beginner</id>
    <content type="html"><![CDATA[<p>원문 :  </p>

<ol>
  <li><a href="http://j.mp/1g3el6I">GitHub For Beginners: Don’t Get Scared, Get Started</a></li>
  <li><a href="http://j.mp/GzCMeO">GitHub For Beginners: Commit, Push And Go</a></li>
</ol>

<p>[중략] 깃의 필요성 등에 대해 역설함.</p>

<p>컴퓨터를 사용하는 모든 지식 근로자는 깃허브를 사용할 이유가 있다. 만약, 당신이 깃허브 사용법을 이해하는 것을 포기했다면, 이 글은 당신을 위한 것이다.</p>

<p>깃허브에 대한 중 주된 오해 중 하나는 그것이 컴퓨터 언어나 컴파일러나 마찬가지로 코딩과 관련된 개발툴이라는 것이다. 그러나, 페이스북이나 플리커와 같은 소셜 네트워크와 크게 다르지 않다. 프로필을 만들고 공유할 프로젝트를 올릴 수 있고, 다른 계정들을 팔로우하여 다른 사용자들과 소통할 수 있다. 많은 사용자가 프로그램과 코드 프로젝트를 저장하지만, 당신이 자랑할만한 프로젝트 폴더의 텍스트 문서나 다른 형식의 화일을 저장하는 것을 막는 것도 없다.</p>

<p>[중간요약] : 깃허브에 올리는 모든 것은 사용자가 지적재산권을 갖으며, 코드에 대한 어떤 지식이 없어도 깃허브를 사용할 수 있다.</p>

<h2 id="what-is-git-">What Is Git?(깃이 뭐지?)</h2>
<p>깃허브의 심장에서 작동되는 소프트웨어인 깃(Git: 재수없고 멍청한 놈, 자식)을 만든 유명한 소프트웨어 개발자 리누스 토발즈에 감사한다. 깃은 프로젝트의 어떤 부분도 겹쳐쓰지 않게 프로젝트의 변경을 관리하는 버전관리 소프트웨어이다.</p>

<!-- more -->

<p>왜 깃같은 것을 사용해야 하나? 당신과 동료가 동시에 같은 웹사이트에서 페이지를 업데이트하고 있다고 하자. 당신이 무언가를 변경하고 저장한 다음 웹사이트에 그것을 업로드한다. 지금까지는 좋았다. 문제는 동료가 동시에 같은 페이지에서 작업할 때이다. 누군가의 작업은 겹쳐쓰여질 것이고 지워질 것이다. </p>

<p>깃과 같은 버전관리 앱은 그런 일을 방지한다. 당신과 동료는 같은 페이지에 각자의 수정사항을 각각 업로드할 수 있고, 깃은 두 개의 복사본을 저장한다. 나중에, 당신들은 그대로 어떤 작업도 잃어버리지 않고 변경사항들을 병합할 수 있다. 깃은 이전에 만들어진 모든 변경사항의 “스냅샷”을 저장하기 때문에 이전 시점의 어떤 버전으로 되돌릴 수도 있다.</p>

<p>깃을 사용할 때 어려운 점은 90년대 해커와 같이 코드를 타이핑하는 명령어(커맨드 라인 - 맥 사용자라면 터미널)를 사용하여 접근해야하는 것이다. 이것은 요즘 컴퓨터 사용자에겐 까다로운 일일 수는 있다. 이제 깃허브를 들여다보자.</p>

<p>깃허브는 두 가지 방식으로 깃을 더 편리하게 해준다. 먼저, <a href="http://github.com/">깃허브 소트프웨어를 다운로드</a>하면, 로컬에서 당신의 프로젝트를 관리할 수 있게하는 비주얼 인터페이스를 제공한다. 두번째는, Github.com에 계정을 생성하면 웹에서 프로젝트를 버전관리할 수 있으며, 평가측정 등의 소셜 네트워크 기능을 사용할 수 있다.</p>

<p>다른 깃허브 사용자의 프로젝트를 둘러볼 수 있고, 그것들을 변경하거나 배우기 위해 자신만의 복사본을 다운로드할 수도 있다. 다른 사용자도 당신의 공개 프로젝트에 대해 같은 걸 할 수 있으며 에러를 발견해서 해결책을 제안할 수도 있다. 어느 경우든, 깃이 모든 변경사항에 대한 “스냅샷”을 저장하기 때문에 어떤 데이타도 잃어버리지 않는다.</p>

<p>깃을 배우지 않고 깃허브를 사용할 수 있지만, 사용하는 것과 이해하는 것은 큰 자이점이 있다. 깃을 이해하기 전에도 깃허브를 사용할 수 있으며, 나도 진짜로 이해하는 것은 아니다. 이 튜토리얼에선, 커맨드 라인에서 깃을 사용하는 것을 배울 것이다.</p>

<h2 id="words-people-use-when-they-talk-about-git-">Words People Use When They Talk About Git(기본 어휘)</h2>

<p>이 튜토리얼에서 반복적으로 사용하려고 하는 몇 개의 용어가 있다. 나도 배우기 시작하기 전에는 들어본 적이 없는 것들이다. 여기 중요한 것들이 있다:</p>

<p><strong>커맨트 라인(Command Line):</strong> 깃 명령어를 입력할 때 사용하는 컴퓨터 프로그램. 맥에선 터미널이라고 한다. PC에선 기본적인 프로그램이 아니어서 처음엔 깃을 다운로드해야 한다(다음 섹션에서 다룰 것이다). 두 경우 모두 마우스를 사용하는 것이 아닌 프롬프트로 알려진 텍스트 기반 명령어를 입력한다.</p>

<p><strong>저장소(Repository):</strong> 프로젝트가 거주(live)할 수 있는 디렉토리나 저장 공간. 깃허브 사용자는 종종 “repo”로 줄여서 사용한다. 당신의 컴퓨터 안의 로컬 폴더가 될 수도 있고, 깃허브나 다른 온라인 호스트의 저장 공간이 될 수도 있다. 저장소 안에 코드 화일, 텍스트 화일, 이미지 화일을 저장하고, 이름붙일 수 있다.</p>

<p><strong>버전관리(Version Control):</strong> 기본적으로, 깃이 서비스되도록 고안된 목적. MS 워드 작업할 때, 저장하면 이전 화일 위에 겹쳐쓰거나 여러 버전으로 나누어 저장한다. 깃을 사용하면 그럴 필요가 없다. 프로젝트 히스토리의 모든 시점의 “스냅샷”을 유지하므로, 결코 잃어버리거나 겹쳐쓰지 않을 수 있다.</p>

<p><strong>커밋(Commit):</strong> 깃에게 파워를 주는 명령이다. 커밋하면, 그 시점의 당신의 저장소의 “스냅샷”을 찍어, 프로젝트를 이전의 어떠한 상태로든 재평가하거나 복원할 수 있는 체크포인트를 가질 수 있다.</p>

<p><strong>브랜치(Branch):</strong> 여러 명이 하나의 프로젝트에서 깃 없이 작업하는 것이 얼마나 혼란스러울 것인가? 일반적으로, 작업자들은 메인 프로젝트의 브랜치를 따와서(branch off), 자신이 변경하고 싶은 자신만의 버전을 만든다. 작업을 끝낸 후, 프로젝트의 메인 디렉토리인 “master”에 브랜치를 다시 “Merge”한다.</p>

<h2 id="git-specific-commands-">Git-Specific Commands(주요 명령어)</h2>

<p>깃은 리눅스와 같은 큰 프로젝트를 염두에 두고 디자인되었기 때문에, 깃 명령어는 아주 많다. 그러나, 깃의 기본을 사용할 때에는 몇 개의 명령어만 알면된다. 모두 “git”이란 단어로 시작된다.</p>

<p><strong>git init:</strong> 깃 저장소를 초기화한다. 저장소나 디렉토리 안에서 이 명령을 실행하기 전까지는 그냥 일반 폴더이다. 이것을 입력한 후에야 추가적인 깃 명령어들을 줄 수 있다.</p>

<p><strong>git config:</strong> “configure”의 준말, 처음에 깃을 설정할 때 가장 유용하다.</p>

<p><strong>git help:</strong> 명령어를 잊어버렸다? 커맨드 라인에 이걸 타이핑하면 21개의 가장 많이 사용하는 깃 명령어들이 나타난다. 좀 더 자세하게 “git help init”이나 다른 용어를 타이핑하여 특정 깃 명령어를 사용하고 설정하는 법을 이해할 수도 있다.</p>

<p><strong>git status:</strong> 저장소 상태를 체크. 어떤 화일이 저장소 안에 있는지, 커밋이 필요한 변경사항이 있는지, 현재 저장소의 어떤 브랜치에서 작업하고 있는지 등을 볼 수 있다.</p>

<p><strong>git add:</strong> 이 명령이 저장소에 새 화일들을 추가하진 <em>않는다</em>. 대신, 깃이 새 화일들을 지켜보게 한다. 화일을 추가하면, 깃의 저장소 “스냅샷”에 포함된다.</p>

<p><strong>git commit:</strong> 깃의 가장 중요한 명령어. 어떤 변경사항이라도 만든 후, 저장소의 “스냅샷”을 찍기 위해 이것을 입력한다. 보통 “git commit -m “Message hear.” 형식으로 사용한다. <code>-m</code>은 명령어의 그 다음 부분을 메시지로 읽어야 한다는 것을 말한다.</p>

<p><strong>git branch:</strong> 여러 협업자와 작업하고 자신만의 변경을 원한다? 이 명령어는 새로운 브랜치를 만들고, 자신만의 변경사항과 화일 추가 등의 커밋 타임라인을 만든다. 당신의 제목이 명령어 다음에 온다. 새 브랜치를 “cats”로 부르고 싶으면, <code>git branch cats</code>를 타이핑한다.</p>

<p><strong>git checkout:</strong> 글자 그대로, 현재 위치하고 있지 않은 저장소를 “체크아웃”할 수 있다. 이것은 체크하길 원하는 저장소로 옮겨가게 해주는 탐색 명령이다. master 브랜치를 들여다 보고 싶으면, <code>git checkout master</code>를 사용할 수 있고, <code>git checkout cats</code>로 또 다른 브랜치를 들여다 볼 수 있다.</p>

<p><strong>git merge:</strong> 브랜치에서 작업을 끝내고, 모든 협업자가 볼 수 있는 master 브랜치로 병합할 수 있다. <code>git merge cats</code>는 “cats” 브랜치에서 만든 모든 변경사항을 master로 추가한다.</p>

<p><strong>git push:</strong> 로컬 컴퓨터에서 작업하고 당신의 커밋을 깃허브에서 온라인으로도 볼 수 있기를 원한다면, 이 명령어로 깃허브에 변경사항을 “push”한다.</p>

<p><strong>git pull:</strong> 로컬 컴퓨터에서 작업할 때, 작업하고 있는 저장소의 최신 버전을 원하면, 이 명령어로 깃허브로부터 변경사항을 다운로드한다(“pull”).</p>

<h2 id="setting-up-github-and-git-for-the-first-time--">Setting Up GitHub And Git For The First Time(처음으로 깃/깃허브 설정하기)</h2>

<p>먼저, <a href="https://github.com/">GitHub.com</a>에 가입한다. 다른 소셜 네트워크에 가입하는 것처럼 간단하다.</p>

<p>로컬 컴퓨터에서 작업하려면 깃을 설치해야 한다. <a href="http://git-scm.com/downloads">필요에 따라</a> 윈도우, 맥, 리눅스 용 깃을 설치하라.</p>

<p>이제 커맨드 라인으로 넘어갈 시점이다. 윈도우에선 방금 설치한 Git Bash 앱으로, OS X에선 터미널로 시작한다. 깃에 자신을 소개할 차례이다. 다음 코드를 타이핑한다:</p>

<pre><code>git config --global user.name "Your Name Here"
</code></pre>

<p>물론, “Your Name Here”의 인용부호 안에 자신의 이름을 넣어야 한다.</p>

<p>다음엔, 당신의 이메일을 말해준다. 조금 전에 GitHub.com을 가입할 때 사용한 이메일이어야 한다. 다음과 같이 한다:</p>

<pre><code>git config --global user.email "your_email@youremail.com"
</code></pre>

<p>이것이 로컬 컴퓨터에서 깃을 사용할 때 필요한 모든 것이다. 원한다면, 깃과 소통할 때마다 GitHub.com 계정에 로드인하는 것을 요청하지 않도록 깃을 설정할 수 있다. 이것과 관련된 풀 튜토리얼은 <a href="https://help.github.com/articles/set-up-git">깃허브에 있다</a>.</p>

<p><img src="http://readwrite.com/files/Screen%20Shot%202013-09-25%20at%205.01.04%20PM.png" alt="" /></p>

<h2 id="creating-your-online-repository--">Creating Your Online Repository(온라인 저장소 만들기)</h2>

<p>이제 프로젝트가 거주할 장소를 만들 시점이다. 깃과 깃허브는 당신의 프로젝트와 그 화일들, 깃이 저장한 화일들의 모든 버전에 접근할 수 있는 디지털 디렉토리나 저장공간을 저장소(repository 줄여서 repo)라고 한다.</p>

<p>GitHub.com으로 돌아가서 사용자명 다음에 있는 작은 책 아이콘을 클릭한다. 혹은, 모든 아이콘이 다 똑같아 보인다면 <a href="https://github.com/new">new repository page</a>로 간다. 저장소에 짧고 기억할만한 이름을 준다. 재미삼아 public으로 해본다.</p>

<p><img src="http://readwrite.com/files/Screen%20Shot%202013-09-25%20at%205.06.48%20PM.png" alt="" /></p>

<p>“Initialize this repository with a README.” 앞의 체크박스는 신경쓰지 않는다. Readme 화일은 보통 프로젝트에 관해 설명하는 텍스트 화일이다. 여기선 연습삼아 로컬에서 자신의 Readme 화일을 만들 것이다.</p>

<p>녹색의 “Create Repository” 버튼을 클릭한다. 이제 프로젝트가 거주할 온라인 공간을 가진 것이다.</p>

<h2 id="creating-your-local-repository--">Creating Your Local Repository(로컬 저장소 만들기)</h2>

<p>온라인에서 거주하는 프로젝트의 공간을 방금 만들었다. 그러나, 그 곳이 작업할 공간은 아니다. 컴퓨터에서 작업할 것이므로, 로컬 디렉토리에 만들 저장소에 실제로 미러링해야 한다.</p>

<p>먼저 다음을 타이핑한다:</p>

<pre><code>mkdir ~/MyProject
</code></pre>

<p><code>mkdir</code>은 make directory의 준말이다. 깃 명령어는 아니고 비주얼 인터페이스 이전 시대에 일반적인 탐색 명령어이다. <code>~/</code>는 나중에 찾기쉽게 컴퓨터 화일 구조의 최상위 단계에 저장소를 만드는 것이다. 브라우저에서 <code>~/</code>를 입력하면 로컬 컴퓨터의 최상위 단계 디렉토리가 보일 것이다. 맥의 크롬인 경우 Users 폴더를 보여준다.</p>

<p>깃허브 저장소와 동일하게 MyProject로 이름짓는 것을 주목한다. 당신도 그렇게 해라.</p>

<p>타이핑한다:</p>

<pre><code>cd ~/MyProject
</code></pre>

<p><code>cd</code>는 change directory를 뜻하며, 역시 탐색 명령어이다. 방금 디렉토리를 만들었고, 그 디렉토리로 옮겨 들어갔다.</p>

<p>이제 마침내 깃 명령어를 사용한다. 다음 줄에 타이핑한다:</p>

<pre><code>git init
</code></pre>

<p><code>init</code>은 “initialize(초기화)”를 뜻한다. 이 코드를 입력하면 이 디렉토리를 로컬 깃 저장소라고 컴퓨터에게 말해주는 것이다. 폴더를 열면 - 이 새로운 깃 디렉토리는 전용 저장소 안에 숨겨진 화일 하나이기 때문에 - 어떤 차이를 보지 못할 것이다.</p>

<p><img src="http://readwrite.com/files/Screen%20Shot%202013-09-25%20at%205.10.04%20PM.png" alt="" /></p>

<p>그러나, 컴퓨터는 이제 이 디렉토리를 Git-ready로 인식하고, 깃 명령어를 입력할 수 있다. 이제 프로젝트가 거주할 온라인과 로컬 저장소를 모두 가졌다.</p>

<p>이제는 깃허브에 첫번째 커밋을 만들어서 프로젝트의 첫 부분을 추가하자. 다음 화면과 같은 MyProject라는 저장소를 만들었었다.</p>

<p><img src="http://readwrite.com/files/Screen%20Shot%202013-09-25%20at%205.10.04%20PM_0.png" alt="" /></p>

<p>다음을 입력한다:</p>

<pre><code>touch Readme.txt
</code></pre>

<p>역시 깃 명령어가 아니다. 또 하나의 기본 탐색 명령어이다. <code>touch</code>는 “create 만드는 것”을 뜻한다. 그 뒤에 무엇을 적던지 간에 만들어지는 것의 이름이다. 파인더나 시작메뉴에서 해당 폴더로 가보면 Readme.txt 화일이 만들어진 것을 볼 것이다.</p>

<p>다음을 입력:</p>

<pre><code>git status
</code></pre>

<p>커맨드 라인에서 다음과 유사한 몇 개의 텍스트 줄을 응답할 것이다:</p>

<pre><code># On branch master
# Untracked files:
#   (use "git add ..." to include in what will be committed)
#
#         Readme.txt
</code></pre>

<p><img src="http://readwrite.com/files/Screen%20Shot%202013-09-25%20at%205.24.55%20PM.png" alt="" /></p>

<p>뭐지? 먼저, 당신은 프로젝트의 master 브랜치 상에 있다. “branched off”하지 않았기 때문에 당연하다. 두번째론, Readme.txt이 “untracked” 화일로 리스트되었다. 현재는 깃이 무시한다는 것을 뜻한다. 깃이 주목하게 하기 위해, 다음을 입력한다:</p>

<pre><code>git add Readme.txt
</code></pre>

<p>커맨드 라인이 주는 힌트를 보면 첫번째 화일을 추가했다는 것을 알 수 있다. 지금까지의 프로젝트 “스냅샷”을 찍거나, “커밋”할 시점이다.</p>

<pre><code>git commit -m “Add Readme.txt”
</code></pre>

<p><img src="http://readwrite.com/files/Screen%20Shot%202013-09-25%20at%205.28.11%20PM.png" alt="" /></p>

<p>-m 플래그는 이미 말했듯이, 뒤따르는 텍스트는 메시지로 읽어야 한다. 커밋 메시지가 현재형인 것을 주목한다. 버전관리는 시간에 대해 유연성을 가지므로 현재형으로 작성해야 한다. 더 이전 버전으로 되돌아갈 수 있으므로 <em>커밋을 했던</em> 것을 적는 것이 아니라, <em>커밋한</em> 것을 적어야 한다.</p>

<p>이제, 로컬에서 작은 작업을 하고 깃허브에 첫 커밋을 ‘push’할 때이다.</p>

<p>“잠깐, 온라인 저장소를 로컬 저장소와 연결하지 않았다.”라고 생각할지 모르겠다. 당신이 맞다. 로컬 저장소와 온라인 저장소의 첫번째 실제 연결을 만들어보자.</p>

<h2 id="connect-your-local-repository-to-your-github-repository----">Connect Your Local Repository To Your GitHub Repository(로컬 저장소와 깃허브 저장소 연결하기)</h2>

<p>먼저, 깃에게 온라인 어딘가가 실제 원격(remote) 저장소인지를 말해주어야 한다. <code>git add</code> 명령어를 사용하기 전까지는 깃이 우리 화일을 인식하지 않는 것과 마찬가지로, 원격 저장소도 인식하지 않을 것이다.</p>

<p><code>https://github.com/username/myproject.git</code>에 “MyProject”라는 이름의 깃허브 저장소가 있다고 가정해보자. 물론, <code>username</code>은 자신의 깃허브 사용자명으로 바꿔야 한며, 저장소 제목도 자신의 깃허브 저장소 제목으로 바꿔야한다.</p>

<pre><code>git remote add origin https://github.com/username/myproject.git
</code></pre>

<p>첫 부분은 익숙하다; <code>git add</code>를 이미 화일과 써봤다. 화일이 비롯된(originated) 곳에서 새로운 위치를 가리키기 위해 <code>origin</code>이란 단어를 더했다.(해석이 약간 명료하지 못함. 원문: We’ve tacked the word origin onto it to indicate a new place from which files will originate.) <code>remote</code>는 <code>origin</code>의 설명자(descriptor)이며, <code>origin</code>이 로컬 컴퓨터가 아닌 온라인 어딘가를 가리킨다는 것이다. </p>

<p>역자주: 간단히 말하면, 온라인에 있는 <code>https://github.com/username/myproject.git</code> 저장소를 <code>origin</code>으로 지정한다.</p>

<p>이제 깃이 원격 저장소가 있는 곳과 로컬 저장소가 변경사항을 어디로 보낼지 알게되었다. 확인하기 위해, 다음을 입력:</p>

<pre><code>git remote -v
</code></pre>

<p><img src="http://readwrite.com/files/Screen%20Shot%202013-09-25%20at%205.36.22%20PM.png" alt="" /></p>

<p>이 명령어는 로컬 저장소가 알고있는 원격 <code>origin</code>에 대한 모든 항목을 보여준다. 지금까지 함께 하였다면, 단 하나이어야 한다. 두 개가 리스트된 것은 정보를 <em>push</em>하고 <em>fetch</em>할 수 있는 것을 뜻한다.</p>

<p>이제 깃허브 원격 저장소로 변경사항을 업로드나 “push” 해보자. 쉽다. 입력:</p>

<pre><code>git push
</code></pre>

<p>커맨드 라인에서 여러 줄에 걸쳐 연달아 내놓을 것이고, 마지막으로 “everything up-to-date.”과 같은 것을 밷아낼 것이다.</p>

<p><img src="http://readwrite.com/files/Screen%20Shot%202013-09-25%20at%205.52.53%20PM.png" alt="" /></p>

<p>단순 명령어만 입력했기 때문에 주의(warning) 메시지가 나온다. 내 저장소의 master 브랜치를 지정하도록 하려면 <code>git push origin master</code>로 입력할 수 있다. 지금은 하나의 브랜치만 있기 때문에 그렇게 하지 않았다.</p>

<p>깃허브에 다시 로그인한다. 이제 오늘 만든 커밋이 얼마나 되는지 깃허브가 추적하는 것을 알 수 있다. 저장소를 클릭해보면 로컬 저장소에서 만들었던 동일한 Reame.txt를 가지고 있을 것이다.</p>

<h2 id="all-together-now">All Together Now!</h2>

<p>축하한다, 이제 공식적으로 깃 사용자가 되었다! 저장소를 만들고 변경사항을 커밋할 수 있다. 이것이 대부분의 입문 튜토리얼의 끝나는 지점이다. </p>

<p>[중략] 이 정도면 회사에서 사장이 깃을 사용할 것을 요구하면 당장 디자인 화일을 깃허브에 올릴 정도는 될 것이라고 이야기하면서 디자인 화일 명 하나를 중심으로 여태 해온 것을 반복함.</p>

<h2 id="section">역자 요약</h2>

<pre><code>git config --global user.name "이름"
git config --global user.email "깃허브 메일주소" // 매번 물어보는 귀찮음을 피하기 위해 설정.

mkdir ~/MyProject   // 로컬 디렉토리 만들고
cd ~/myproject      // 디렉토리로 들어가서
git init            // 깃 명령어를 사용할 수 있는 디렉토리로 만든다.
git status          // 현재 상태를 훑어보고
git add 화일명.확장자  // 깃 주목 리스트에 화일을 추가하고 or
git add .           // 이 명령은 현재 디렉토리의 모든 화일을 추가할 수 있다.
git commit -m “현재형으로 설명” // 커밋해서 스냅샷을 찍는다.

git remote add origin https://github.com/username/myproject.git // 로컬과 원격 저장소를 연결한다.
git remote -v // 연결상태를 확인한다.
git push origin master // 깃허브로 푸시한다.
</code></pre>

<h2 id="git-resources">Git Resources</h2>

<ul>
  <li><a href="http://git-scm.com/book">Pro Git</a>. 깃을 배우고 사용하는 법에 대한 오픈소스 북. 분량이 많지만, 기본을 배우기 위해서는 3장까지만 읽으면 된다.</li>
  <li><a href="http://www.codeschool.com/courses/try-git">Try Git</a>. 코드스쿨과 깃허브가 팀을 짜서 이 속성 튜토리얼을 만들었다. 기본에 대해 좀 더 연습하길 원하면 도움이 될 것이다.</li>
  <li><a href="http://www.youtube.com/GitHubGuides">GitHub Guides</a>. 비주얼 학습자라면 깃허브의 공식 유투브 채널에서 시간을 보낼만하다. 특히 <a href="http://www.youtube.com/watch?v=8oRjP8yj2Wo&amp;list=PLg7s6cbtAD165JTRsXh8ofwRw0PqUnkVH">Git Basics</a> 네개의 시리즈에서 많은 것을 얻을 수 있다.</li>
  <li><a href="http://gitref.org/">Git Reference</a>. 명령어를 잊어버렸을 때는 용어 참조하기 좋은 사이트다. </li>
  <li><a href="http://rogerdudler.github.io/git-guide">Git - the simple guide</a>. 이 튜토리얼은 짧고 달콤하다. 깃의 기초에 대해 되살리고 싶다면 필요할 것이다.</li>
  <li><a href="https://help.github.com/articles/github-glossary">GitHub Glossary</a>. 역자가 추가한 깃허브 공식 용어 사전</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS로 웹사이트를 인쇄가능하게 만들기]]></title>
    <link href="http://nolboo.github.io/blog/2013/09/26/printable-css/"/>
    <updated>2013-09-26T21:40:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/09/26/printable-css</id>
    <content type="html"><![CDATA[<p><em>원문의 영어 단어는 쉬운데 해석하기가 어렵고 필요없는(?) 말이 많아서 필요한 부분만 발췌하였습니다.</em></p>

<p>원문 : <a href="http://www.creativebloq.com/responsive-web-design/make-your-website-printable-css-3132929">Make your website printable with CSS</a></p>

<p>이 방법은 개발자가 적은 노력으로 인쇄 페이지를 지원할 수 있는 방법이다.</p>

<!-- more -->

<h2 id="step-01-getting-started">Step 01. Getting started</h2>

<p>우선, 소스 웹 페이지와 비교하여 사이트를 어떻게 인쇄할 것인지를 생각해보자.</p>

<p><img src="http://media.creativebloq.futurecdn.net/sites/creativebloq.com/files/images/2013/05/Hannah/table.jpg" alt="" /></p>

<p>웹페이지는 무한대로 스크롤할 수 있지만, 인쇄된 페이지는 종이 크기에 제한된다. 웹페이지가 비디오, 오디오, 접촉을 통한 피드백도 가능한 접근성을 갖는 반면, 인쇄된 페이지는 철저히 보는 매체이다. 웹페이지는 비트맵 데이타(사진, 그래픽)와 벡터 데이타(서체, SVG)를 표현할 수 있지만, 일단 인쇄되면 종이 위에 비트맵 데이타일 뿐이다. 웹페이지는 인터랙티브하고 스크린 상의 엘리먼트를 변경할 수 있지만, 인쇄된 페이지는 그렇지 않다. 이러한 것들이 인쇄된 페이지의 컨텐츠에 대한 결정을 하는 요인이 되기 때문에 모두 기억해두는 것이 유용할 것이다.</p>

<p><img src="http://media.creativebloq.futurecdn.net/sites/creativebloq.com/files/images/2013/05/Hannah/01(67\).jpg" alt="" />
&gt; <strong>파이어폭스 테스크탑 브라우저에 본 예제 페이지. 오래 되었지만 아직 인쇄할만한다.</strong></p>

<p>페이지를 볼 때 사용자가 보길 원하는 것은 단 하나: 컨텐츠. 내 사이트이므로, 사용자가 인쇄할 때 유지해야할 페이지 상의 엘리먼트를 확실하게 하고 싶다:</p>

<ul>
  <li>브랜딩</li>
  <li>독자가 내 페이지를 찾는 방법</li>
  <li>저작권 문구</li>
  <li>회사의 CMS와 같은 크로스 브랜딩</li>
  <li>내 컨텐츠에 대한 링크 주소</li>
</ul>

<p>이에 반해, 대부분의 인쇄 사용자들이 보길 원하지 않는 다른 항목이 있다:</p>

<ul>
  <li>주 네비게이션</li>
  <li>보조 네비게이션</li>
  <li>사이트 검색</li>
  <li>소셜 아이콘과 링크</li>
</ul>

<p>마지막으로, 사용자나 내가 원하지 않는 몇 가지가 있다:</p>

<ul>
  <li>색상(특히 모노 프린터를 위해)</li>
  <li>배경 이미지(와 색상)</li>
  <li>타이밍/상호작용하는 엘리먼트(이미지 슬라이더의 사진과 같은)</li>
  <li>로고와 같은 화이트 이미지</li>
</ul>

<h2 id="step-02-make-a-home-for-print-styles">Step 02. Make a home for print styles</h2>

<p>프린트 스타일이 호출되기 위한 CSS를 설정하는 것이 첫번째 할일이다. RWD 코딩에 해봤다면, 다음은 친숙할 것이다:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="css"><span class="line"><span class="k">@media</span> <span class="nt">print</span> <span class="p">{</span>
</span><span class="line">  <span class="c">/* insert your style declarations here */</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>이런 접근으로만 한정되진 않는다. <code>&lt;head&gt;</code> 안에 <code>&lt;link&gt;</code>로 프린트 스타일을 호출할 수도 있다.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">type=</span><span class="s">&quot;text/css&quot;</span> <span class="na">href=</span><span class="s">&quot;/css/print.css&quot;</span> <span class="na">media=</span><span class="s">&quot;print&quot;</span><span class="nt">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>이 방법은 추가적인 HTTP 요청과 관련이 있다. 브라우저는 페이지를 렌더링할 때 프린트 스타일이 필요하지 않으나, 대부분 모든 CSS 화일을 내려받기 전 까지는 페이지를 렌더링하지 않을 것이다; 오페라는 예외이다. 게다가, 최신 브라우저는 모든 화일이 다운로드되기 전까지는 어떤 온로드 이벤트를 작동하지 않는다. 프린트 스타일은 매우 적은 선언만을 포함할 수 있기 때문에 화일을 분리한다고 해서 추가적인 HTTP 오버헤드와 렌더링 지연이나 이벤트 작동을 고려할 필요가 그리 잦은 것은 아니다.</p>

<p><img src="http://media.creativebloq.futurecdn.net/sites/creativebloq.com/files/images/2013/05/Hannah/02(63\).jpg" alt="" />
&gt; <strong>파이어폭스에서 PDF로 인쇄한 동일한 페이지. 몇 개가 사라지고 레이아웃이 단순해진 것을 볼 수 있다.</strong></p>

<h2 id="step-03-applying-the-styles">Step 03. Applying the styles</h2>

<p>내 로고는 텍스트이며, 컬러 프린터 사용자들이 빨간색으로 인쇄할 필요없도록 검정으로 변경할 것이다. </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="css"><span class="line"><span class="nf">#Banner</span> <span class="nt">p</span><span class="nf">#Title</span> <span class="p">{</span>
</span><span class="line">  <span class="k">font-size</span><span class="o">:</span> <span class="m">24pt</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="nf">#Banner</span> <span class="nt">p</span><span class="nf">#Title</span> <span class="nt">a</span><span class="o">,</span> <span class="nf">#Banner</span> <span class="nt">p</span><span class="nf">#Title</span> <span class="nt">a</span><span class="nd">:link</span><span class="o">,</span> <span class="nf">#Banner</span> <span class="nt">p</span><span class="nf">#Title</span> <span class="nt">a</span><span class="nd">:visited</span> <span class="p">{</span>
</span><span class="line">  <span class="k">color</span><span class="o">:</span> <span class="m">#000</span><span class="p">;</span> <span class="c">/* change link to black text */</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>브라우저가 인쇄된 페이지에 페이지 주소를 포함할 수 있다는 것을 알지만, 몇몇 사용자는 그것을 무시하고 몇몇 페이지 주소는 너무 길다. 페이지에 이동경로 탐색이 있기 때문에 남기기로 선택한다. 사용자가 푸터에 인쇄될 주소를 읽을 수 없더라도, 적어도 내 사이트의 해당 페이지의 경로를 볼 수는 있다. 독자가 내 사이트에서 해당 페이지를 찾을 수 있도록 하는 두번째 목표를 달성한다.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="css"><span class="line"><span class="nf">#Bread</span> <span class="nt">a</span><span class="nd">:link</span><span class="o">,</span> <span class="nf">#Bread</span> <span class="nt">a</span><span class="nd">:visited</span> <span class="p">{</span>
</span><span class="line">  <span class="k">text-decoration</span><span class="o">:</span> <span class="k">underline</span><span class="p">;</span> <span class="c">/* leave a clue that it&amp;rsquo;s a link */</span>
</span><span class="line">  <span class="k">color</span><span class="o">:</span> <span class="m">#000</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="nf">#Bread</span> <span class="p">{</span>
</span><span class="line">  <span class="k">color</span><span class="o">:</span> <span class="m">#000</span><span class="p">;</span>
</span><span class="line">  <span class="k">font-size</span><span class="o">:</span> <span class="m">6pt</span><span class="p">;</span> <span class="c">/* make the text small */</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="nf">#Bread</span> <span class="o">&gt;</span> <span class="nt">a</span><span class="nd">:after</span> <span class="p">{</span>
</span><span class="line">  <span class="k">content</span><span class="o">:</span> <span class="s2">&quot;&quot;</span><span class="p">;</span> <span class="c">/* disable URL display if in #Content */</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>푸터에 있는 모든 것을 인쇄하길 원하지 않는다. 예를 들면 검색 박스를 인쇄하지 않도록 한다.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="css"><span class="line"><span class="nf">#Footer</span> <span class="p">{</span>
</span><span class="line">  <span class="k">font-size</span><span class="o">:</span> <span class="m">6pt</span><span class="p">;</span> <span class="c">/* make the text small */</span>
</span><span class="line">  <span class="k">color</span><span class="o">:</span> <span class="m">#000</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="nf">#SearchForm</span> <span class="p">{</span>
</span><span class="line">  <span class="k">display</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>푸터에 CMS 로고를 남긴다. (아마 독자가 신경쓰지 않을) URL을 보여줄 필요가 없으나, 브랜드는 남긴다. 크로스 브랜딩에 대한 네번째 목표이다.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="css"><span class="line"><span class="nf">#Footer</span> <span class="nt">img</span> <span class="p">{</span>
</span><span class="line">  <span class="k">float</span><span class="o">:</span> <span class="k">right</span><span class="p">;</span> <span class="c">/* defined elsewhere, included for completeness */</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>다섯번째 목표는 문맥에 따른 링크의 전체 주소를 보여주는 것이다. 모든 링크 뒤에 주소를 포함하곤한다: 그러나, 몇몇 링크 주소를 믿을 수 없이 긴 - 사용자가 다시 타이핑할 수 없을 정도로 - 문제가 있을 수 있다.</p>

<p><img src="http://media.creativebloq.futurecdn.net/sites/creativebloq.com/files/images/2013/05/Hannah/03(58\).jpg" alt="" />
&gt; <strong>크롬에서 인쇄 미리보기 대화 상자. 모든 인쇄 미리보기에서와 같이, 예상한 것에 대한 빠른 아이디어를 제공한다.</strong></p>

<p>하이퍼링크를 보여주기로 하였다면, 컨텐츠에 따라 제한하고 - 이동경로와 푸터에선 URL을 보여주지 않는다 - 가능하면 이미지에서 제외한 것 등을 기억하는 것이 중요하다.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="css"><span class="line"><span class="nf">#Content</span> <span class="nt">a</span><span class="nd">:after</span> <span class="p">{</span> <span class="c">/* select links in the content area only */</span>
</span><span class="line">  <span class="k">content</span><span class="o">:</span> <span class="s2">&quot; [&quot;</span> <span class="n">attr</span><span class="p">(</span><span class="n">href</span><span class="p">)</span> <span class="s2">&quot;] &quot;</span><span class="p">;</span>
</span><span class="line">  <span class="k">text-decoration</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span>
</span><span class="line">  <span class="k">display</span><span class="o">:</span> <span class="k">inline</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>이제 인쇄되길 원치않는 엘리먼트를 가려보자. 작은 화면에서 엘리먼트를 가리는 것 - RWD에선 좋은 아이디어가 아니지만 - 과 달리, 페이지는 이미 전부 다운로드되었고, 가려야 하는 엘리먼트는 인쇄 페이지에서 어떤 가치도 없어야 한다.</p>

<p>예제에서 네비게이션, 검색, 소셜 아이콘과 의미를 갖지 않는 다른 것들을 제거할 것이다.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="css"><span class="line"><span class="nf">#Nav</span><span class="o">,</span> <span class="nf">#FlyOutNav</span><span class="o">,</span> <span class="nf">#SubNav</span><span class="o">,</span> <span class="nc">.NoPrint</span><span class="o">,</span> <span class="nt">p</span><span class="nc">.CodeAlert</span><span class="o">,</span> <span class="nf">#SMLinks</span><span class="o">,</span> <span class="nf">#SearchForm</span> <span class="p">{</span>
</span><span class="line">  <span class="k">display</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>아직 필요한 것을 전부한 것은 아니다.중요한 것을 까먹기지 않기 위해 거의 모든 인쇄 스타일시트를 적용할 수 있는 디폴트 스타일 세트를 가지고 있다. 사이트마다 정기적으로 조정하지만, 필요에 따른 좋은 시작점이 된다:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
</pre></td><td class="code"><pre><code class="css"><span class="line"><span class="nt">body</span> <span class="p">{</span>
</span><span class="line">    <span class="k">background</span><span class="o">:</span> <span class="m">#fff</span><span class="p">;</span>
</span><span class="line">    <span class="k">color</span><span class="o">:</span> <span class="m">#000</span><span class="p">;</span>
</span><span class="line">    <span class="k">font-size</span><span class="o">:</span> <span class="m">8pt</span><span class="p">;</span>
</span><span class="line">    <span class="k">line-height</span><span class="o">:</span> <span class="m">150</span><span class="o">%</span><span class="p">;</span>
</span><span class="line">    <span class="k">margin</span><span class="o">:</span> <span class="m">0px</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="nt">hr</span> <span class="p">{</span>
</span><span class="line">    <span class="k">color</span><span class="o">:</span> <span class="m">#ccc</span><span class="p">;</span>
</span><span class="line">    <span class="k">background-color</span><span class="o">:</span> <span class="m">#ccc</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="nt">h1</span><span class="o">,</span> <span class="nt">h2</span><span class="o">,</span> <span class="nt">h3</span><span class="o">,</span> <span class="nt">h4</span><span class="o">,</span> <span class="nt">h5</span><span class="o">,</span> <span class="nt">h6</span><span class="o">,</span> <span class="nt">code</span><span class="o">,</span> <span class="nt">pre</span> <span class="p">{</span>
</span><span class="line">    <span class="k">color</span><span class="o">:</span> <span class="m">#000</span><span class="p">;</span>
</span><span class="line">    <span class="k">text-transform</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span> <span class="c">/* because sometimes I set all-caps */</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="nt">h1</span> <span class="p">{</span>
</span><span class="line">    <span class="k">font-size</span><span class="o">:</span> <span class="m">11pt</span><span class="p">;</span>
</span><span class="line">    <span class="k">margin-top</span><span class="o">:</span> <span class="m">1em</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="nt">h2</span> <span class="p">{</span>
</span><span class="line">    <span class="k">font-size</span><span class="o">:</span> <span class="m">10pt</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="nt">h3</span> <span class="p">{</span>
</span><span class="line">    <span class="k">font-size</span><span class="o">:</span> <span class="m">9pt</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="nt">h4</span><span class="o">,</span> <span class="nt">h5</span><span class="o">,</span> <span class="nt">h6</span> <span class="p">{</span>
</span><span class="line">    <span class="k">font-size</span><span class="o">:</span> <span class="m">8pt</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="nt">code</span><span class="o">,</span> <span class="nt">pre</span> <span class="p">{</span>
</span><span class="line">    <span class="k">font-size</span><span class="o">:</span> <span class="m">8pt</span><span class="p">;</span>
</span><span class="line">    <span class="k">background-color</span><span class="o">:</span> <span class="k">transparent</span><span class="p">;</span>
</span><span class="line">    <span class="c">/* just in case the user configured browser to print backgrounds */</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="nt">blockquote</span> <span class="p">{</span>
</span><span class="line">    <span class="k">background-image</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span>
</span><span class="line">    <span class="c">/* though they may not print, I’d rather be sure */</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="nt">a</span><span class="nd">:link</span><span class="o">,</span> <span class="nt">a</span><span class="nd">:visited</span> <span class="p">{</span>
</span><span class="line">    <span class="k">text-decoration</span><span class="o">:</span> <span class="k">underline</span><span class="p">;</span>
</span><span class="line">    <span class="k">color</span><span class="o">:</span> <span class="m">#000</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="nt">abbr</span><span class="nd">:after</span><span class="o">,</span> <span class="nt">acronym</span><span class="nd">:after</span> <span class="p">{</span> <span class="c">/* some HTML4 love */</span>
</span><span class="line">    <span class="k">content</span><span class="o">:</span> <span class="s2">&quot; (&quot;</span> <span class="n">attr</span><span class="p">(</span><span class="n">title</span><span class="p">)</span> <span class="s2">&quot;) &quot;</span><span class="p">;</span>
</span><span class="line">    <span class="c">/* I suspect I am one of the few who still use these elements */</span>
</span><span class="line">  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>이 스타일시트는 몇 가지 기본적인 것을 해낸다:</p>

<ul>
  <li>컨텐츠 주변의 여백을 제거한다.(사용자는 인쇄 설정에서 페이지 여백을 다룰 수 있다)</li>
  <li>서체 크기를 재설정하고 텍스트를 검정색으로 설정한다.</li>
  <li>페이지의 <code>&lt;abbr&gt;</code>과 <code>&lt;acronym&gt;</code> 타이틀 속성 값을 입력한다.(이미지의 <code>alt text</code>와 같은 엘리먼트에도 사용할 수 있지만, 적당한 것은 아니다.)</li>
</ul>

<p><img src="http://media.creativebloq.futurecdn.net/sites/creativebloq.com/files/images/2013/05/Hannah/04(61\).jpg" alt="" />
&gt; <strong>다른 종이 크기에서 테스트해야 한다. 랜드스케이프는 보기도 쉽고, 크기 조절 문제를 빠르게 테스트할 수 있게 한다.</strong></p>

<h2 id="step-04-further-tweaks">Step 04. Further tweaks</h2>

<p>사이트에 이미 모바일 레이아웃이 적용되었다면, 아마 선형 레이아웃에 고려한 스타일을 이미 갖고 있을 것입니다. 아무것도 하지 않았다면 시작점으로 모바일 친화적인 레이아웃을 사용하고, 네비게이션과 유지하길 원치 않는 엘리먼트를 꺼버릴 수 있다.</p>

<p>이제 다른 스크린 크기의 레이아웃을 고려하기 위해 다른 스타일을 생각해보자. 좋은 예는 뷰포트 사이즈에 기반한 이미지 사이즈를 크기 변경할 때이다.</p>

<p>많은 사이트의 특정 미디어 쿼리에서 100% 너비로 이미지를 크기변경하는 것을 보아왔다. 이건 종이 너비에 이미지를 무심히 맞춰버릴 수 있기에(때론 종이 전체에) 인쇄된 페이지에선 문제가 될 수 있다. 사용자 페이지와 잉크를 아낄 수 있게 이미지 크기를 줄이는 것을 고려하고, 몇 가지 경우엔 필요하다면 크기를 키우는 것까지도 고려해라.</p>

<p>종이에 위치하지 않은 레이아웃의 엘리먼트에 대해서도 생각해라. 예로, 플래쉬, 임베딩된 유투브 혹은 플레이할 수 있는 인터랙티브 위젯이 있는가?</p>

<p>인쇄 페이지에서 그것들을 같이 제거하는 것을 원할 것이다. 그렇지 않으면, 임베딩된 유투브 디비오는 많은 공간을 차지하거나 여백으로 나타날 것이다.</p>

<p><img src="http://media.creativebloq.futurecdn.net/sites/creativebloq.com/files/images/2013/05/Hannah/05(59\).jpg" alt="" />
&gt; <strong>어떤 유저는 페이지를 쉽게 읽게 하기위해 텍스트 크기를 키울 수 있다. 스타일을 조정할 필요가 있는지 이런 것을 테스트해라.</strong></p>

<h2 id="step-05-testing">Step 05. Testing</h2>

<p>모든 스타일이 준비되면, 테스트해라. 페이지를 프린트하지 않고 사용하는 두 가지 테크닉이 있다. 첫번째는 브라우저 인쇄 미리보기이다. - 스타일이 어떻게 해석되는지 알아보기 위한 빠른 방법이다. 두번째는 PDF로 인쇄해서 얻는 페이지를 보는 것이다.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[부트스트랩 3에서 새롭게 바뀐 것]]></title>
    <link href="http://nolboo.github.io/blog/2013/09/17/new-in-bootstrap3/"/>
    <updated>2013-09-17T23:09:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/09/17/new-in-bootstrap3</id>
    <content type="html"><![CDATA[<p>원문 : <a href="http://julienrenaux.fr/2013/08/11/whats-new-in-twitter-bootstrap-3/">What’s new in Twitter Bootstrap 3?</a></p>

<h2 id="scaffolding">Scaffolding</h2>

<ul>
  <li>모바일 퍼스트, 반응형 12행 그리드</li>
</ul>

<h2 id="section">그리드 시스템</h2>

<p><code>.span*</code>에서 <code>.col-xs</code>, <code>.col-sm-*</code>, <code>.col-md-*</code>, <code>.col-lg-*</code>로 변경.
디폴트로 fluid이므로 <code>.container-fluid</code>와 <code>.row-fluid</code>은 제거.</p>

<p>모바일, 태블릿, 테스트탑에서 그리드 예제:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;row&quot;</span><span class="nt">&gt;</span>
</span><span class="line">    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;col-xs-6 col-sm-6 col-md-6 col-lg-6&quot;</span><span class="nt">&gt;</span>6<span class="nt">&lt;/div&gt;</span>
</span><span class="line">    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;col-xs-6 col-sm-6 col-md-6 col-lg-6&quot;</span><span class="nt">&gt;</span>6<span class="nt">&lt;/div&gt;</span>
</span><span class="line"><span class="nt">&lt;/div&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<!-- more -->

<h2 id="section-1">반응형 디자인</h2>

<h3 id="section-2">반응형 이미지</h3>

<p>구글 맵스와 <a href="https://github.com/twbs/bootstrap/issues/1552">문제</a>가 있었는데, BS3에선 <code>.img-responsive</code> 클래스를 넣어 해결했다. 이 클래스는 이미지에 <code>max-width: 100%;</code>와 <code>height: auto;</code>를 적용하여 부모 엘리먼트에 따라 크기가 달라진다.</p>

<h3 id="section-3">반응형 유틸리티</h3>

<p><code>.visible-xs</code>, <code>.visible-sm</code>, <code>.visible-md</code>, <code>.visible-lg</code> 4개의 클래스로 크기별로 보이거나, <code>.hidden-xs</code>, <code>.hidden-sm</code>, <code>.hidden-md</code>, <code>.hidden-lg</code> 클래스로 숨길 수 있다.</p>

<h2 id="css">CSS</h2>

<p>글로발 CSS 설정, 기본 HTML 엘리먼트 스타일링
<code>*zoom: 1</code>, <code>-moz-box-shadow</code> 등의 hack을 없애고 IE7과 파이어폭스 3.6을 지원하지 않는다.</p>

<h3 id="typography">Typography</h3>

<p>헤딩, 리스트, 텍스트 클래스명이 좀 더 일관성있게 되었다. 예: .list-unstyled, .list-inline, .text-muted, .h1, .h2, .h3 등을 사용</p>

<h3 id="section-4">테이블</h3>

<p>기본적으로 <code>&lt;table&gt;</code>에 스타일링하지 않으며, <code>.table</code>을 사용하여 기본 스타일링을 한다.
<code>.table-hover</code>로 마우스 오버했을 때와 같이 <code>.active</code>로 열을 하일라이트할 수 있다.</p>

<h3 id="forms">Forms</h3>

<p><code>.input-prepend</code>, <code>.input-append</code>를 사용하지 않고 <code>input-group</code>을 사용한다.
수평폼도 모바일 퍼스트이므로, 768px 보다 작은 화면에서는 그냥 쌓인다.
<em><code>.form-control</code>과 함께 <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, <code>&lt;select&gt;</code> 엘리먼트는 기본적으로 <code>width: 100%;</code>로 설정된다.</em></p>

<p><code>.radio-inline</code>은 그대로이고 <code>.form-group</code>이 추가되었으며, 다음은 없어졌다:</p>

<ul>
  <li>.inline-help  </li>
  <li>.help-inline  </li>
  <li>.uneditable-input </li>
  <li>.form-search  </li>
  <li>.input-block-level  </li>
  <li>.controls-row </li>
  <li>.input-prepend  </li>
  <li>.input-append</li>
</ul>

<h4 id="height-sizing">Height sizing</h4>

<p><code>.input-small</code>, <code>.input-large</code> 등을 사용할 때 버튼 크기에 따라 폼의 높이도 변경된다.</p>

<h3 id="buttons">Buttons</h3>

<p>기본 버튼도 <code>.button-default</code>가 필요하며, <code>.btn-inverse</code>는 없어졌다. 나머지 버튼 크기는 <code>btn-xs</code>, <code>.btn-sm</code>, <code>.btn-lg</code>로 바뀌었다.</p>

<h3 id="images">Images</h3>

<p><code>.img-polaroid</code>는 없어졌으며, 보통의 inline(-block) 이미지를 위한 <code>.img-thumbnail</code>이 추가되었다. <em><code>.img-responsive</code> 클래스를 추가하여 반응형에 가깝게 사용할 수 있다.</em></p>

<h2 id="components">Components</h2>

<h3 id="dropdown-menus">Dropdown menus</h3>

<p>드랍다운 메뉴에 헤더를 줄 수 있다.</p>

<h3 id="buttons-1">Buttons</h3>

<p><code>.btn-group-justified</code> 클래스로 부모 엘리먼트의 전체 너비와 같은 크기를 가질 수 있다.</p>

<h3 id="alerts">Alerts</h3>

<p><code>.alert</code> 컴포넌트 안의 <code>hr</code> 엘리먼트는 alert 색의 경계선으로 스타일링될 것이다. 링크도 가독성을 위해 자동으로 알맞게 스타일링된다.</p>

<h3 id="navs">Navs</h3>

<p><code>.nav-list</code>가 없어졌고, List group이 대신한다. 왼쪽/오른쪽/아래쪽 탭이 없어졌다. <strong>자바스크립트 플러그인과 커스텀 CSS로 왼쪽/오른쪽 탭을 사용할 수 있다. 그러나 이제 핵심 기능에 포함되지 않는다.</strong></p>

<h3 id="navbar">Navbar</h3>

<p>navbar의 높이가 모바일 기기에선 44px에서 62px로, 데스크탑에선 50px로 커졌고, 박스 그림자나 그라디언트되지 않는다. <code>.navbar-search</code>, <code>.divider-vertical</code>, <code>.navbar-inner</code>가 없어졌으며, 변경된 것은 다음과 같다:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">BS2</th>
      <th style="text-align: left">BS3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">.navbar &gt; .nav</td>
      <td style="text-align: left">.navbar-nav</td>
    </tr>
    <tr>
      <td style="text-align: left">.btn-navbar</td>
      <td style="text-align: left">.navbar-toggle</td>
    </tr>
    <tr>
      <td style="text-align: left">.brand</td>
      <td style="text-align: left">.navbar-brand</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="list-groupnew">List group(NEW)</h3>

<h4 id="basic-list-group">Basic list group</h4>

<p>기본적으로 BS2의 <code>.nav-list</code>와 같다. <strong>리스트 그룹 항목엔 배지를 추가할 수 있으며, 자동으로 오른쪽에 위치한다.</strong></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;list-group&quot;</span><span class="nt">&gt;</span>
</span><span class="line">    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;list-group-item&quot;</span><span class="nt">&gt;</span>Cras justo odio<span class="nt">&lt;/li&gt;</span>
</span><span class="line">    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;list-group-item&quot;</span><span class="nt">&gt;</span>Dapibus ac facilisis in<span class="nt">&lt;/li&gt;</span>
</span><span class="line">    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;list-group-item&quot;</span><span class="nt">&gt;</span>Morbi leo risus<span class="nt">&lt;/li&gt;</span>
</span><span class="line"><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="linked-list-group">Linked list group</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;list-group&quot;</span><span class="nt">&gt;</span>
</span><span class="line">    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;#&quot;</span> <span class="na">class=</span><span class="s">&quot;list-group-item active&quot;</span><span class="nt">&gt;</span>Cras justo odio<span class="nt">&lt;/a&gt;</span>
</span><span class="line">    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;#&quot;</span> <span class="na">class=</span><span class="s">&quot;list-group-item&quot;</span><span class="nt">&gt;</span>Dapibus ac facilisis in<span class="nt">&lt;/a&gt;</span>
</span><span class="line">    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;#&quot;</span> <span class="na">class=</span><span class="s">&quot;list-group-item&quot;</span><span class="nt">&gt;</span>Morbi leo risus<span class="nt">&lt;/a&gt;</span>
</span><span class="line"><span class="nt">&lt;/div&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="custom-content">Custom content</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;list-group&quot;</span><span class="nt">&gt;</span>
</span><span class="line">    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;#&quot;</span> <span class="na">class=</span><span class="s">&quot;list-group-item active&quot;</span><span class="nt">&gt;</span>
</span><span class="line">        <span class="nt">&lt;h4</span> <span class="na">class=</span><span class="s">&quot;list-group-item-heading&quot;</span><span class="nt">&gt;</span>List group item heading<span class="nt">&lt;/h4&gt;</span>
</span><span class="line">        <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;list-group-item-text&quot;</span><span class="nt">&gt;</span>Donec id elit non mi porta gravida at eget metus.<span class="nt">&lt;/p&gt;</span>
</span><span class="line">    <span class="nt">&lt;/a&gt;</span>
</span><span class="line">    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;#&quot;</span> <span class="na">class=</span><span class="s">&quot;list-group-item&quot;</span><span class="nt">&gt;</span>
</span><span class="line">        <span class="nt">&lt;h4</span> <span class="na">class=</span><span class="s">&quot;list-group-item-heading&quot;</span><span class="nt">&gt;</span>List group item heading<span class="nt">&lt;/h4&gt;</span>
</span><span class="line">        <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;list-group-item-text&quot;</span><span class="nt">&gt;</span>Donec id elit non mi porta gravida at eget metus.<span class="nt">&lt;/p&gt;</span>
</span><span class="line">    <span class="nt">&lt;/a&gt;</span>
</span><span class="line"><span class="nt">&lt;/div&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="typographic-components">Typographic components</h3>

<p>헤딩 <code>font-weight</code>가 가벼워졌으며, <strong>반응형 뷰에서 폰트 사이즈가 변경된다.</strong>
<code>.hero-unit</code>이 <code>.jumbotron</code>으로 바뀌었다.</p>

<h3 id="progress-bars">Progress bars</h3>

<p>구조가 다음과 같으며:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;progress&quot;</span><span class="nt">&gt;</span>
</span><span class="line">    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;progress-bar&quot;</span><span class="nt">&gt;&lt;/div&gt;</span>
</span><span class="line"><span class="nt">&lt;/div&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>.progress-bar-info</code>과 같은 클래스가 <code>.progress-bar</code>에 바로 옆에 오며, 다음과 같이 클래스가 바뀌었다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">BS2</th>
      <th style="text-align: left">BS3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">.bar</td>
      <td style="text-align: left">.progress-bar</td>
    </tr>
    <tr>
      <td style="text-align: left">.progress-info</td>
      <td style="text-align: left">.progress-bar-info</td>
    </tr>
    <tr>
      <td style="text-align: left">.progress-success</td>
      <td style="text-align: left">.progress-bar-success</td>
    </tr>
    <tr>
      <td style="text-align: left">.progress-warning</td>
      <td style="text-align: left">.progress-bar-warning</td>
    </tr>
    <tr>
      <td style="text-align: left">.progress-danger</td>
      <td style="text-align: left">.progress-bar-danger</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="panelsnew">Panels(NEW)</h3>

<p>헤더와 푸터를 가진 박스를 만들 수 있다.</p>

<h4 id="panel-with-heading">Panel with heading</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;panel&quot;</span><span class="nt">&gt;</span>
</span><span class="line">    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;panel-heading&quot;</span><span class="nt">&gt;</span>
</span><span class="line">        <span class="nt">&lt;h3</span> <span class="na">class=</span><span class="s">&quot;panel-title&quot;</span><span class="nt">&gt;</span>Panel title<span class="nt">&lt;/h3&gt;</span>
</span><span class="line">    <span class="nt">&lt;/div&gt;</span>
</span><span class="line">    Panel content
</span><span class="line"><span class="nt">&lt;/div&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="panel-with-footer">Panel with footer</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;panel&quot;</span><span class="nt">&gt;</span>
</span><span class="line">    Panel content
</span><span class="line">    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;panel-footer&quot;</span><span class="nt">&gt;</span>Panel footer<span class="nt">&lt;/div&gt;</span>
</span><span class="line"><span class="nt">&lt;/div&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="contextual-alternatives">Contextual alternatives</h4>

<p>문맥 상태(success, warning, danger, info)를 나타내는 <code>.panel-success</code> 등의 클래스를 사용하여 의미있는 패널을 만들 수 있다.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;panel panel-success&quot;</span><span class="nt">&gt;</span>
</span><span class="line">    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;panel-heading&quot;</span><span class="nt">&gt;</span>
</span><span class="line">        <span class="nt">&lt;h3</span> <span class="na">class=</span><span class="s">&quot;panel-title&quot;</span><span class="nt">&gt;</span>Panel title<span class="nt">&lt;/h3&gt;</span>
</span><span class="line">    <span class="nt">&lt;/div&gt;</span>
</span><span class="line">    Panel content
</span><span class="line"><span class="nt">&lt;/div&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="sources">Sources</h2>

<ul>
  <li><a href="http://blog.getbootstrap.com/">Bootstrap Blog</a></li>
  <li><a href="https://github.com/twbs/bootstrap/pull/6342">List of changes and useful tips</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[존 그루버 마크다운 페이지 번역]]></title>
    <link href="http://nolboo.github.io/blog/2013/09/07/john-gruber-markdown/"/>
    <updated>2013-09-07T15:01:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/09/07/john-gruber-markdown</id>
    <content type="html"><![CDATA[<p>원문 : <a href="http://daringfireball.net/projects/markdown/" title="Permalink to Daring Fireball: Markdown">Daring Fireball: Markdown</a></p>

<p>기존 오피스에서 구글 클라우드로 모든 문서작업을 옮긴 지가 거의 4년 정도 되는 것 같다. 무겁고 복잡하여 느린 오피스에 불만이 많았고, 어디서나 어느 기기에서나 접근할 수 있다는 매력으로 한참을 사용하였지만 클라우드가 가지는 로딩 속도에 대한 불만은 없어지지 않았다.(물론 무거운 오피스에서도 가장 큰 불만이었다. 많이 사용되고 에버노트가 내겐 저장용인 가장 큰 이유이기도 하다.) 그래서 NVAlt나 simplenote와 같은 프로그램을 병행해 사용할 수 밖에 없었고 현재도 가장 애용하는 제품이다. 몇년 전부터 마크다운에 대해 피상적으로 알고 있었으나 본격으로 사용한 것은 약 6,7개월 전부터인데 사용하다보니 미래의 문서 포맷으로는 가장 최적이라고 생각되고, 아직 발전할 여지가 많다고 생각된다. 마크다운에 첫번째 소개로 창시자인 저널리스트(개발자가 아니다 물론 펄 프로그램을 만들어 유포하긴했어도^^)인 존 그루버가 몇년째 자신의 블로그 페이지에서 공개하고 있는 표준문서에 가까운 도큐멘트를 문법(syntax)부분을 중심으로 발췌 번역한다.</p>

<!-- more -->

<h2 id="introduction">Introduction</h2>

<p>마크다운은 웹에서 글을 쓰는 사람들을 위해 텍스트를 HTML로 변환해주는 툴이다. 읽기쉽고 쓰기편한 순수한 텍스트 형식으로 글을 쓰고난 후 XHTML(또는 HTML)로 변환한다.</p>

<p>마크다운 문법의 최우선 목적은 최대한 읽기 편하게 하는 것이다. 이상적인 마크타운 형식 문서는 태그나 형식 명령없이 순수한 텍스트 그대로 출판할 수 있어야 한다. 마크다운 문법은 기존의 여러 text-to-HTML 필터에 영향을 받았지만 그중 텍스트 이메일 형식에서 가장 큰 영감을 받았다.</p>

<p>마크다운은 BSD 오픈 라이언스 기반의 무료 소프트웨어이다.</p>

<h2 id="acknowledgements">Acknowledgements</h2>

<p>이 부분은 실질적인 내용이 없어 건너뛰려고 하였으나 애런 스워츠가 공동 창시자라 불리울 정도로 공헌이 많고(특히 문법부분), HTML 문서를 Markdown으로 변환해주는 <a href="http://www.aaronsw.com/2002/html2text/">html2text</a>를 만들었다는 부분을 명시한다.</p>

<h2 id="markdown-syntax-documentation">Markdown Syntax Documentation</h2>

<h3 id="overview">Overview</h3>

<h4 id="philosophy">Philosophy</h4>

<p>마크다운은 구현 가능한한 읽기 쉽고 쓰기 쉽게 하도록 하였다.</p>

<p>그러나 다른 무엇보다도 가독성을 강조하였다. 마크다운 형식 문서는 태그나 형식 명령으로 마크업되는 것 같이 보이지않고, 일반 텍스트 그대로 출판할 수 있어야 한다. 마크다운 문법은 기존의 여러 텍스트-HTML 필터 - <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a>, <a href="http://www.aaronsw.com/2002/atx/">atx</a>, <a href="http://textism.com/tools/textile/">Textile</a>, <a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>, <a href="http://www.triptico.com/software/grutatxt.html">Gruatext</a>, <a href="http://ettext.taint.org/doc/">EtText</a> - 의 영향을 받았지만 마크타운 문법의 가장 큰 영감의 원천은 순수 텍스트 전자우편이다.</p>

<p>그 결과, 마크다운 문법은 전체적으로 구두점으로 구성되어 있으며, 구두점은 의미하는 것을 고려해서 주의깊게 선택했다. 예로, 단어를 감싸는 별표는 *강조*처럼 보이며, 마크다운 목록은 일반 목록처럼 보인다. 심지어 인용은 이메일에서 사용해오던 텍스트 메시지 인용과 같다.</p>

<h3 id="inline-html">Inline HTML</h3>

<p>마크다운 문법은 하나의 목적을 의도한다: 웹에 <em>글을 쓰기</em> 위한 형식으로 사용한다.</p>

<p>마크타운은 HTML을 대체하는 것이 아니라, 오히려 HTML에 가깝다. 마크타운의 문법은 매우 적고, HTML 태그의 매우 작은 부분에 해당한다. 그 아이디어는 HTML 태그를 쉽게 넣을 수 있는 문법을 만들려는 것이 아니다. 개인적인 의견이지만 HTML은 이미 쉽게 넣을 수 있다. 마크다운의 아이디어는 글을 읽고 쓰고 편집하는 것이 편하게 하는 것이다. HTML은 <em>출판</em> 형식이고, 마크다운은 <em>쓰기</em> 형식이다. 따라서 마크다운의 문법은 단지 순수한 텍스트로 전달할 수 있는 문제만 다룬다.</p>

<p>마크다운 문법에서 다루지 않은 마크업은 그냥 HTML 그 자체를 사용하면 된다. 마크다운 형식에서 HTML 형식으로 전환하기 위해 범위를 지정하는 등의 일을 할 필요가 없습니다. 태그를 그대로 사용하면 된다.</p>

<p>유일한 제한은 블럭 엘리먼트 - 예. <code>&lt;div&gt;</code>, <code>&lt;table&gt;</code>, <code>&lt;pre&gt;</code>, <code>&lt;p&gt;</code> 등 - 는 주변 컨텐츠와 빈줄로 구분하고(한칸씩 띄어주고) 블럭의 시작과 끝 태그는 탭이나 공백으로 들여쓰면 안된다. 마크타운은 HTML 블럭레벨 태그 주위에 (원치않는) <code>&lt;p&gt;</code> 태그를 추가하지 않을 정도로 똑똑하다.</p>

<p>예를들어 마크타운 기사에 HTML 테이블를 추가하기 위해:</p>

<pre><code>&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;Foo&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

This is another regular paragraph.
</code></pre>

<p>블록레벨 태그 안에선 마크다운 형식의 문법이 처리되지 않는 것을 주목한다. 예를들어 HTML 블럭 안에서는 *강조*와 같은 문법을 사용할 수 없다.</p>

<p>스팬레벨(인라인) HTML 태그 - 예: <code>&lt;span&gt;</code>, <code>&lt;cite&gt;</code>, <code>&lt;del&gt;</code> - 은 마크다운 문단, 목록, 헤더 등에서 사용할 수 있다. 원하면 마크타운 형식 대신에 HTML 태그를 사용할 수 있다. 예로. 마크다운 링크나 이미지 문법 대신에 HTML <code>&lt;a&gt;</code>나 <code>&lt;img&gt;</code> 태그를 사용할 수 있다.</p>

<p>블럭레벨 태그와는 달리, 스팬레벨 태그에서는 마크타운 문법을 <em>처리된다</em>.</p>

<h3 id="automatic-escaping-for-special-characters">Automatic Escaping for Special Characters</h3>

<p>HTML에서, 특별 처리해야할 두 개의 문자가 있다: <code>&lt;</code>와 <code>&amp;</code>. 왼쪽 꺽쇠 괄호는 태그를 시작하는 데에 사용하며; ampersand(<code>&amp;</code>)는 HTML 엔티티를 표시할 때 사용한다. 만약 이들을 문자 그대로 사용하려면 이들 항목을 <code>&amp;lt;</code>, <code>&amp;amp;</code>처럼 예외처리를 해 주어야 한다.</p>

<p>특히 <code>&amp;</code>는 웹 상에서 글을 쓸 때 곤란하다. 만약 <code>AT&amp;T</code>를 쓰길 원하면 <code>AT&amp;amp;T</code>로 써야 한다. 심지어 URL 안에서도 <code>&amp;</code>를 예외처리할 필요가 있다. 따라서 다음 링크를 하려면:</p>

<pre><code>http://images.google.com/images?num=30&amp;q=larry+bird
</code></pre>

<p>다음과 같이 인코딩해야 한다:</p>

<pre><code>http://images.google.com/images?num=30&amp;amp;q=larry+bird
</code></pre>

<p>말할 필요도 없이 잊기 쉬운 내용이며, 아마도 이것은 잘 만들어진 웹사이트에서도 가장 흔하게 볼 수 있는 HTML 오류 중 하나일 것이다.</p>

<p>마크다운은 이 문자들을 주의깊게 다루어주어서 자연스럽게 사용할 수 있다. 만약 <code>&amp;</code>를 하나의 HTML 엔티티의 부분으로 <code>&amp;</code>를 사용하면 변경하지 않는다. 그렇지 않을 경우엔 <code>&amp;amp;</code>로 바꾼다.</p>

<p>따라서 기사에 저작권 기호를 포함하고 싶다면, 다음과 같이 쓰면된다:</p>

<pre><code>&amp;copy;
</code></pre>

<p>마크다운은 이것을 바꾸지 않는다. 그러나:</p>

<pre><code>AT&amp;T
</code></pre>

<p>처럼 쓴다면 마크다운은 다음처럼 바꾼다:</p>

<pre><code>AT&amp;amp;T
</code></pre>

<p>비슷하게 마크다운은 인라인 HTML을 지원하기 때문에 HTML 태그의 구분자로서 꺽쇠 괄호를 사용하면 마크다운은 그렇게 다룬다. 그러나 다음처럼 쓰면:</p>

<pre><code>4 &lt; 5
</code></pre>

<p>마크다운은 이것을 다음처럼 바꾼다:</p>

<pre><code>4 &amp;lt; 5
</code></pre>

<p>그러나 마크다운 코드 스팬과 코드 블럭에서 꺽쇠 괄호와 <code>&amp;</code> 기호는 <em>항상</em> 자동적으로 인코드된다. 이것은 마크다운으로 HTML 코드에 대한 글을 쉽게 쓸 수 있게 한다. (반면 HTML 문법에 대한 글을 쓰려고 할 때 HTML만의 형식은 끔찍하다. 모든 <code>&lt;</code>과 <code>&amp;</code>에 대해 예외처리를 해주어야 한다.)</p>

<hr />

<h2 id="block-elements">BLOCK ELEMENTS</h2>

<h3 id="paragraphs-and-line-breaks">PARAGRAPHS AND LINE BREAKS</h3>

<p>문단은 하나 또는 그 이상의 연이은 줄이며, 하나 이상의 빈줄로 분리한다. (빈줄은 빈줄 - 공백이나 탭을 제외한 아무것도 포함하지 않은 것으로 생각한다 - 처럼 보이는 줄이다.) 일반 문단은 공백이나 탭으로 들여쓰지 말아야 한다.</p>

<p>“하나 이상의 연이은 텍스트 줄”이라는 규칙이 함축하는 것은 마크다운이 “강제 줄바꿈” 문단을 지원하는 것이다. 이것이 상당히 다른 부분이다. 대부분의 다른 text-to-HTML 변환 포맷터들이(무버블 타입의 줄바꿈 변환 옵션 포함하여) 하나의 문단 안에서 줄바꿈 문자는 모두 <code>&lt;br /&gt;</code> 태그로 변환한다.</p>

<p>마크다운을 사용해서 <code>&lt;br /&gt;</code>를 삽입하려면 줄 마지막에 둘 이상의 공백을 두고 엔터를 입력하면 된다.</p>

<p>그렇다, <br /> 태그를 만들기 위해 좀 수고가 들지만, “모든 줄바꿈은 하나의 <br />이다”라는 지나치게 단순한 규칙은 마크다운에서 동작하지 않는다. 마크다운의 전자메일 형식의 인용과 다중 패러그래프 목록은 강제로 줄바꿈할 때 가장 잘 - 보기에도 낫게 - 동작한다.</p>

<h3 id="headers">HEADERS</h3>

<p>마크다운은 두 가지 형식의 제목을 지원한다, <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a>와 <a href="http://www.aaronsw.com/2002/atx/">atx</a>.</p>

<p>Setext 형식의 헤더는 등호(큰 제목)와 빼기(작은 제목) 기호를 “밑줄”로 사용한다. 예를들어:</p>

<pre><code>This is an H1
=============

This is an H2
-------------
</code></pre>

<p>밑줄 =, - 의 수는 여러 개이면 된다.</p>

<p>Atx 형식의 헤더는 줄 시작에서 1-6개의 해시 문자를 사용한다. 헤더의 수는 제목의 크기에 따른다. 예를 들어:</p>

<pre><code># This is an H1

## This is an H2

###### This is an H6
</code></pre>

<p>옵션으로, atx 헤더를 닫을 수 있다. 이건 순전히 장식용이다 — 이렇게 하는 것이 더 나아 보인다면 이걸 사용할 수 있다. 닫는 해시는 시작 해시의 수와 같을 필요는 없다. (시작 해시의 수가 제목의 크기를 결정한다.):</p>

<pre><code># This is an H1 #

## This is an H2 ##

### This is an H3 ######
</code></pre>

<h3 id="blockquote">BlockQuote</h3>

<p>마크다운은 이메일 형식의 <code>&gt;</code> 문자를 블럭인용에 사용한다. 만약 이메일의 인용 규칙에 익숙하다면 마크다운에서 블럭인용을 만드는 법을 알고 있는 것이다. 텍스트를 강제 줄바꿈하고 각 줄 앞에 <code>&gt;</code>를 넣으면 가장 잘 보인다.</p>

<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&gt; 
&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&gt; id sem consectetuer libero luctus adipiscing. 
</code></pre>

<p>마크다운은 강제로 줄바꿈 된 첫줄의 앞에 <code>&gt;</code>만 두어도 인용하는 것이 가능하다.</p>

<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.  

&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.  
</code></pre>

<p>추가적으로 <code>&gt;</code>를 덧붙임으로서 인용 안의 인용(nest)을 할 수 있다:</p>

<pre><code>&gt; This is the first level of quoting.  
&gt;  
&gt; &gt; This is nested blockquote.  
&gt;  
&gt; Back to the first level.  
</code></pre>

<p>인용은 제목, 목록, 코드블럭과 같은 다른 마크다운 요소를 포함할 수 있다.</p>

<pre><code>&gt; ## This is a header.  
&gt;   
&gt; 1.   This is the first list item.  
&gt; 2.   This is the second list item.  
&gt;   
&gt; Here's some example code:  
&gt;   
&gt;     return shell_exec("echo $input | $markdown_script");  
</code></pre>

<p>제대로 된 문서 편집기는 이메일 형식의 인용을 쉽게할 수 있는 방법을 제공한다. 예를들어 BBEdit는 블럭을 지정하고 텍스트 메뉴에서 인용 레벨을 선택할 수 있다.</p>

<h3 id="lists">LISTS</h3>

<p>마크다운은 순서있는(번호), 순서없는(글머리 기호) 목록을 지원한다.</p>

<p>순서없는 목록은 항목 표시로 별표, 더하기, 빼기를 - 교환가능하게 - 사용한다.</p>

<pre><code>*   Red
*   Green
*   Blue
</code></pre>

<p>은 다음과 같다:</p>

<pre><code>+   Red
+   Green
+   Blue
</code></pre>

<p>과</p>

<pre><code>-   Red
-   Green
-   Blue
</code></pre>

<p>순서있는 목록은 숫자와 점을 사용한다:</p>

<pre><code>1.  Bird
2.  McHale
3.  Parish
</code></pre>

<p>목록에 사용되는 실제 숫자는 마크다운이 처리하는 HTML 출력에 아무런 영향도 주지 않는다는 것은 알아두는 것이 중요하다. 위의 목록을 마크다운이 처리하면, HTML은 다음과 같게 된다.:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;ol&gt;</span>
</span><span class="line"><span class="nt">&lt;li&gt;</span>Bird<span class="nt">&lt;/li&gt;</span>
</span><span class="line"><span class="nt">&lt;li&gt;</span>McHale<span class="nt">&lt;/li&gt;</span>
</span><span class="line"><span class="nt">&lt;li&gt;</span>Parish<span class="nt">&lt;/li&gt;</span>
</span><span class="line"><span class="nt">&lt;/ol&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>만약 위의 예 대신에:</p>

<pre><code>1.  Bird
1.  McHale
1.  Parish
</code></pre>

<p>또는 심지어:</p>

<pre><code>3. Bird
1. McHale
8. Parish
</code></pre>

<p>도 정확히 같은 HTML을 만든다. 중요한 것은, 원한다면, 순서있는 마크다운 목록에서 소스의 숫자와 출판될 HTML의 숫자가 동일하도록 숫자를 맞출 수 있다. 그러나 마음대로 해도 된다.</p>

<p>그러나, 목록번호를 맘대로 매겨도 아직 숫자 1로 시작된다. 미래 어느 시점에 마크다운은 임의의 숫자로 시작하는 순서있는 목록을 지원할 것이다.(역자: 언제?)</p>

<p>항목 표시는 일반적으로 왼쪽 마진에서 시작하지만 최대 세개의 공백으로 들여쓸 수 있다. 목록 표시는 하나 이상의 공백이나 탭이 뒤따라야 한다.</p>

<p>또 목록을 보기 좋게 하기 위해 들여쓰기와 줄바꾸기를 사용할 수 있다.</p>

<pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.  
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,  
    viverra nec, fringilla in, laoreet vitae, risus.  
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.  
    Suspendisse id sem consectetuer libero luctus adipiscing.  
</code></pre>

<p>그러나 다음과 같이 써도 된다:</p>

<pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.  
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,  
viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.  
Suspendisse id sem consectetuer libero luctus adipiscing.  
</code></pre>

<p>목록 항목을 빈줄로 분리하면 마크다운은 HTML 출력에서 <code>&lt;p&gt;</code> 태그로 이 항목을 감싼다. 예를 들면:</p>

<pre><code>*   Bird
*   Magic
</code></pre>

<p>은 다음처럼 변환된다:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;ul&gt;</span>
</span><span class="line"><span class="nt">&lt;li&gt;</span>Bird<span class="nt">&lt;/li&gt;</span>
</span><span class="line"><span class="nt">&lt;li&gt;</span>Magic<span class="nt">&lt;/li&gt;</span>
</span><span class="line"><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>그러나, 다음은:</p>

<pre><code>*   Bird

*   Magic
</code></pre>

<p>이렇게 변환된다:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;ul&gt;</span>
</span><span class="line"><span class="nt">&lt;li&gt;&lt;p&gt;</span>Bird<span class="nt">&lt;/p&gt;&lt;/li&gt;</span>
</span><span class="line"><span class="nt">&lt;li&gt;&lt;p&gt;</span>Magic<span class="nt">&lt;/p&gt;&lt;/li&gt;</span>
</span><span class="line"><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>목록 항목은 여러 문단으로 이루어질 수 있다. 목록 항목에서 이어지는 문단은 적어도 4개 이상의 공백이나 하나 이상의 탭으로 들여써야 한다.</p>

<pre><code>1.  This is a list item with two paragraphs. Lorem ipsum dolor  
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit  
    mi posuere lectus.  

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet  
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum  
    sit amet velit.  

2.  Suspendisse id sem consectetuer libero luctus adipiscing.  
</code></pre>

<p>이어지는 각 줄을 들여쓰는 것이 보기에 좋다. 그러나 다음과 같이 느긋하게 사용힐 수 있다:</p>

<pre><code>*   This is a list item with two paragraphs.  

    This is the second paragraph in the list item. You're  
only required to indent the first line. Lorem ipsum dolor  
sit amet, consectetuer adipiscing elit.

*   Another item in the same list.  
</code></pre>

<p>목록 항목 안에서 블록 인용하려면 <code>&gt;</code> 구분 문자로 들여쓰게 하면 된다.</p>

<pre><code>*   A list item with a blockquote:  

    &gt; This is a blockquote
    &gt; inside a list item.
</code></pre>

<p>목록 항목 안에서 코드 블럭을 넣으려면 두 번의 들여쓰기가 - 8개의 공백 또는 두번의 탭이 필요하다:</p>

<pre><code>*   A list item with a code block:  

        &lt;code goes here&gt;
</code></pre>

<p>다음과 같이 씀으로서 우연히 순차목록을 만들 가능성을 없애는 것도 가능하다.</p>

<pre><code>1986. What a great season.
</code></pre>

<p>다시 말하자면 줄 시작 부분의 <em>숫자-마침표-공백</em>. 이것을 피하기 위해 마침표를 <code>\</code>로 예외처리할 수 있다.</p>

<pre><code>1986\. What a great season.
</code></pre>

<h3 id="code-blocks">CODE BLOCKS</h3>

<p>프로그래밍이나 마크업 소스코드를 표시하기 위해 형식화된 코드 블럭을 사용할 수 있다. 일반 문단과는 달리 코드블럭의 줄은 문자 그대로 해석된다. 마크다운은 <code>&lt;pre&gt;</code>와 <code>&lt;code&gt;</code> 두 개의 태그로 코드블럭을 감싼다.</p>

<p>마크타운에서 코드 블럭을 만들기 위해 간단히 블럭의 모든 줄을 적어도 4개 이상의 공백이나 하나의 탭으로 들여쓰면 된다. 예를 들면, 다음 입력은:</p>

<pre><code>This is a normal paragraph:

    This is a code block.
</code></pre>

<p>마크다운은 다음처럼 바꾼다:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;p&gt;</span>This is a normal paragraph:<span class="nt">&lt;/p&gt;</span>
</span><span class="line">
</span><span class="line"><span class="nt">&lt;pre&gt;&lt;code&gt;</span>This is a code block.
</span><span class="line"><span class="nt">&lt;/code&gt;&lt;/pre&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>4개의 공백 또는 하나의 탭으로 된 한 단계의 들여쓰기는 코드 블럭 각 줄로부터 제거된다. 예를 들면, 다음은:</p>

<pre><code>Here is an example of AppleScript:

    tell application "Foo"
        beep
    end tell
</code></pre>

<p>은 다음처럼 바뀐다:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;p&gt;</span>Here is an example of AppleScript:<span class="nt">&lt;/p&gt;</span>
</span><span class="line">
</span><span class="line"><span class="nt">&lt;pre&gt;&lt;code&gt;</span>tell application &quot;Foo&quot;
</span><span class="line">    beep
</span><span class="line">end tell
</span><span class="line"><span class="nt">&lt;/code&gt;&lt;/pre&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>코드 블럭은 들여쓰여지지 않은 행을 만날 때(또는 글의 끝)까지 계속된다.</p>

<p>코드블럭에서, 앰퍼센트(<code>&amp;</code>)와 왼쪽, 오른쪽 꺽쇠 괄호는 자동적으로 HTML 에티티로 변환된다. 그 결과, 마크다운에서 HTML 소스코드를 아주 쉽게 삽입 - 복사하고 들여쓰기 - 할 수 있다. 마크다운은 <code>&amp;</code>와 꺽쇠 괄호를 인코딩하는 것도 잘 처리한다. 예를 들면, 다음은:</p>

<pre><code>&lt;div class="footer"&gt;
    &amp;copy; 2004 Foo Corporation
&lt;/div&gt;
</code></pre>

<p>다음과 같이 바뀐다:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;pre&gt;&lt;code&gt;</span><span class="ni">&amp;lt;</span>div class=&quot;footer&quot;<span class="ni">&amp;gt;</span>
</span><span class="line">    <span class="ni">&amp;amp;</span>copy; 2004 Foo Corporation
</span><span class="line"><span class="ni">&amp;lt;</span>/div<span class="ni">&amp;gt;</span>
</span><span class="line"><span class="nt">&lt;/code&gt;&lt;/pre&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>일반 마크다운 문법은 코드블럭에서는 처리되지 않는다. 예로, 별표는 코드블럭 안에서 그대로 별표로 표시된다. 이것은 마크다운 자체의 문법을 설명할 때도 쉽게 사용할 수 있다는 것을 말한다.</p>

<h3 id="horizontal-rules">HORIZONTAL RULES</h3>

<p>수평선 세개 이상의 빼기, 별표, 밑줄로 수평선(<code>&lt;hr /&gt;</code>)을 만들 수 있다. 만약 원하는 경우 빼기나 별표 중간에 공백을 넣을 수도 있다. 아래의 줄은 모두 수평선을 만든다:</p>

<pre><code>* * *

***

*****

- - -

---------------------------------------
</code></pre>

<hr />

<h2 id="span-elements">SPAN ELEMENTS</h2>

<h3 id="links">LINKS</h3>

<p>마크다운은 두가지 형식의 링크를 지원한다: <em>인라인</em>과 <em>참조</em></p>

<p>두 형식 모두,에서 링크 문자열은 [대괄호]로 구분한다.</p>

<p>인라인 링크를 만들기 위해 링크 문자열을 대괄호로 닫고 이어서 둥근괄호 쌍을 사용한다. 둥근괄호 안에 링크 URL과 링크에 대한 설명을 추가할 수 있다. 예를 들면, 다음은:</p>

<pre><code>This is [an example](http://example.com/ "Title") inline link.

[This link](http://example.net/) has no title attribute.
</code></pre>

<p>다음처럼 바뀐다:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;p&gt;</span>This is <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://example.com/&quot;</span> <span class="na">title=</span><span class="s">&quot;Title&quot;</span><span class="nt">&gt;</span>
</span><span class="line">an example<span class="nt">&lt;/a&gt;</span> inline link.<span class="nt">&lt;/p&gt;</span>
</span><span class="line">
</span><span class="line"><span class="nt">&lt;p&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://example.net/&quot;</span><span class="nt">&gt;</span>This link<span class="nt">&lt;/a&gt;</span> has no
</span><span class="line">title attribute.<span class="nt">&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>만약 같은 서버의 로컬 리소스를 참조하려면 상대 경로를 사용한다:</p>

<pre><code>See my [About](/about/) page for details.
</code></pre>

<p>참조 형식의 링크는 두 번째에도 대괄호를 사용하며, 그 안에 링크와 대응하는 레이블을 넣는다.:</p>

<pre><code>This is [an example][id] reference-style link.
</code></pre>

<p>옵션으로 대괄호를 공백으로 분리할 수도 있다:</p>

<pre><code>This is [an example] [id] reference-style link.
</code></pre>

<p>그리고 문서 아무 곳에서나 다음과 같은 방법으로 링크를 참조할 수 있다:</p>

<pre><code>[id]: http://example.com/  "Optional Title Here"
</code></pre>

<p>이것은:</p>

<ul>
  <li>대괄호에는 링크 ID를 포함해야 한다(옵션으로 왼쪽 마진에서 최대 세개의 공백으로 들여쓸 수 있다);</li>
  <li>콜론이 이어 지며;</li>
  <li>하나 이상의 공백(또는 탭)이 뒤따른다;</li>
  <li>링크에 대한 URL이 뒤따른다;</li>
  <li>옵션으로 링크에 대한 제목 속성이 뒤따를 수 있으며, 작은 따옴표나 큰 따옴표로 인용하거나 괄호로 감싸야 한다.</li>
</ul>

<p>다음 세개의 링크는 모두 같다:</p>

<pre><code>[foo]: http://example.com/  "Optional Title Here"
[foo]: http://example.com/  'Optional Title Here'
[foo]: http://example.com/  (Optional Title Here)
</code></pre>

<p><em>주의</em>: 링크 타이틀 구분에 작은 따옴표를 사용할 수 없는 버그가 Markdown.pl 1.0.1에 있다.</p>

<p>옵션으로 링크 URL은 꺽쇠 괄호로 감쌀 수 있다:</p>

<pre><code>[id]: &lt;http://example.com/&gt;  "Optional Title Here"
</code></pre>

<p>또 제목 속성을 다음 행에 두고 공백이나 탭으로 들여쓸 수 있다. 긴 URL은 이렇게 하는 것이 보기에 더 좋다:</p>

<pre><code>[id]: http://example.com/longish/path/to/resource/here
    "Optional Title Here"
</code></pre>

<p>링크 정의는 마크다운 처리 과정 중 링크를 만드는데 사용되며 HTML 출력에선 제거된다.</p>

<p>링크 정의 이름은 문자, 숫자, 공백, 구두점으로 구성된다 - 그러나 대소문자는 가리지 <em>않는다</em>. 예를 들어 다음 두 개 링크는 같다:</p>

<pre><code>[link text][a]
[link text][A]
</code></pre>

<p><em>함축적 링크 이름</em>을 사용하면 링크 이름을 생략할 수 있다. 이 경우 링크의 제목 그 자체가 이름으로 사용된다. 그냥 빈 대괄호를 사용하면 된다. - 예: google.com 사이트를 링크하는 “Google” 라는 단어를 링크하기 위해 간단히 다음처럼 사용할 수 있다:</p>

<pre><code>[Google][] 
</code></pre>

<p>그리고 다음처럼 링크를 정의한다:</p>

<pre><code>[Google]: http://google.com/
</code></pre>

<p>링크 이름에 공백을 포함할 수 있기 때문에 링크 제목으로 여러 단어를 사용해도 잘 동작한다:</p>

<pre><code>Visit [Daring Fireball][] for more information.
</code></pre>

<p>그리고 다음처럼 링크를 정의한다:</p>

<pre><code>[Daring Fireball]: http://daringfireball.net/
</code></pre>

<p>링크 정의는 마크다운 문서 어디에든 둘 수 있다. 나는 링크가 사용된 문단 바로 아래에 두는 경향이 있다. 그러나 원한다면 주석처럼 문서 끝에 모두 넣어도 된다.</p>

<p>이것은 실제 동작하는 참조 링크의 예이다:</p>

<pre><code>I get 10 times more traffic from [Google] [1] than from
[Yahoo] [2] or [MSN] [3].

  [1]: http://google.com/        "Google"
  [2]: http://search.yahoo.com/  "Yahoo Search"
  [3]: http://search.msn.com/    "MSN Search"
</code></pre>

<p>함축적 이름을 사용한다면 다음처럼 쓸 수 있다:</p>

<pre><code>I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

  [google]: http://google.com/        "Google"
  [yahoo]:  http://search.yahoo.com/  "Yahoo Search"
  [msn]:    http://search.msn.com/    "MSN Search"
</code></pre>

<p>위의 예는 모두 다음과 같은 HTML 출력을 만든다:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;p&gt;</span>I get 10 times more traffic from <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://google.com/&quot;</span>
</span><span class="line"><span class="na">title=</span><span class="s">&quot;Google&quot;</span><span class="nt">&gt;</span>Google<span class="nt">&lt;/a&gt;</span> than from
</span><span class="line"><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://search.yahoo.com/&quot;</span> <span class="na">title=</span><span class="s">&quot;Yahoo Search&quot;</span><span class="nt">&gt;</span>Yahoo<span class="nt">&lt;/a&gt;</span>
</span><span class="line">or <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://search.msn.com/&quot;</span> <span class="na">title=</span><span class="s">&quot;MSN Search&quot;</span><span class="nt">&gt;</span>MSN<span class="nt">&lt;/a&gt;</span>.<span class="nt">&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>비교를 위해 다음과 같이 마크다운의 인라인 링크 형식을 사용해서 쓴 같은 문장이 있다:</p>

<pre><code>I get 10 times more traffic from [Google](http://google.com/ "Google")
than from [Yahoo](http://search.yahoo.com/ "Yahoo Search") or
[MSN](http://search.msn.com/ "MSN Search").
</code></pre>

<p>참조 형식의 링크가 더 쉬운 것은 아니다. 중요한 것은 참조 형식의 링크로 소스 문서의 가독성이 엄청나게 올라간다는 것이다. 위의 예를 비교해 보면: 참조 링크를 사용하면 문단은 81자 길이다; 인라인 링크 형식으로는 176자이고, HTML 만으론 234자이다. HTML 만으로는 텍스트보다 마크업이 더 많다.</p>

<p>마크다운의 참조 형식 링크의 소스문서는 가독성이 올라가며, 브라우저로 랜더링한 최종 출력과 훨씬 더 비슷하게 된다. 문단의 마크업에 관련된 메타데이타를 이동할 수 있도록 함으로서 글을 쓰는 자연스런 흐름을 방해받지 않고 링크를 추가할 수 있다.</p>

<h3 id="emphasis">EMPHASIS</h3>

<p>마크다운은 별표(*)와 밑줄(_)을 강조 문자로 다룬다. 하나의 *나 _로 감싼 문자열은 HTML <code>&lt;em&gt;</code> 태그로 감싸게 된다. 두개의 <code>*</code>나 <code>_</code>로 감싸면 HTML <code>&lt;strong&gt;</code> 태그로 감싸게 된다. 예로, 다음은:</p>

<pre><code>*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
</code></pre>

<p>다음과 같이 출력된다:</p>

<pre><code>&lt;em&gt;single asterisks&lt;/em&gt;

&lt;em&gt;single underscores&lt;/em&gt;

&lt;strong&gt;double asterisks&lt;/strong&gt;

&lt;strong&gt;double underscores&lt;/strong&gt;
</code></pre>

<p>좋아하는 형식을 사용할 수 있다; 유일한 제한은 열고 닫을 때 같은 문자를 사용해야 한다는 것이다.</p>

<p>강조는 단어 중간에도 사용할 수 있다:</p>

<pre><code>un*frigging*believable
</code></pre>

<p>그러나, 만약 *나 _를 공백으로 감싸면 별표와 밑줄 문자 그대로 처리된다.</p>

<p>강조 구분자로 사용하지 않으려면 사용된 위치에서 별표와 밑줄을 표시하기 위해 역슬래시로 예외 처리하면 된다:</p>

<pre><code>\*this text is surrounded by literal asterisks\*
</code></pre>

<h3 id="code">CODE</h3>

<p>문자 코드를 삽입하기 위해서는 역따옴표(<code>`</code>)로 감싼다. 정형화된 코드블럭과는 달리 문자 코드는 일반 문단에 삽입되는 코드를 의미한다. 예를 들면:</p>

<pre><code>Use the `printf()` function.
</code></pre>

<p>는 다음처럼 출력된다:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;p&gt;</span>Use the <span class="nt">&lt;code&gt;</span>printf()<span class="nt">&lt;/code&gt;</span> function.<span class="nt">&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>문자 코드에 역따옴표를 포함하기 위해 여러 개의 역 따옴표를 사용할 수 있다:</p>

<pre><code>``There is a literal backtick (`) here.``
</code></pre>

<p>이렇게 출력된다:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;p&gt;&lt;code&gt;</span>There is a literal backtick (`) here.<span class="nt">&lt;/code&gt;&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>문자 코드를 감싼 역따옴표 구분자는 공백을 포함할 수 있다 - 열기 전 한개, 닫기 전 한개. 이렇게 함으로서 문자 코드의 시작 또는 끝에 역따옴표를 글자 그대로 표시할 수 있다:</p>

<pre><code>A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
</code></pre>

<p>다음과 같이 출력된다:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;p&gt;</span>A single backtick in a code span: <span class="nt">&lt;code&gt;</span>`<span class="nt">&lt;/code&gt;&lt;/p&gt;</span>
</span><span class="line">
</span><span class="line"><span class="nt">&lt;p&gt;</span>A backtick-delimited string in a code span: <span class="nt">&lt;code&gt;</span>`foo`<span class="nt">&lt;/code&gt;&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>문자 코드에서 <code>&amp;</code>와 꺽쇠 괄호는 엔티티로 자동 인코드된다. 이것으로 HTML 코드를 포함하기 쉽다. 마크다운은 다음을:</p>

<pre><code>Please don't use any `&lt;blink&gt;` tags.
</code></pre>

<p>다음과 같이 변환한다:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;p&gt;</span>Please don&#39;t use any <span class="nt">&lt;code&gt;</span><span class="ni">&amp;lt;</span>blink<span class="ni">&amp;gt;</span><span class="nt">&lt;/code&gt;</span> tags.<span class="nt">&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>다음과 같이 쓸 수도 있다:</p>

<pre><code>`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.
</code></pre>

<p>다음과 같이 출력된다:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;p&gt;&lt;code&gt;</span><span class="ni">&amp;amp;</span>#8212;<span class="nt">&lt;/code&gt;</span> is the decimal-encoded equivalent of <span class="nt">&lt;code&gt;</span><span class="ni">&amp;amp;</span>mdash;<span class="nt">&lt;/code&gt;</span>.<span class="nt">&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="images">IMAGES</h3>

<p>인정하건대, 순수 텍스트 문서에 이미지를 배치할 수 있는 “자연스런” 문법을 만드는 것은 상당히 어렵다.</p>

<p>마크다운은 링크 문법과 유사하도록 의도된 이미지 문법을 사용한다: <em>인라인</em>과 <em>참조</em></p>

<p>인라인 이미지 문법은 다음과 같다:</p>

<pre><code>![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg "Optional title")
</code></pre>

<p>말하자면:</p>

<ul>
  <li>하나의 감탄사 부호: !;</li>
  <li>이미지 alt 속성 텍스트을 포함하는, 대괄호가 뒤따른다;</li>
  <li>이미지의 URL이나 경로를 포함하는, 괄호가 뒤따른다. 옵션으로 작은 따옴표나 큰 따옴표로 에워싼 타이틀 속성을 줄 수도 있다.</li>
</ul>

<p>참조 형식의 이미지 문법은 다음과 같다:</p>

<pre><code>![Alt text][id]
</code></pre>

<p>여기서 “id”는 정의된 이미지 참조의 이름이다. 이미지 참조는 링크 참조와 동일한 문법으로 정의된다:</p>

<pre><code>[id]: url/to/image  "Optional title attribute"
</code></pre>

<p>이 글에선 마크다운은 이미지 크기를 지정하는 문법이 없다. 이미지의 크기가 중요하다면 그냥 일반적인 HTML <code>&lt;img&gt;</code>` 태그를 사용할 수 있다.</p>

<hr />

<h2 id="miscellaneous">MISCELLANEOUS</h2>

<h3 id="automatic-links">AUTOMATIC LINKS</h3>

<p>마크다운은 URL과 이메일 주소를 위한 “자동” 링크를 만드는 간단한 형식을 지원한다: 간단히 URL과 이메일 주소를 꺽쇠 괄호로 감싼다. URL과 이메일 주소의 실제 텍스트를 표시하면서 클릭 가능한 링크로 만들고 싶다면, 다음과 같이 하면 된다:</p>

<pre><code>&lt;http://example.com/&gt;
</code></pre>

<p>마크다운은 이것을 다음처럼 바꾼다:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://example.com/&quot;</span><span class="nt">&gt;</span>http://example.com/<span class="nt">&lt;/a&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>전자우편 주소에 대한 자동 링크도 비슷하지만 전자우편 주소는 스팸 봇의 접근을 막기위해 랜덤의 10진, 16진 인코딩을 한다는 점이 차이가 있다. 예를 들어 마크다운은 다음을:</p>

<pre><code>&lt;address@example.com&gt;
</code></pre>

<p>이렇게 바꾼다:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;</span>
</span><span class="line"><span class="s">&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;</span>
</span><span class="line"><span class="s">&amp;#109;&quot;</span><span class="nt">&gt;</span><span class="ni">&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;</span>
</span><span class="line"><span class="ni">&amp;#109;&amp;#x70;&amp;#x6C;</span>e<span class="ni">&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;</span><span class="nt">&lt;/a&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>브라우저에선 “address@example.com”로 클릭가능한 링크로 렌더링된다.</p>

<p>(이런 종류의 항목 인코딩 기법은 사실 많은 이메일-수집 봇을 실제 바보로 만드나, 모든 봇을 확실하게 바보로 만들 수는 없을 것이다. 하지않는 것 보단 낫다, 그러나 이렇게 공개된 이메일 주소는 결국 스팸을 받기 시작할 것이다.)</p>

<h3 id="backslash-escapes">BACKSLASH ESCAPES</h3>

<p>마크다운 문법에서 특별한 의미를 갖는 문자를 글자 그대로 사용하려면, 역 슬래시(<code>\</code>) 예외처리(escape)를 사용할 수 있다. 예를들어 HTML의 <code>&lt;em&gt;</code> 태그 대신에 별표 문자로 하나의 단어를 감싸려면 별표 앞에 역 슬래시를 두면 된다.</p>

<pre><code>\*별표 문자\*
</code></pre>

<p>마크다운은 다음과 같은 문자에 대해 이스케이프를 지원한다:</p>

<pre><code>\   backslash
`   backtick
*   asterisk
_   underscore
{}  curly braces
[]  square brackets
()  parentheses
#   hash mark
+   plus sign
-   minus sign (hyphen)
.   dot
!   exclamation mark
</code></pre>

<hr />

<p>막상 번역하고 보니 쉬운 내용을 약간 어렵고 지루하게 표시한 결과가 아닌가 생각되지만 실제 마크다운을 사용할 때는 위의 내용을 다 알아야 하는 것이 아니다. <code>#</code>과 <code>*</code>, 들여쓰기 이 세가지만 알아도 블로깅하거나 문서를 작성하는 데 거의 불편함이 없다.</p>

<p>그러나, 마땅히 표준 문서에 가까운 글이 몇년 간 제대로 번역되지 않는(?) 것이 안타까워 번역해보았다.(거의 노가다:;)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[깃허브로 협업하는 법]]></title>
    <link href="http://nolboo.github.io/blog/2013/08/29/how-to-collaborate-on-github/"/>
    <updated>2013-08-29T18:35:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/08/29/how-to-collaborate-on-github</id>
    <content type="html"><![CDATA[<p>원문 : <a href="http://net.tutsplus.com/tutorials/tools-and-tips/how-to-collaborate-on-github/">How to Collaborate On GitHub</a></p>

<p>필요한 부분만 완전 요약하여 번역하였으니 원문을 반드시 참조하세요!</p>

<h2 id="learn-the-ecosystem-of-the-project">Learn the Ecosystem of the Project</h2>

<p>공헌하기 위해서는 프로젝트와 관련된 모든 문서를 읽어라. 예를 들면, 깃허브는 표준화된 <code>CONTRIBUTING.md</code>를 가지고 있다. <a href="https://github.com/jquery/jquery/blob/master/CONTRIBUTING.md">jQuery 공헌 가이드</a>는 완벽한 예제이다. 프로젝트 생태계를 이해하는 또 다른 방법은 기존 코드베이스와 <code>git log</code>를 살펴보는 것이다. 프로젝트의 문서를 전부 읽고 어휘를 습득하라.</p>

<h2 id="the-pull-request-workflow-for-code-contribution">The Pull-Request Workflow for Code Contribution</h2>

<p>깃허브의 일반적인 워크플로우는 꽤 단순하다.
<!-- more -->
1. 자신의 계정으로 target 저장소를 fork한다.
2. 로컬 컴퓨터에 저장소를 clone한다.
3. “topic 브랜치”로 check out하고 소스를 변경한다.
4. 자신의 fork에 topic 브랜치를 push한다.
5. 토론을 통해 pull request를 만들기위해 깃허브의 diff 뷰어를 사용한다.
6. 요청된 변경을 만든다.
7. pull 요청이 (보통 master 브랜치 안으로) merge되고 topic 브랜치는 upstream(target) 저장소에서 지워진다.</p>

<p>워크플로우에서 각 프로젝트마다 많은 차이가 있다. 예로, topic 브랜치의 이름 규약은 서로 다르다. 어떤 프로젝트는 깃허브 이슈의 ID #가 345일 때 <code>bug_345</code>와 같은 규약을 사용한다. 어떤 프로젝트에선 더 짧은 커밋 메시지를 선호한다.</p>

<h3 id="step-1-forking">Step 1: Forking</h3>

<p>깃허브에서 저장소를 fork한다.</p>

<p><img src="http://cdn.tutsplus.com/net.tutsplus.com/uploads/2013/08/github_header.png" alt="" /></p>

<p><img src="http://cdn.tutsplus.com/net.tutsplus.com/uploads/2013/08/forking.png" alt="" /></p>

<h3 id="step-2-cloning">Step 2: Cloning</h3>

<p>우측 사이드바의 URL을 사용하여 저장소를 clone한다.</p>

<pre><code>git clone git@github.com:jcutrell/jquery.git
</code></pre>

<p><img src="http://cdn.tutsplus.com/net.tutsplus.com/uploads/2013/08/clone_url.png" alt="" /></p>

<h3 id="step-3-adding-the-upstream-remote">Step 3: Adding the Upstream Remote</h3>

<p>클론한 디렉토리로 변경하고, 이 지점에서 upstream remote를 추가한다.</p>

<pre><code>cd jquery
git remote add upstream git@github.com:jquery/jquery.git
</code></pre>

<p>이렇게 하면 로컬에서 소스 변경을 Pull하고 merge할 수 있다. 이렇게:</p>

<pre><code>git fetch upstream
git merge upstream/master
</code></pre>

<h3 id="step-4-checking-out-a-topic-branch">Step 4: Checking Out a Topic Branch</h3>

<p>자신의 변경사항을 만들기 전에, topic 브랜치로 checkout한다.</p>

<pre><code>git checkout -b enhancement_345
</code></pre>

<h3 id="step-5-committing">Step 5: Committing</h3>

<p>이제 소스를 변경하고 변경에 대한 추적하는 커밋을 만든다.</p>

<pre><code>git commit -am "adding a smileyface to the documentation."
</code></pre>

<h3 id="step-6-pushing">Step 6: Pushing</h3>

<p>자신의 fork에 topic 브랜치를 push한다.</p>

<pre><code>git push origin enhancment_345
</code></pre>

<h3 id="step-7-creating-a-pull-request">Step 7: Creating a Pull Request</h3>

<p>최종적으로 pull 요청을 만들 것이다. 먼저 자신의 fork로 간다. “your recently pushed branches”에서 “Compare and Pull Request”를 선택한다. 그렇지 않으면 뜨랍다운에서 브랜치를 선택하고, 저장소 섹션의 우상에 있는 “Pull Request” 나 “Compare”를 클릭한다.</p>

<p><img src="http://cdn.tutsplus.com/net.tutsplus.com/uploads/2013/08/compare_pull_request.png" alt="" /></p>

<p><img src="http://cdn.tutsplus.com/net.tutsplus.com/uploads/2013/08/switch_branches.png" alt="" /></p>

<p><a href="http://zachholman.com/talk/how-github-uses-github-to-build-github/">“How GitHub Uses GitHub to Build GitHub”</a>에 따르면 pull 요청은 대화이다.</p>

<h2 id="github-issues--pull-requests--project-management-zen">GitHub Issues + Pull Requests = Project Management Zen</h2>

<p>이슈의 가장 놀라운 특징은 pull 요청과의 통합이다. 사용자는 키밋 메시지에 이슈 숫자 IO를 포함하여 커밋 메시지에서 이슈를 참조할 수 있다. 예를 들면:</p>

<pre><code>git commit -am "Adding a header; fixes #3"
</code></pre>

<p>위의 커밋 메시지는 pull 요청이 받아들여지면 이슈 #3를 자동으로 닫는다.</p>

<h2 id="seek-out-secondary-channels-of-collaboration">Seek Out Secondary Channels of Collaboration</h2>

<p>pull 요청만이 공헌할 수 있는 유일한 방법이라고 생각하지 마라. 포럼이나 IRC 대화에서도 가능하다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[아주 유용한 jQuery 라이브러리들 - 코드스쿨 추천]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/31/cs-useful-jquery-libraries/"/>
    <updated>2013-07-31T18:44:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/31/cs-useful-jquery-libraries</id>
    <content type="html"><![CDATA[<p>코세라를 필두로 온라인 강의에 맛들여서 Code School도 맛보고 있는데 Most Useful jQuery Libraries란 스크린캐스트 강의에서 나온 라이브러리를 소개한다.</p>

<ul>
  <li><a href="http://jqueryui.com/autocomplete/">jQuery UI Autocomplete</a></li>
  <li><a href="http://flowplayer.org/tools/index.html">jQuery Tools</a> : 탭, 툴팁, 오버레이, 스크롤러블, 폼, 툴박스 등의 요긴한 UI를 제공.</li>
  <li><a href="http://fancybox.net/">FancyBox</a> : 라이트박스 즉, 이미지를 클릭하면 팝업으로 보여주는 기능을 제공.</li>
  <li><a href="http://datatables.net/">DataTables</a> : 정렬과 검색이 되는 스프레드시트 등에 유용.</li>
  <li><a href="http://tablesorter.com/docs/">tablesorter</a> : 표에서 행 정렬에 필요한 많은 기능을 제공.</li>
  <li><a href="http://harvesthq.github.com/chosen/">Chosen</a> : 유저 프랜들리 실렉트 박스.</li>
  <li><a href="http://bassistance.de/jquery-plugins/jquery-plugin-validation/">Validation</a> : 클라이언트 사이드 폼 유효성 검사.</li>
  <li><a href="http://digitalbush.com/projects/masked-input-plugin/">Masked Input</a> : 전화번호 등의 고정된 형식의 입력.</li>
  <li><a href="http://aquantum-demo.appspot.com/file-upload">jQuery File Upload</a> : 드래그앤드랍 멀티 업로드.</li>
  <li><a href="http://fitvidsjs.com/">FitVids.js</a> : 반응형 비디오 임베딩.</li>
  <li><a href="http://simianstudios.com/portamento/">Portamento.js</a> : 슬라이딩 고정 패널</li>
  <li><a href="http://tympanus.net/codrops/2011/09/12/elastislide-responsive-carousel/">Elasislade</a> 반응형 캐러셀</li>
  <li><a href="http://ryrych.github.com/rlightbox2">rightbox</a> 반응형 미디어 박스. 이미지, 유튜브, 비메오 등 지원.</li>
  <li><a href="http://fittextjs.com/">FitText</a> 가변 반응형 헤드라인.</li>
  <li><a href="http://cherne.net/brian/resources/jquery.hoverIntent.html">hoverIntent</a> 호버 기능의 확장.</li>
</ul>

<p>일년 전 강의지만 현재도 계속 소개되고 있는 것들이 많으며, 유료라 나중에 재확인하기 위해 기록한다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdoc 설치]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/install-markdoc/"/>
    <updated>2013-07-22T21:41:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/install-markdoc</id>
    <content type="html"><![CDATA[<p>[TOC]</p>

<h2 id="section">설치</h2>

<p>터미널에서</p>

<pre><code>$ easy_install Markdoc

Finished processing dependencies for Markdoc
</code></pre>

<p>위의 메시지가 나오면 성공.</p>

<h2 id="section-1">위키 만들기</h2>

<h3 id="section-2">위키 초기화</h3>

<pre><code>$ markdoc init my-wiki --vcs-ignore hg

markdoc.vcs-ignore: INFO: Writing ignore file to .hgignore
markdoc.init: INFO: Wiki initialization complete
markdoc.init: INFO: Your new wiki is at: .../my-wiki

$ cd .../my-wiki &lt;!-- more --&gt;
</code></pre>

<h3 id="section-3">페이지 편집</h3>

<p>wiki/ 서브 디렉토리에 문서가 위치하며, 마크다운 파일이다. .md 확장자를 가지며, wiki configuration에서 추가할 수 있다. wiki/ 디렉토리에서 마크다운 화일 작성.</p>

<h3 id="section-4">빌드</h3>

<p>아래 명령을 내리면 .html/ 서브디렉토리에 모든 HTML이 제너레이트된다.</p>

<pre><code>$ markdoc build
</code></pre>

<h3 id="section-5">보기</h3>

<pre><code>$ markdoc serve
markdoc.serve: INFO: Serving on http://127.0.0.1:8008
</code></pre>

<p>웹브라우저에서 <a href="http://localhost:8008/">http://localhost:8008/</a>를 열면 보인다.</p>

<h2 id="section-6">기타 기능</h2>

<ul>
  <li>구글 애널리틱스를 한줄 코드로 삽입</li>
  <li>rsync를 이용해 원격 서버와 동기화</li>
  <li>Pygments 지원 문법</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[100% 익명으로 웹 호스팅하는 방법]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/anonymous-hosting/"/>
    <updated>2013-07-22T21:40:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/anonymous-hosting</id>
    <content type="html"><![CDATA[<p>원본: <a href="http://bitcoinwebhosting.net/how-to-get-anonymous-web-hosting/">How To Get 100% Anonymous Web Hosting</a></p>

<p>익명 목적으로 사용하는 별도의 컴퓨터가 없다면 인터넷 접속하기 전과 후에 쿠키를 지워야 한다. Piriform의 <a href="http://www.piriform.com/ccleaner">CCleaner</a>가 널리 사용되는 무료 선택사항이다.</p>

<p>시작하기 전에 설치하고 쿠키를 지운 다음 아래 절차를 따라하라.</p>

<h2 id="tor-bundle-">절차 #1: Tor Bundle 다운로드</h2>

<p>Tor는 처음에 미국 해군 연구소에서 개발한 무료 오픈소스 소프트웨어이다. 공식웹페이지 <a href="https://www.torproject.org/">https://www.torproject.org/</a>에서 Tor Browser Bundle을 다운로드하여 설치한다.
<!-- more --></p>

<h2 id="section">절차 #2: 익명 이메일 계정 만들기</h2>

<p>정기적으로 이메일을 사용한다면 당신의 IP가 전세계에 걸쳐 텔레포팅(통신위성 등으로 전세계 정보를 수집하고 전달하는 것)되는 것과 차이나지 않는다. 당신의 트래픽을 익명화할 경우 어떤 개인적인 세부사항들을 입력하거나 실제 아이덴티티를 연결된 계정으로 로그인하거나 당신의 IP로 접근하지 말아야 한다.</p>

<p>익명 이메일 계정을 만드는 몇 가지 선택사항이 있다. 당연히 전화로 활성화되는 이메일 서비스를 사용하지 않기를 원할 것이다. 야후는 일반적으로 전화 활성화를 요구하지 않으나 문제가 있다면 <a href="http://tormail.org/">Tormail.org</a>를 이용할 수 있다. Tor 네트워크를 통해서만 접근할 수 있는 숨겨진 서비스이다.</p>

<p>주의 : 이메일 서비스를 포함하는 당신이 컨트롤할 수 없는 어떤 것도 신뢰하지 마라. Tor는 당신의 위치를 숨겨줄 것이나, 한 개의 이메일에서라도 당신이 정보를 공유하면 당신을 폭로할 수 있다.</p>

<h2 id="section-1">절차 #3: 비트코인 클라이언트를 다운로드하고 온라인 월릿(지갑)을 만들기</h2>

<p>월릿을 만들기 위해 비트코인이 필요하다. 첫번째 절차는 <a href="http://bitcoin.org/">비트코인 소프트웨어를 다운로드하는 것</a>이다. <a href="http://bitcoin.org/en/choose-your-wallet">온라인 월릿을 만드는 것</a>도 선택할 수 있다. 온라인 월릿을 사용하는 것이 다소 보안 위험이 있다. 장기간의 저장하기 위해서는 항상 콜드 월릿을 사용해야 한다. 그러나, 빠른 거래와 편의를 위해선 온라인 월릿은 훌륭하게 작동한다.</p>

<h2 id="section-2">절차 #4: 비트코인 구매</h2>

<p>비트코인을 구매할 수 있는 몇 개의 웹사이트가 있다. Mt. Gox, BitInstant, Coinbase는 개인정보를 입력할 것을 요구하고 이 튜토리얼에서 적합하지 않다. 익명성을 위한 가장 안전한 선택지를 열거한다:</p>

<ul>
  <li><a href="https://localbitcoins.com/">LocalBitcoins.com</a> - 당신이 큰 도시에 있다면 비트코인을 구매할 누군가를 로컬에서 찾을 수 있다. 공공 장소에서 만나고 트랜잭션을 확인하기 위해 네트워크를 위해 충분한 시간을 확보해라.</li>
</ul>

<h2 id="section-3">절차 #5: 익명 웹 호스팅 구매</h2>

<p>이제 필요한 절차는 <a href="http://bitcoinwebhosting.net/bitcoin-hosting/">호스팅 플랜을 선택</a>하고 결제 절차를 진행하는 것이다. 어떤 개인정보도 입력할 필요가 없다. <a href="http://bitcoinwebhosting.net/bitcoin-shared-hosting/">shared hosting plan</a>를 구매하고 BitPay가 계정을 자동으로 확인하고 계정정보를 이메일로 보낼 것이다. <a href="http://bitcoinwebhosting.net/bitcoin-vps-hosting/">anonymous VPS</a>이나 전용서버를 구매했다면 트랜잭션을 확인하기 위해 계정을 설정할 것이다.</p>

<p>이것이 100% 익명 웹 호스팅하는 방법이다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[반응형 디자인 적용하기(케이스 스터디)]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/adapting-to-a-responsive-design/"/>
    <updated>2013-07-22T21:40:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/adapting-to-a-responsive-design</id>
    <content type="html"><![CDATA[<p>원본: <a href="http://mobile.smashingmagazine.com/2013/06/18/adapting-to-a-responsive-design-case-study/">Adapting To A Responsive Design (Case Study)</a></p>

<h2 id="why-adapt-to-a-responsive-design">Why Adapt To A Responsive Design?</h2>

<h3 id="changing-our-approach">CHANGING OUR APPROACH</h3>
<p>새로운 폼팩터가 엄청나게 유입되면서 좀 더 future-friendly한, 동시에 관리하기 쉬운 웹사이트를 만들게 되었다.</p>

<h3 id="setting-goals-for-the-responsive-design">SETTING GOALS FOR THE RESPONSIVE DESIGN</h3>
<p><strong>반응형 디자인의 목표</strong></p>

<ol>
  <li>속도</li>
  <li>스타일, 백그라운드 혹은 자바스크립트와 상관없는 접근성</li>
  <li>하나의 컨텐츠</li>
  <li>플랫폼 독립성</li>
  <li><a href="http://futurefriend.ly/">미래지향</a> - 계속 유지보수하기 싫다.
<!-- more -->
먼저 신뢰할만한 고객에게 의견을 구했고, <a href="http://www.google.co.uk/analytics/">구글 애널리틱스</a>, <a href="http://www.leadforensics.com/">리드포렌식</a>, <a href="http://www.crazyegg.com/">크레이지에그</a> 등을 이용해 기존 웹사이트를 분석했다.</li>
</ol>

<p><em>링크를 허락하지 않으며 문맥에 큰 상관이 없으니 원본 그림 참조 바랍니다.</em></p>

<p>디자인 팀이 기존 컨텐츠를 재구성하기 위해 카드 소팅을 사용하고 있다.</p>

<h2 id="making-performance-a-priority">Making Performance A Priority</h2>

<p>특정 스크린 너비에서 보이지않게만 하는 방법은 성능이 문제가 된다. 모바일 breadpoint에서 40 HTTP 요청과 500KB 데이타를 넘지않길 원했다.</p>

<h3 id="third-party-scripts">THIRD-PARTY SCRIPTS</h3>

<p><a href="http://zurb.com/article/883/small-painful-buttons-why-social-media-bu">Zurb에 의하면</a>, 총 19개의 요청으로 페이스북, 트위터, 구글 소셜 미디어 버튼을 로드하는 것이 대역폭에서 246.7 KB를 잡아먹는다고 한다. 그래서 무거운 소셜미디어 플러그인을 가벼운 소셜미디어 링크로 대치하였다.</p>

<p><em>링크를 허락하지 않으며 문맥에 큰 상관이 없으니 원본 그림 참조 바랍니다.</em></p>

<p>몇개의 필수적인 트래킹 스크립트는 남겨야 했는데, HTML의 <code>body</code> 엘리먼트의 바닥과 외부 스크립트 화일에 집어넣어서 컨텐츠 이후에 로딩되도록 하였다.</p>

<h3 id="did-we-really-need-a-cms">DID WE REALLY NEED A CMS?</h3>

<p>토의 초기에 CMS가 필요한가에 검토하였는데 우리 대부분은 HTML, CSS, Git에 익숙하기 때문에 CMS 없이 컨텐츠를 관리하기로 했다.</p>

<p><a href="http://newrelic.com/">New Relic</a>과 같은 서버사이드 성능 모니터링 툴을 사용해서, 이전에 사용하던 CMS가 페이지 로딩 타임을 느리게하는 주요 요인이라는 것을 알 수 있었다. 그래서 웹사이트에서 CMS를 완전히 제거해버렸다. 블로그는 제외했는데, 올리는 컨텐츠의 양과 주기때문에 효과적으로 관리하기 위해서는 아직 CMS가 필요했다.</p>

<p><em>링크를 허락하지 않으며 문맥에 큰 상관이 없으니 원본 그림 참조 바랍니다.</em></p>

<p>이전 홈페이지 2.34초의 총 실행시간 동안 1,459번의 데이타베이스 서버를 쿼리했다.</p>

<p>이전 웹사이트는 워드프레스 CMS와 연결된 MVC 아키텍트로 구축되었었다. 예로 들었듯이 하나의 일반적인 페이지가 로드하되기위해 600 ~ 1,500 쿼리를 사용했다. 단순히 CMS를 제거함으로써 수백번의 데이타베이스 쿼리가 한방에 0으로 줄었다.</p>

<p><em>링크를 허락하지 않으며 문맥에 큰 상관이 없으니 원본 그림 참조 바랍니다.</em></p>

<p>초기 프로토타입을 개발하고 있다.</p>

<p>정적 페이지를 위한 CMS를 제거하여 데이타베이스와 동적인 템플릿에 대한 니즈를 생략했다. 인기 있는 PHP 프레임워크인 Laravel을 사용해 커스텀 동적 루트와 정적 템플릿 시스템을 적용했다. 이것은 템플릿 이름과 URL을 매칭시켜 웹사이트에서 URL이 호출될 때마다 Laravel 라우터가 로드될 템플릿을 정확하게 안다는 것을 의미한다. 또한, 그 템플릿은 HTML에서 정적으로 레이아웃된 컨텐츠를 이미 가지고 있다는 것을 의미한다.</p>

<p>이것만으로, 웹사이트 처리 속도를 3,900% 넘게 개선할 수 있었다. 평균 2.2초에서 56 밀리초로 서버 처리속도가 개선되었다.</p>

<p><em>링크를 허락하지 않으며 문맥에 큰 상관이 없으니 원본 그림 참조 바랍니다.</em></p>

<p>서버 처리 속도가 이제 단지 56밀리초이며, 데이타베이스 쿼리는 0이다. - 전보다 대략 40배 더 빨라졌다.</p>

<p>자연히 우리는 매 프로젝트의 시작에서 어떤 CMS가 가장 적합하고 필요한지 자문해야한다. 물론 다른 옵션도 있다. <a href="http://getkirby.com/">Kirby</a>와 <a href="http://statamic.com/">Statamic</a>와 같은 화일 베이스 CMS, <a href="http://grabaperch.com/">Perch</a>와 같은 경량 CMS를 구축하거나 커스터마이징, <a href="https://www.varnish-cache.org/">Varnish</a>와 같은 것을 이용해 더 나은 서버사이드 캐싱만을 적용하는 것 등이다.</p>

<p>결국, 가장 경량이더라도, 영리한 캐싱과 함께 CMS를 최적화 시키는 것조차도 오버헤드이고 성능과 정적화일의 서버 족적에 맞출 수 없어서 CMS를 제거하기로 결정했다.</p>

<h3 id="avoiding-off-the-shelf-css-frameworks">AVOIDING OFF-THE-SHELF CSS FRAMEWORKS</h3>

<p><a href="http://twitter.github.com/bootstrap/">Twitter Bootstrap</a>과 <a href="http://foundation.zurb.com/">Foundation</a>과 같은 CSS 프레임워크는 인터렉티브한 프로토타입을 재빠르게 구축하는 데에 훌륭하지만 대부분의 프로젝트에 필요한 것보단 종종 훨씬 더 복잡하다. 이들 프레임워크가 민감하고 광범위한 유즈 케이스에 맞추어져 있고 프로젝트의 특별한 요구에 맞추어져 있지 않기 때문이다.</p>

<p>우리는 단순하고 빠르고 우리 요구에 극도로 유연한 커스텀 반응형 그리드를 만들어 스타일 시트의 크기를 줄였다.</p>

<p>컨텐츠를 정의하는 레이아웃에 반해 컨텐츠가 레이아웃과 그리드를 모양짓는 것을 디자인하였다.</p>

<p><em>링크를 허락하지 않으며 문맥에 큰 상관이 없으니 원본 그림 참조 바랍니다.</em></p>

<p>위에서 부터 시계방향(놀부주: 시계반대방향인 듯)으로: 데스크탑에서 레이아웃은 3개의 행이고 모바일에선 하나의 행으로된 스택(쌓아놓은 더미)로 된다. 태블릿에선 컨텐츠 왼쪽에 이미지를 띄워 추가 공간의 이점을 살렸다.</p>

<pre><code>@media only screen and (min-width: 120px) and (min-device-width: 120px) {

   // Uses mobile grid
   .container {
      width: 100%;
   }
   .col12, .col11, .col10, .col9, .col8, .col7, .col6, .col5, .col4, .col3 {
      width: 92%;
      margin: 0 4% 20px 4%;
   }
   .col2 {
      width: 46%;
      float: left;
      margin: 0 4% 20px 4%;
   }
}

@media only screen and (min-width: 600px) and (min-device-width: 600px) {

   // Uses custom grid to accomodate content
   .home-content {
      article {
         width: 92%;
         clear: both;
         margin: 0 4% 20px 4%;
      }
      .image {
         float: left;
         width: 40%;
      }
      .text {
         float: left;
         width: 50%;
         margin-left: 5%;
         .btn {
            @include box-sizing(content-box);
            width: 100%;
         }
      }
   }
}

@media only screen and (min-width: 1024px) and (min-device-width: 1024px) {

   // Uses regular desktop grid system
   .container {
      width:960px;
      margin:0 auto;
   }
   .col4 {
      width: 300px;
      float: left;
      margin: 0 10px;
   }
}
</code></pre>

<p>코드 중복을 피하려고 <a href="http://sass-lang.com/">Sass</a>를 사용했고, 모든 CSS 코드가 실제로 사용되도록 했다. Sass에선 CSS를 가능한한 작게하기 위해 minify할 수도 있다.</p>

<pre><code>$sass --watch --style compressed scss:css
</code></pre>

<p>커스텀 그리드를 만들기 위해 Sass 안의 함수를 사용하기도 했다. 아래는 테스크탑 그리드를 위한 코드이다.</p>

<pre><code>@import "vars";

// Grid system
$wrap: $col * 12 + $gutter * 11;
@for $i from 2 through 12 {
   .col#{$i} {
      width: $col * $i + $gutter * $i - $gutter;
      float: left;
      margin: 0 $gutter/2 $vgrid $gutter/2;
   }
}
@for $i from 1 through 11 {
   .pre#{$i} {
      padding-left: $col * $i + $gutter * $i;
   }
}
@for $i from 1 through 11 {
   .suf#{$i} {
      padding-right: $col * $i + $gutter * $i;
   }
}
.container {
   width: $wrap + $gutter;
   margin: 0 auto;
   padding-top: 1px;
}
.colr {
   float: right;
   margin: 0 $gutter;
}
.alpha {
   margin-left: 0;
}
.omega {
   margin-right: 0;
}
</code></pre>

<p>여기서, 단순히 <code>vars</code> 화일을 편집함으로써 그리드의 <code>column</code>과 <code>gutter</code>의 너비를 커스터마이징할 수 있다.</p>

<pre><code>// Grid
$vgrid:      20px;
$col:        60px;
$gutter:     20px;
</code></pre>

<p><a href="https://github.com/Cyber-Duck/hoisin.scss">깃허브</a>에 오픈소스화 하였으니, 포크하여 당신의 프로젝트에 적용해 보고 어떤지 알려달라!</p>

<h3 id="conditionally-loading-javascript">CONDITIONALLY LOADING JAVASCRIPT</h3>

<p>속도 향상을 필요로 하고 지원될 때만 자바스크립트가 로드되길 원했고, <a href="http://requirejs.org/">RequireJS</a>를 이용했다. 자바스크립트 화일을 줄여주는 <a href="https://github.com/mishoo/UglifyJS">UglifyJS</a>도 포함되어있다.</p>

<p><em>링크를 허락하지 않으며 문맥에 큰 상관이 없으니 원본 그림 참조 바랍니다.</em></p>

<p>최적화로 자바스크립트 크기가 411 KB에서 106 KB로 줄었다.</p>

<h3 id="optimizing-image-assets">OPTIMIZING IMAGE ASSETS</h3>

<p>우리 웹사이트는 작업을 전시하기 위해 꽤 이미지가 무거운 실례이기 때문에 대부분의 웹사이트에서 가장 무거운 자산인 이미지 다운로드를 개선하길 원했다.</p>

<p>Adobe Firework의 <a href="http://help.adobe.com/en_US/fireworks/cs/using/WS3f28b00cc50711d9-73dfa65f133a490f3b9-8000.html">selective quality options</a>을 사용해 웹사이트의 전체 이미지를 수작업으로 최적화했다. 압축, blur, desaturation 등의 더 세세한 조정을 통해 이미지 화일 크기를 줄이기도 했다.</p>

<p><em>링크를 허락하지 않으며 문맥에 큰 상관이 없으니 원본 그림 참조 바랍니다.</em></p>

<p>이미지의 부분들을 desaturation하고 blur하는 것은 꼭 필요한 것은 아니지만 이미지 크기를 상당히 줄였다.</p>

<p><a href="http://imageoptim.com/">ImageOptim</a>와 <a href="http://tinypng.org/">TinyPNG</a>를 사용해 이미지와 스프라이트를 압축하기도 했다. 이 툴들은 이미지 질 저하없이 모든 불필요한 데이타를 제거한다. 예로 메인 이미지 스프라이트의 무게를 111 KB를 40 KB까지 줄였다.</p>

<p>홈페이지의 슬라이드쇼 배너에서는 미디어 쿼리를 이용해 적합한 크기의 이미지만 로드하여 다양한 스크린 크기에 최적화했다.</p>

<p><em>링크를 허락하지 않으며 문맥에 큰 상관이 없으니 원본 그림 참조 바랍니다.</em></p>

<p>위의 이미지는 모바일에서 볼 수 있고, 슬라이드쇼는 훨씬 더 가벼워졌다.</p>

<p>CSS는:</p>

<pre><code>@media only screen and (min-width: 120px) and (min-device-width: 120px) {
   .item-1 {
      background: $white url('carousel/dmd/background-optima-m.jpg') 50% 0 no-repeat;
      .computer, .tablet, .phone, .eiffel, .bigben, .train {
         display: none;
      }
   }
   /* Total loaded: 27 KB */
} 
</code></pre>

<p><em>링크를 허락하지 않으며 문맥에 큰 상관이 없으니 원본 그림 참조 바랍니다.</em></p>

<p>데스크탑에선 더 많은 자산을 로드한다.</p>

<p>데스크탑에서는 더 큰 스크린 크기의 대부분을 사용하도록 더 많은 자산을 로드한다.</p>

<p>CSS는:</p>

<pre><code>@media only screen and (min-width: 1024px) and (min-device-width: 1024px) {
   .item-1 {
      background: $white url('carousel/dmd/background.jpg') center -30px no-repeat;
      .computer {
         background: url('carousel/dmd/computer.png') center top no-repeat;
         div {
            background: url('carousel/dmd/sc-computer.jpg') center top no-repeat;
         }
      }
      .tablet {
         background: url('carousel/dmd/tablet.png') center top no-repeat;
         div   {
            background:  url('carousel/dmd/sc-tablet.jpg') center top no-repeat;
         }
      }
      .phone {
         background: url('carousel/dmd/phone.png') center top no-repeat;
         div {
            background: url('carousel/dmd/sc-mobile.jpg') center top no-repeat;
         }
      }
      .eiffel {
         background: url('#{$img}carousel/dmd/eiffel.png') center top no-repeat;
      }
      .bigben {
         background: url('#{$img}carousel/dmd/bigben.png') center top no-repeat;
      }
      .train {
         background: url('#{$img}carousel/dmd/train.png') center top no-repeat;
      }
   }
   /* Total loaded: 266 KB */
}
</code></pre>

<h3 id="delivering-content-faster">DELIVERING CONTENT FASTER</h3>

<p><a href="http://developer.yahoo.com/performance/rules.html">야후의 성능 황금률</a>에서는 엔드유저 반응 시간의 80-90%는 페이지의 모든 구성요소(이미지, 스타일 시트, 스크립트, 플래쉬 등)를 다운로드하는 것에 소비된다고 한다. 간략히, 각 요청은 처리하는 시간이 걸린다; 그러므로 서버에서 화일을 제공되는 것과 같은 각 요청은 로딩 시간을 불가피하게 증가시킬 것이다.</p>

<p><a href="http://www.cloudflare.com/features-cdn">CloudFlare의 CDN</a>을 이용하여 웹사이트 처리에서 웹 서버의 화일 제공 작업을 분리하였다. 이것은 우리 웹 서버를 정적 화일을 제공하기 보단 애플리케이션에 집중하도록 하는 것을 의미한다. 모든 정적인 자산을 분리된 서브도메인(우리 경우 <code>static.cyber-duck.co.uk</code>)으로 옮겼다. 각 자산에 요구되는 대역폭을 차례로 줄여 하나의 자산을 요청하는 각 요청과 함께 보내지는 쿠키를 최소로 줄이기 위한 것이다.</p>

<p>CDN은 캐싱하고, 유저 위치에 가장 가까운 서버에서 화일이 제공되도록 하게하고, 데이타가 더 짧은 거리에서 제공되기 때문에 네트워크 지연을 최소화하여 로딩 시간을 줄여준다.</p>

<p>CDN에 더해, Gzip 룰을 사용했고 <a href="https://github.com/h5bp/html5-boilerplate/blob/master/.htaccess">HTML5 Boilerplate의 <code>.htaccess</code> 화일</a>에서 헤더를 죽였다.(expire) This uses Apache’s mod_deflate module to compress the output of files to the browser and also sets an expiration on headers far into the future, to ensure better caching of the website for returning visitors.</p>

<h2 id="creating-a-truly-responsive-design">Creating A Truly Responsive Design</h2>

<p>진정한 반응형 디자인을 전달하기 위해, 모든 스타일링과 디스플레이 작업을 - 자바스크립트를 직접 사용해 엘리먼트를 숨기거나 보여주지 않고, CSS 클래스를 추가하거나 제거하여 엘리먼트의 상태만을 변경하기 위해 자바스크립트를 사용하고 - CSS 에만 위임했다.</p>

<h3 id="the-right-code-for-the-task">THE RIGHT CODE FOR THE TASK</h3>

<p>이 방법을 사용해 모바일 방문자가 전화하거나 사무실을 빠르게 찾을 수 있도록 전화와 지도 버튼을 갖도록 모바일의 탑 메뉴를 변형하는 등의 모바일에 특정한 최적화를 할 수 있었다.</p>

<p>이 접근법으로 웹사이트 전체에서 엘리먼트를 다이내믹하게 활성화하거나 비활성화하여 자바스크립트가 가능하지 않을 때에 페이지에 이 엘리먼트가 존재하도록 하였다.</p>

<p><em>링크를 허락하지 않으며 문맥에 큰 상관이 없으니 원본 그림 참조 바랍니다.</em></p>

<p>상단 GUI의 오른쪽에서 지도와 전화 버튼을 볼 수 있으며, 페이지의 나머지 부분을 접근할 수 있는 표준 컨트롤을 둘 수 있다.</p>

<p>자바스크립트 코드:</p>

<pre><code>$('#menu').addClass('closed');
$('.btn-menu').click(function(e){
   e.preventDefault();
   $('#menu').toggleClass('closed');
});
</code></pre>

<p>테스크탑 CSS:</p>

<pre><code>.nav {
   display: block;
   float: right;
}
.btn-menu, .btn-call, .btn-map {
   display: none;
}
</code></pre>

<p>모바일 CSS:</p>

<pre><code>.menu {
   display: block;
   height: auto;
   overflow: hidden;
}
.menu.closed {
   height: 0;
}
.btn-menu, .btn-call, .btn-map {
   display: block;
}
</code></pre>

<h3 id="animations-as-an-enhancement">ANIMATIONS AS AN ENHANCEMENT</h3>

<p>애니메이션 슬라이드쇼를 위해 HTML과 CSS만을 사용하는 슬라이드쇼를 만들기 위해 <a href="http://www.sequencejs.com/">SequenceJS</a>를 사용했다. 자바스크립트를 이용할 수 없거나 스크린 크기가 너무 작을 경우엔 애니메이션에 필요한 모든 자산을 다운로드할 필요가 없다.</p>

<p>다른 경우에도, <strong>애니메이션에는 CSS3만을 사용하기로 했다.</strong></p>

<p>이것은 CPU 작업을 GPU로 옮기는 하드웨어 가속을 사용해 애니메션 성능을 향상시켰다. 스마트폰이나 태블릿 사용자에게는 제한된 CPU 자원의 소비를 줄여 성능에 막대한 차이를 만들 수 있다.</p>

<p>CSS에 애니메이션을 위임하여 최고의 하드웨어 가속을 만들 수 있었따.</p>

<pre><code>.menu {
   height: auto;
   transition: height 200ms linear;
}
.menu.closed {
   height: 0;
   transition: height 200ms linear;
}
</code></pre>

<h3 id="breakpoints-based-on-content-and-design-not-device">BREAKPOINTS BASED ON CONTENT AND DESIGN, NOT DEVICE</h3>

<p>구분점(breakpoint)들에서 크고 작은 스크린에 최적화된 컨텐츠 표현을 반응적으로 전달하기 위해 다양한 CSS 미디어 쿼리를 사용했다.</p>

<p>이 기기 종속적이지 않은 접근법으로 다른 기기가 시장에 나올 때마다 코드를 최적화할 필요가 없게 되었다. 우리는 120, 240, 600, 760, 980, 1360에 구분점을 잡았다.</p>

<p><em>링크를 허락하지 않으며 문맥에 큰 상관이 없으니 원본 그림 참조 바랍니다.</em></p>

<p>웹사이트는 각 구분점 사이에서 유동적으로 반응한다.</p>

<p>미래 친화성을 더 확실히 하기위해 특정 기기에 기반한 구분점을 디자인하지 않고, 우리가 손에 넣을 수 있는 데스크탑 브라우저와 다양한 폰과 태블릿에서, Lynx, 플레이스테이션 3, 킨들 페이퍼 화이트, PSP Vita 등등의 많은 기기와 브라우저에서 테스트하였다. 오래된 노키아 기기에서도 테스트하였고 웹사이트는 잘 동작하였다.</p>

<p><em>링크를 허락하지 않으며 문맥에 큰 상관이 없으니 원본 그림 참조 바랍니다.</em></p>

<p>우리 디자이너와 프론트엔드 팀이 노키아 X2와 같은 오래된 모델을 포함한 매우 다양한 기기에서 테스트하였다.</p>

<h2 id="being-more-accessible">Being More Accessible</h2>

<p>웹 디자이너와 개발자로서 반응성은 웹 사이트를 더 접근하기 쉽게 만드는 것이 아니라 우리 고객과 동료가 왜 배려받아야 하는지에 관해 교육하는 것이다.</p>

<p>우리 웹사이트에 적용한 접근성에 대해 얻은 것 몇가지가 아래에 있다.</p>

<h3 id="text">TEXT</h3>

<ul>
  <li>텍스트는 배경에 대해 읽기쉬워야 한다. 헤딩에는 3:1, <code>body</code> 텍스트엔 4.5:1의 대조비를 준다.</li>
  <li>텍스트는 적절한 헤딩과 의미있는 순서로 구조되어야 하고 컨텐츠의 주제나 목적을 설명한다.</li>
  <li>텍스트는 컨텐츠나 기능성을 잃지 않고 크기를 변경할 수 있어야 한다.</li>
</ul>

<h3 id="links">LINKS</h3>

<ul>
  <li>모든 링크의 목적은 설명하는 텍스트와 함께 명료해야하고 할 수 없는 경우에는 대안 텍스트를 제공해야 한다.</li>
  <li>모든 페이지의 첫번째 링크는 컨텐츠로 직접 이동할 수 있는 내비게이션을 제공해야 한다.</li>
  <li>페이지 주소(즉, URL)은 사람이 읽기쉬워야 하고, 가능한 경우에는 영구적이어야 한다.</li>
  <li>중요한 페이지와 기능에 빠른 내비게이션을 위해 접근 관문을 제공했다.</li>
</ul>

<p>네비게이션 링크를 스킵하는 HTML:</p>

<pre><code>&lt;a href="#content" title="Skip to content" accesskey="s" class="btn-skip"&gt;Skip navigation&lt;/a&gt;
</code></pre>

<p>그리고 CSS:</p>

<pre><code>.btn-skip {
   position: absolute;
   left: -9999px;
}
</code></pre>

<h3 id="images">IMAGES</h3>

<ul>
  <li>모든 컨텐츠 이미지는 이미지가 불가하거나 지원되지 않을 때 보여주는 (<code>alt</code> 속성과 함께하는) 대안 텍스트를 가져야한다.</li>
  <li>컨텐츠는 이미지가 불가하거나 지원되지 않을 때에도 접근할 수 있거나 이해될 수 있어야 한다.</li>
</ul>

<h3 id="video">VIDEO</h3>

<ul>
  <li>모든 비디오는 말하는 부분이 있으면 캔셥이나 자막을 갖고, YouTube에 호스팅한다.</li>
</ul>

<h3 id="forms">FORMS</h3>

<ul>
  <li>모든 폼 컨트롤과 필드는 적절하고 명료하게 레이블한다.</li>
  <li>폼 입력은 터치 스크린에서 정확한 키보드가 로드되도록 형식과 속성을 할당한다.</li>
  <li>모든 중요한 폼 필드는 폼이 제출 될 때 에러를 체크하도록 한다.</li>
  <li>발견된 에러는 정정하는 방법에 대한 제안과 함께 유저에게 텍스트로 설명되어야 한다.</li>
  <li>모든 폼은 키보드에서 <code>tab</code>키로 내비게이션할 수 있도록 적절한 포커스 순서를 가져야 한다.</li>
  <li>모든 폼은 <code>Return</code>이나 <code>Enter</code>키로 제출할 수 있어야 한다.</li>
</ul>

<p><code>required</code>나 <code>placeholder</code>와 같은 적절한 input 타입과 속성을 사용하면 폼을 더 접근하기 쉽게 만들 수 있다.</p>

<pre><code>&lt;input type="email" id="email" name="email" value="" required="" placeholder="Pop your email address in here"&gt;
</code></pre>

<h2 id="just-getting-started">Just Getting Started</h2>

<p>몇 주전 새 웹사이트를 띄운 결과가 인상적이었다. 모바일 트래픽이 200% 넘게 증가하였고(모든 트래픽 평균에선 82%가 증가), 평균 방문 시간이 18% 증가혔다. 모바일 사용자의 exit 비율이 4,000% 감소하였다.</p>

<p><em>링크를 허락하지 않으며 문맥에 큰 상관이 없으니 원본 그림 참조 바랍니다.</em></p>

<p>구글 애널리틱스에 의하면 서버 반응 속도가 평균 1.21 초에서 170 밀리초로 감소하였다. 비슷하게 페이지 로딩 시간도 평균 9.19 초에서 1.82 초로 감소하였다.</p>

<p>여기서 중요한 것은 단지 시작이라는 것이다. 성능 최적화, 화일 크기 줄이기, 터치 제스처, <a href="http://adaptive-images.com/">adaptive images</a>과 같은 서버 사이드 솔루션 등을 더 사용할 수 있다.</p>

<p><em>링크를 허락하지 않으며 문맥에 큰 상관이 없으니 원본 그림 참조 바랍니다.</em></p>

<p>반응형으로 가는 것은 우리 웹사이트의 첫번째 단계일 뿐이다.</p>

<p>벤자민 플랭클린이 가로되, 당신이 변화를 끝낼 때 당신은 끝난 것이다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[모든 디자이너와 프런트 개발자가 숙달하고 있어야할 CSS 스니핏 50]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/50-useful-css-snippets/"/>
    <updated>2013-07-22T21:39:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/50-useful-css-snippets</id>
    <content type="html"><![CDATA[<p>원본 : <a href="http://www.hongkiat.com/blog/css-snippets-for-designers/">50 Useful CSS Snippets Every Designer Should Have</a></p>

<p><a href="http://www.hongkiat.com/blog/complete-guide-to-cross-browser-compatibility-check/">Complete Guide To Cross-Browser Compatibility Check</a></p>

<p><img src="http://media02.hongkiat.com/css-snippets-for-designers/css-snippets.jpg" alt="" /></p>

<p>이 기사가 모든 웹 프로들에게 <strong>50개의 편리한 CSS2/CCS3 코드 스니핏을</strong> 선물하기를 바란다.
<!-- more --></p>

<h4 id="css-resets">1. CSS Resets</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="css"><span class="line"><span class="nt">html</span><span class="o">,</span> <span class="nt">body</span><span class="o">,</span> <span class="nt">div</span><span class="o">,</span> <span class="nt">span</span><span class="o">,</span> <span class="nt">applet</span><span class="o">,</span> <span class="nt">object</span><span class="o">,</span> <span class="nt">iframe</span><span class="o">,</span> <span class="nt">h1</span><span class="o">,</span> <span class="nt">h2</span><span class="o">,</span> <span class="nt">h3</span><span class="o">,</span> <span class="nt">h4</span><span class="o">,</span> <span class="nt">h5</span><span class="o">,</span> <span class="nt">h6</span><span class="o">,</span> <span class="nt">p</span><span class="o">,</span> <span class="nt">blockquote</span><span class="o">,</span> <span class="nt">pre</span><span class="o">,</span> <span class="nt">a</span><span class="o">,</span> <span class="nt">abbr</span><span class="o">,</span> <span class="nt">acronym</span><span class="o">,</span> <span class="nt">address</span><span class="o">,</span> <span class="nt">big</span><span class="o">,</span> <span class="nt">cite</span><span class="o">,</span> <span class="nt">code</span><span class="o">,</span> <span class="nt">del</span><span class="o">,</span> <span class="nt">dfn</span><span class="o">,</span> <span class="nt">em</span><span class="o">,</span> <span class="nt">img</span><span class="o">,</span> <span class="nt">ins</span><span class="o">,</span> <span class="nt">kbd</span><span class="o">,</span> <span class="nt">q</span><span class="o">,</span> <span class="nt">s</span><span class="o">,</span> <span class="nt">samp</span><span class="o">,</span> <span class="nt">small</span><span class="o">,</span> <span class="nt">strike</span><span class="o">,</span> <span class="nt">strong</span><span class="o">,</span> <span class="nt">sub</span><span class="o">,</span> <span class="nt">sup</span><span class="o">,</span> <span class="nt">tt</span><span class="o">,</span> <span class="nt">var</span><span class="o">,</span> <span class="nt">b</span><span class="o">,</span> <span class="nt">u</span><span class="o">,</span> <span class="nt">i</span><span class="o">,</span> <span class="nt">center</span><span class="o">,</span> <span class="nt">dl</span><span class="o">,</span> <span class="nt">dt</span><span class="o">,</span> <span class="nt">dd</span><span class="o">,</span> <span class="nt">ol</span><span class="o">,</span> <span class="nt">ul</span><span class="o">,</span> <span class="nt">li</span><span class="o">,</span> <span class="nt">fieldset</span><span class="o">,</span> <span class="nt">form</span><span class="o">,</span> <span class="nt">label</span><span class="o">,</span> <span class="nt">legend</span><span class="o">,</span> <span class="nt">table</span><span class="o">,</span> <span class="nt">caption</span><span class="o">,</span> <span class="nt">tbody</span><span class="o">,</span> <span class="nt">tfoot</span><span class="o">,</span> <span class="nt">thead</span><span class="o">,</span> <span class="nt">tr</span><span class="o">,</span> <span class="nt">th</span><span class="o">,</span> <span class="nt">td</span><span class="o">,</span> <span class="nt">article</span><span class="o">,</span> <span class="nt">aside</span><span class="o">,</span> <span class="nt">canvas</span><span class="o">,</span> <span class="nt">details</span><span class="o">,</span> <span class="nt">embed</span><span class="o">,</span> <span class="nt">figure</span><span class="o">,</span> <span class="nt">figcaption</span><span class="o">,</span> <span class="nt">footer</span><span class="o">,</span> <span class="nt">header</span><span class="o">,</span> <span class="nt">hgroup</span><span class="o">,</span> <span class="nt">menu</span><span class="o">,</span> <span class="nt">nav</span><span class="o">,</span> <span class="nt">output</span><span class="o">,</span> <span class="nt">ruby</span><span class="o">,</span> <span class="nt">section</span><span class="o">,</span> <span class="nt">summary</span><span class="o">,</span> <span class="nt">time</span><span class="o">,</span> <span class="nt">mark</span><span class="o">,</span> <span class="nt">audio</span><span class="o">,</span> <span class="nt">video</span> <span class="p">{</span>
</span><span class="line">  <span class="k">margin</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span>
</span><span class="line">  <span class="k">padding</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span>
</span><span class="line">  <span class="k">border</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span>
</span><span class="line">  <span class="k">font-size</span><span class="o">:</span> <span class="m">100</span><span class="o">%</span><span class="p">;</span>
</span><span class="line">  <span class="k">font</span><span class="o">:</span> <span class="k">inherit</span><span class="p">;</span>
</span><span class="line">  <span class="k">vertical-align</span><span class="o">:</span> <span class="k">baseline</span><span class="p">;</span>
</span><span class="line">  <span class="k">outline</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span>
</span><span class="line">  <span class="o">-</span><span class="n">webkit</span><span class="o">-</span><span class="n">box</span><span class="o">-</span><span class="n">sizing</span><span class="o">:</span> <span class="k">border</span><span class="o">-</span><span class="n">box</span><span class="p">;</span>
</span><span class="line">  <span class="o">-</span><span class="n">moz</span><span class="o">-</span><span class="n">box</span><span class="o">-</span><span class="n">sizing</span><span class="o">:</span> <span class="k">border</span><span class="o">-</span><span class="n">box</span><span class="p">;</span>
</span><span class="line">  <span class="n">box</span><span class="o">-</span><span class="n">sizing</span><span class="o">:</span> <span class="k">border</span><span class="o">-</span><span class="n">box</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="nt">html</span> <span class="p">{</span> <span class="k">height</span><span class="o">:</span> <span class="m">101</span><span class="o">%</span><span class="p">;</span> <span class="p">}</span>
</span><span class="line"><span class="nt">body</span> <span class="p">{</span> <span class="k">font-size</span><span class="o">:</span> <span class="m">62</span><span class="o">.</span><span class="m">5</span><span class="o">%</span><span class="p">;</span> <span class="k">line-height</span><span class="o">:</span> <span class="m">1</span><span class="p">;</span> <span class="k">font-family</span><span class="o">:</span> <span class="n">Arial</span><span class="o">,</span> <span class="n">Tahoma</span><span class="o">,</span> <span class="k">sans-serif</span><span class="p">;</span> <span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="nt">article</span><span class="o">,</span> <span class="nt">aside</span><span class="o">,</span> <span class="nt">details</span><span class="o">,</span> <span class="nt">figcaption</span><span class="o">,</span> <span class="nt">figure</span><span class="o">,</span> <span class="nt">footer</span><span class="o">,</span> <span class="nt">header</span><span class="o">,</span> <span class="nt">hgroup</span><span class="o">,</span> <span class="nt">menu</span><span class="o">,</span> <span class="nt">nav</span><span class="o">,</span> <span class="nt">section</span> <span class="p">{</span> <span class="k">display</span><span class="o">:</span> <span class="k">block</span><span class="p">;</span> <span class="p">}</span>
</span><span class="line"><span class="nt">ol</span><span class="o">,</span> <span class="nt">ul</span> <span class="p">{</span> <span class="k">list-style</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span> <span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="nt">blockquote</span><span class="o">,</span> <span class="nt">q</span> <span class="p">{</span> <span class="k">quotes</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span> <span class="p">}</span>
</span><span class="line"><span class="nt">blockquote</span><span class="nd">:before</span><span class="o">,</span> <span class="nt">blockquote</span><span class="nd">:after</span><span class="o">,</span> <span class="nt">q</span><span class="nd">:before</span><span class="o">,</span> <span class="nt">q</span><span class="nd">:after</span> <span class="p">{</span> <span class="k">content</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">;</span> <span class="k">content</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span> <span class="p">}</span>
</span><span class="line"><span class="nt">strong</span> <span class="p">{</span> <span class="k">font-weight</span><span class="o">:</span> <span class="k">bold</span><span class="p">;</span> <span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="nt">table</span> <span class="p">{</span> <span class="k">border-collapse</span><span class="o">:</span> <span class="k">collapse</span><span class="p">;</span> <span class="k">border-spacing</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span> <span class="p">}</span>
</span><span class="line"><span class="nt">img</span> <span class="p">{</span> <span class="k">border</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span> <span class="k">max-width</span><span class="o">:</span> <span class="m">100</span><span class="o">%</span><span class="p">;</span> <span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="nt">p</span> <span class="p">{</span> <span class="k">font-size</span><span class="o">:</span> <span class="m">1.2em</span><span class="p">;</span> <span class="k">line-height</span><span class="o">:</span> <span class="m">1.0em</span><span class="p">;</span> <span class="k">color</span><span class="o">:</span> <span class="m">#333</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><a href="http://meyerweb.com/eric/tools/css/reset/">에릭 마이어의 리셋 코드</a>를커스터마이징한 스니핏이다. 반응형 이미지에 대한 추가하고 모든 핵심 엘리먼트에 <strong>border-box</strong>를 설정하고, 마진과 패딩 수치가 알맞게 정렬되게 한다.</p>

<h4 id="classic-css-clearfix">2. Classic CSS Clearfix</h4>

<pre><code>.clearfix:after { content: "."; display: block; clear: both; visibility: hidden; line-height: 0; height: 0; }
.clearfix { display: inline-block; }
 
html[xmlns] .clearfix { display: block; }
* html .clearfix { height: 1%; }
</code></pre>

<p>이 clearfix 코드는 정통한 웹 개발자들 사이에 몇년 간 돌아다닌 것이다. 플로팅된 엘리먼트를 담는 컨테이너에 이 클래스를 적용해야한다. 뒤에 오는 어떤 컨텐츠도 <strong>플로트되지 않아 끌어내려지지 않고 명확해질 것이다.</strong></p>

<h4 id="updated-clearfix">3. 2011 Updated Clearfix</h4>

<pre><code>.clearfix:before, .container:after { content: ""; display: table; }
.clearfix:after { clear: both; }

/* IE 6/7 */
.clearfix { zoom: 1; }
</code></pre>

<p>새 버전과 클래식 버전 간의 주요 렌더링 차이점을 말할 수는 없지만  두 버전 모두 플로트를 효과적으로 지울 것이며, IE 6~8을 포함한 모든 최신 브라우저에서 작동할 것이다.</p>

<h4 id="cross-browser-transparency">4. Cross-Browser Transparency</h4>

<pre><code>.transparent {
    filter: alpha(opacity=50); /* internet explorer */
    -khtml-opacity: 0.5;      /* khtml, old safari */
    -moz-opacity: 0.5;       /* mozilla, netscape */
    opacity: 0.5;           /* fx, safari, opera */
}
</code></pre>

<p><em><a href="http://perishablepress.com/cross-browser-transparency-via-css/">Code Source</a></em></p>

<p>모든 곳에 적용하고 싶어지는 CSS3 속성 중 하나인 불투명도(opacity)를 <strong>필터 속성을 추가해서</strong> IE의 예전 버전에서도 우아하게 다룰 수 있다.</p>

<h4 id="css-blockquote-template">5. CSS Blockquote Template</h4>

<pre><code>blockquote {
    background: #f9f9f9;
    border-left: 10px solid #ccc;
    margin: 1.5em 10px;
    padding: .5em 10px;
    quotes: "\201C""\201D""\2018""\2019";
}
blockquote:before {
    color: #ccc;
    content: open-quote;
    font-size: 4em;
    line-height: .1em;
    margin-right: .25em;
    vertical-align: -.4em;
}
blockquote p {
    display: inline;
}
</code></pre>

<p><em><a href="http://css-tricks.com/snippets/css/simple-and-nice-blockquote-styling/">Code Source</a></em></p>

<p><strong>블로그나 웹페이지에서 인용되거나 반복되는 컨텐츠를 분리하기 위해</strong> HTML 엘리먼트에 아주 훌륭한 코드라고 생각한다.</p>

<h4 id="individual-rounded-corners">6. Individual Rounded Corners</h4>

<pre><code>#container {
    -webkit-border-radius: 4px 3px 6px 10px;
    -moz-border-radius: 4px 3px 6px 10px;
    -o-border-radius: 4px 3px 6px 10px;
    border-radius: 4px 3px 6px 10px;
}

/* alternative syntax broken into each line */
#container {
    -webkit-border-top-left-radius: 4px;
    -webkit-border-top-right-radius: 3px;
    -webkit-border-bottom-right-radius: 6px;
    -webkit-border-bottom-left-radius: 10px;
    
    -moz-border-radius-topleft: 4px;
    -moz-border-radius-topright: 3px;
    -moz-border-radius-bottomright: 6px;
    -moz-border-radius-bottomleft: 10px;
}
</code></pre>

<p><strong>모서리 각각에 다른 값을 설정하고 싶을 경우</strong> 이 코드 스니핏을 사용해라. 숏버전과 롱버전을 같이 포함하였다.</p>

<h4 id="general-media-queries--">7. General Media Queries(범용 미디어 쿼리)</h4>

<pre><code>/* Smartphones (portrait and landscape) ----------- */
@media only screen 
and (min-device-width : 320px) and (max-device-width : 480px) {
  /* Styles */
}

/* Smartphones (landscape) ----------- */
@media only screen and (min-width : 321px) {
  /* Styles */
}

/* Smartphones (portrait) ----------- */
@media only screen and (max-width : 320px) {
  /* Styles */
}

/* iPads (portrait and landscape) ----------- */
@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) {
  /* Styles */
}

/* iPads (landscape) ----------- */
@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : landscape) {
  /* Styles */
}

/* iPads (portrait) ----------- */
@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : portrait) {
  /* Styles */
}

/* Desktops and laptops ----------- */
@media only screen and (min-width : 1224px) {
  /* Styles */
}

/* Large screens ----------- */
@media only screen and (min-width : 1824px) {
  /* Styles */
}

/* iPhone 4 ----------- */
@media only screen and (-webkit-min-device-pixel-ratio:1.5), only screen and (min-device-pixel-ratio:1.5) {
  /* Styles */
}
</code></pre>

<p><em><a href="http://css-tricks.com/snippets/css/media-queries-for-standard-devices/">Code Source</a></em></p>

<p>위의 소스에서 얻을 수 있는 아주 훌륭한 템플릿이어서 몽땅 복사해왔다. 이 코드는 <code>min-device-pixel-ratio</code>을 사용해 레티나 베이스 기기도 목표로 할 수도 있다.</p>

<h4 id="modern-font-stacks---">8. Modern Font Stacks(최신 폰트 스택 모음)</h4>

<pre><code>/* Times New Roman-based serif */
font-family: Cambria, "Hoefler Text", Utopia, "Liberation Serif", "Nimbus Roman No9 L Regular", Times, "Times New Roman", serif;

/* A modern Georgia-based serif */
font-family: Constantia, "Lucida Bright", Lucidabright, "Lucida Serif", Lucida, "DejaVu Serif," "Bitstream Vera Serif", "Liberation Serif", Georgia, serif;

/*A more traditional Garamond-based serif */
font-family: "Palatino Linotype", Palatino, Palladio, "URW Palladio L", "Book Antiqua", Baskerville, "Bookman Old Style", "Bitstream Charter", "Nimbus Roman No9 L", Garamond, "Apple Garamond", "ITC Garamond Narrow", "New Century Schoolbook", "Century Schoolbook", "Century Schoolbook L", Georgia, serif;

/*The Helvetica/Arial-based sans serif */
font-family: Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif;

/*The Verdana-based sans serif */
font-family: Corbel, "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", "DejaVu Sans", "Bitstream Vera Sans", "Liberation Sans", Verdana, "Verdana Ref", sans-serif;

/*The Trebuchet-based sans serif */
font-family: "Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif;

/*The heavier "Impact" sans serif */
font-family: Impact, Haettenschweiler, "Franklin Gothic Bold", Charcoal, "Helvetica Inserat", "Bitstream Vera Sans Bold", "Arial Black", sans-serif;

/*The monospace */
font-family: Consolas, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", Monaco, "Courier New", Courier, monospace;
</code></pre>

<p><em><a href="http://www.sitepoint.com/eight-definitive-font-stacks/">Code Source</a></em></p>

<p>새로운 웹페이지를 디자인할 때 자신만의 CSS 폰트 스택을 브레인스토밍하는 것은 어렵다. 이 스니핏이 고민을 덜어 시작하기 위한 템플릿들이 되길 바란다. 더 많은 예를 원한다면 내가 좋아하는 리소스 중 하나인 <a href="http://cssfontstack.com/">CSS Font Stack</a>을 확인해라.</p>

<h4 id="custom-text-selection--">9. Custom Text Selection(하일라이트 색상 변경)</h4>

<pre><code>::selection { background: #e2eae2; }
::-moz-selection { background: #e2eae2; }
::-webkit-selection { background: #e2eae2; }
</code></pre>

<p>몇몇 최신 웹 브라우저는 웹페이지의 하일라이트 색상을 정의할 수 있다. <strong>이 (원본)페이지는 light blue가 디폴트로 되어있다.</strong> 이 스니핏은 웹킷과 모질라의 업체 접두어(vendor prefixes)와 함께하는 전형적인 <code>::selection</code>을 포함한다.</p>

<h4 id="hiding-h1-text-for-logo-h1--">10. Hiding H1 Text for Logo(로고의 H1 텍스트 숨기기)</h4>

<pre><code>h1 {
    text-indent: -9999px;
    margin: 0 auto;
    width: 320px;
    height: 85px;
    background: transparent url("images/logo.png") no-repeat scroll;
}
</code></pre>

<p>이 기술이 오래된 <a href="http://web.archive.org/web/20080229090645/http://digg.com/">Digg layout</a>에서 적용된 것을 맨 먼저 알았었다. 웹사이트 이름을 SEO 목적으로 순수 텍스트로 주어서 H1 태그를 배치할 수 있다. CSS로 <strong>이 텍스트를 보이지 않게 움직이고 로고 이미지로 대치할 수 있다.</strong></p>

<h4 id="polaroid-image-border--">11. Polaroid Image Border(폴라로이드형 이미지 테두리)</h4>

<pre><code>img.polaroid {
    background:#000; /*Change this to a background image or remove*/
    border:solid #fff;
    border-width:6px 6px 20px 6px;
    box-shadow:1px 1px 5px #333; /* Standard blur at 5px. Increase for more depth */
    -webkit-box-shadow:1px 1px 5px #333;
    -moz-box-shadow:1px 1px 5px #333;
    height:200px; /*Set to height of your image or desired div*/
    width:200px; /*Set to width of your image or desired div*/
}
</code></pre>

<p><em><a href="http://www.smipple.net/snippet/kettultim/Polaroid%20Image%20Border%20-%20CSS3">Code Source</a></em></p>

<p>이 기본 스니핏으로 이미지에 <strong>폴라로이드</strong> 클래스를 적용할 수 있으며, <strong>큰 백색 경계선과 약간의 박스 그림자와 함께 오래된 사진 스타일을 만들 것이다.</strong> 이미지 차원과 웹사이트 레이아웃에 어울리게 너비/높이 값을 변경할 수 있다.</p>

<h4 id="anchor-link-pseudo-classes--">12. Anchor Link Pseudo Classes(초심자용 앵커 링크)</h4>

<pre><code>a:link { color: blue; }
a:visited { color: purple; }
a:hover { color: red; }
a:active { color: yellow; }
</code></pre>

<p><em><a href="http://www.ahrefmagazine.com/web-design/30-useful-css-snippets-for-developers">Code Source</a></em></p>

<p>대부분의 CSS 개발자는 앵커 링크 스타일과 <code>:hover</code> 효과를 알고있으나, 초심자들은 이 코드 스니핏을 참조로서 사용하길 권한다. 앵커 링크와 다른 HTML 엘리먼트 몇 개에 네 가지 기본 상태를 준다.</p>

<h4 id="fancy-css3-pull-quotes--">13. Fancy CSS3 Pull-Quotes(멋진 별도 인용)</h4>

<pre><code>.has-pullquote:before {
    /* Reset metrics. */
    padding: 0;
    border: none;
    
    /* Content */
    content: attr(data-pullquote);
    
    /* Pull out to the right, modular scale based margins. */
    float: right;
    width: 320px;
    margin: 12px -140px 24px 36px;
    
    /* Baseline correction */
    position: relative;
    top: 5px;
    
    /* Typography (30px line-height equals 25% incremental leading) */
    font-size: 23px;
    line-height: 30px;
}

.pullquote-adelle:before {
    font-family: "adelle-1", "adelle-2";
    font-weight: 100;
    top: 10px !important;
}

.pullquote-helvetica:before {
    font-family: "Helvetica Neue", Arial, sans-serif;
    font-weight: bold;
    top: 7px !important;
}

.pullquote-facit:before {
    font-family: "facitweb-1", "facitweb-2", Helvetica, Arial, sans-serif;
    font-weight: bold;
    top: 7px !important;
}
</code></pre>

<p><em><a href="http://miekd.com/articles/pull-quotes-with-html5-and-css/">Code Source</a></em></p>

<p>Pull-quote는 블로그와 뉴스 기사의 옆쪽으로 떨여져 보이게되어blockquotes와는 다르다. 종종 기사에서 인용된 텍스트를 언급하며 blockquote와는 약간 다르게 보인다. 이 기본 클래스는 3개의 폰트패밀리를 포함했으니 적용할 때는 하나만 선택하라.</p>

<h4 id="fullscreen-backgrounds-with-css3">14. Fullscreen Backgrounds with CSS3</h4>

<pre><code>html { 
    background: url('images/bg.jpg') no-repeat center center fixed; 
    -webkit-background-size: cover;
    -moz-background-size: cover;
    -o-background-size: cover;
    background-size: cover;
}
</code></pre>

<p><em><a href="http://css-tricks.com/perfect-full-page-background-image/">Code Source</a></em></p>

<p>이 코드는 CSS3 문접을 지원하지 않는 오래된 브라우저에서는 잘 동작하지 않는다. 그러나, 오랜 브라우저 지원을 신경쓰지 않고 빠른 해법을 원한다면 최고다! <strong>웹 사이트 배경에 커다란 사진을 추가하고도 크기 변경과 스크롤에도 잘 유지되어 훌륭한 코드다.</strong></p>

<h4 id="vertically-centered-content--">15. Vertically Centered Content(수직적 중앙 정렬)</h4>

<pre><code>.container {
    min-height: 6.5em;
    display: table-cell;
    vertical-align: middle;
}
</code></pre>

<p><em><a href="http://www.w3.org/Style/Examples/007/center">Code Source</a></em></p>

<p><code>margin: 0 auto</code> 기술을 사용하여 컨텐츠를 페이지의 수평적 중앙에 끼워넣는 것은 매우 쉽다. 그러나 수직 컨텐츠는 훨씬 더 어렵다. 이것은 자바스크립트없이도 완벽하게 작동하는 순수 CSS 해법이다.</p>

<h4 id="force-vertical-scrollbars--">16. Force Vertical Scrollbars(수직 스크롤바 강제)</h4>

<pre><code>html { height: 101% }
</code></pre>

<p>페이지 컨텐츠가 브라우저 창의 전체 높이를 채우지 않는다면 결국 스크롤바를 얻지 못한다. 이 스니핏은 스크롤바가 항상 남도록 HTML 엘리먼트가 브라우저보다 아주 약간 높도록 해준다.</p>

<h4 id="css3-gradients-template">17. CSS3 Gradients Template</h4>

<pre><code>#colorbox {
    background: #629721;
    background-image: -webkit-gradient(linear, left top, left bottom, from(#83b842), to(#629721));
    background-image: -webkit-linear-gradient(top, #83b842, #629721);
    background-image: -moz-linear-gradient(top, #83b842, #629721);
    background-image: -ms-linear-gradient(top, #83b842, #629721);
    background-image: -o-linear-gradient(top, #83b842, #629721);
    background-image: linear-gradient(top, #83b842, #629721);
}
</code></pre>

<p>CSS3 그라디언트는 새로운 스펙의 놀라운 부분 중 하나다. 많은 업체 접두어가 기억하기 힘들며, 이 코드 스니핏이 프로젝트 시간을 줄여줄 것이다.</p>

<h4 id="font-face-template">18. @font-face Template</h4>

<pre><code>@font-face {
    font-family: 'MyWebFont';
    src: url('webfont.eot'); /* IE9 Compat Modes */
    src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
    url('webfont.woff') format('woff'), /* Modern Browsers */
    url('webfont.ttf')  format('truetype'), /* Safari, Android, iOS */
    url('webfont.svg#svgFontName') format('svg'); /* Legacy iOS */
}
    
body {
    font-family: 'MyWebFont', Arial, sans-serif;
}
</code></pre>

<p><em><a href="http://css-tricks.com/snippets/css/using-font-face/">Code Source</a></em></p>

<p>여기 기억하기 힘든 CSS3가 또 있다. <code>@font-face</code>를 사용하여 자신의 TTF/OTF/SVG/WOFF 파일을 웹사이트에 끼워넣고 별도의 폰트 패밀리를 만들어낼 수 있다. 향후 프로젝트의 기본예제로 이 템플릿을 사용하라.</p>

<h4 id="stitched-css3-elements">19. Stitched CSS3 Elements</h4>

<pre><code>p {
    position:relative;
    z-index:1;
    padding: 10px;
    margin: 10px;
    font-size: 21px;
    line-height: 1.3em;
    color: #fff;
    background: #ff0030;
    -webkit-box-shadow: 0 0 0 4px #ff0030, 2px 1px 4px 4px rgba(10,10,0,.5);
    -moz-box-shadow: 0 0 0 4px #ff0030, 2px 1px 4px 4px rgba(10,10,0,.5);
    box-shadow: 0 0 0 4px #ff0030, 2px 1px 6px 4px rgba(10,10,0,.5);
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}

p:before {
    content: "";
    position: absolute;
    z-index: -1;
    top: 3px;
    bottom: 3px;
    left :3px;
    right: 3px;
    border: 2px dashed #fff;
}

p a {
    color: #fff;
    text-decoration:none;
}

p a:hover, p a:focus, p a:active {
    text-decoration:underline;
}
</code></pre>

<p><em><a href="http://kitmacallister.com/2011/css3-stitched-elements/">Code Source</a>: 사이트 운영 안함</em></p>

<ul>
  <li>역자추가링크 : &lt;http://www.techrepublic.com/blog/webmaster/create-cool-stitched-effects-with-css3/1964&gt;</li>
</ul>

<h4 id="css3-zebra-stripes-">20. CSS3 Zebra Stripes(얼룩말 줄무늬)</h4>

<pre><code>tbody tr:nth-child(odd) {
    background-color: #ccc;
}
</code></pre>

<p><em><a href="http://css-tricks.com/snippets/css/css3-zebra-striping-a-table/">Code Source</a></em></p>

<p>얼룩말 줄무늬를 포함하는 것은 데이타 표 안에서 가장 많이 사용된다. 사용자가 40 혹은 50개의 열을 훑어 볼 때 어느 셀이 어느 열에 속하는지 정확히 구별하기가 어렵다. 기본으로 얼룩말 줄무늬를 추가해서 홀수 열의 백그라운드 색상을 변화를 줄 수 있다.</p>

<h4 id="fancy-ampersand-">21. Fancy Ampersand(근사한 <code>&amp;</code>)</h4>

<pre><code>.amp {
    font-family: Baskerville, 'Goudy Old Style', Palatino, 'Book Antiqua', serif;
    font-style: italic;
    font-weight: normal;
}
</code></pre>

<p><em><a href="http://css-tricks.com/snippets/css/fancy-ampersand/">Code Source</a></em></p>

<p>이 클래스는 페이지 내용에서 <code>&amp;</code> 기호 주위를 감싸는 <code>span</code> 엘리먼트를 적용한다. 고전적인 세리프 폰트와 <code>&amp;</code> 기호를 강하게 보여주기 위한 이탤릭체가 적용될 것이다.</p>

<h4 id="drop-cap-paragraphs--">22. Drop-Cap Paragraphs(문단의 큰 첫글자)</h4>

<pre><code>p:first-letter{
    display: block;
    margin: 5px 0 0 5px;
    float: left;
    color: #ff3366;
    font-size: 5.4em;
    font-family: Georgia, Times New Roman, serif;
}
</code></pre>

<p>신문과 책 같은 인쇄된 매체에선 일반적으로 크게 처리된 문단의 첫글자를 일반적으로 볼 수 있다. 웹과 블로그에서도 레이아웃 안에 충분한 여기가 있다면 단정한 효과를 줄 수 있다. 이 CSS 규칙은 모든 문단을 목표로 하고 있으나 특정 한 클래스나 ID로 제한할 수도 있다.</p>

<h4 id="inner-css3-box-shadow--">23. Inner CSS3 Box Shadow(안쪽 박스 그림자)</h4>

<h1 id="mydiv-">mydiv {</h1>
<pre><code>-moz-box-shadow: inset 2px 0 4px #000;
-webkit-box-shadow: inset 2px 0 4px #000;
box-shadow: inset 2px 0 4px #000; }
</code></pre>

<p>박스 그림자 속성은 웹사이트를 만드는 방법에 굉장한 변화를 주었다. 거의 모든 엘리먼트에 박스 그림자를 그릴 수 있고 모두 훌륭하게 보인다. 이 코드는 디자인하기가 훨씬 더 어렵지만 제대로된 경우 청순하게 보이는 안쪽 그림자를 만들 것이다.</p>

<h4 id="outer-css3-box-shadow--">24. Outer CSS3 Box Shadow(바깥쪽 박스 그림자)</h4>

<pre><code>#mydiv { 
    -webkit-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);
    -moz-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);
    box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);
}
</code></pre>

<p>바깥쪽 CSS3 그림자의 세번째 숫자는 흐리는 거리(blur)을 나타내고 4번째 숫자는 그림자 크기(spread)를 나타낸다. 이 값들은 <a href="http://www.w3schools.com/cssref/css3_pr_box-shadow.asp">W3Schools</a>에서 더 많이 배울 수 있다.</p>

<h4 id="triangular-list-bullets--">25. Triangular List Bullets(삼각형 글머리 기호)</h4>

<pre><code>ul {
    margin: 0.75em 0;
    padding: 0 1em;
    list-style: none;
}
li:before { 
    content: "";
    border-color: transparent #111;
    border-style: solid;
    border-width: 0.35em 0 0.35em 0.45em;
    display: block;
    height: 0;
    width: 0;
    left: -1em;
    top: 0.9em;
    position: relative;
}
</code></pre>

<p><em><a href="http://jsfiddle.net/chriscoyier/yNZTU/">Code Source</a></em></p>

<p>믿거나 말거나 실제로 <strong>CSS3만으로 삼각형 글머리 기호를 만들어 낼 수 있다.</strong> 평판있는 브라우저에서 아주 멋지게 보이는 쿨한 기술이다. 유일한 잠재적인 이슈는 대체(fallback) 방법이 없다는 것이다.</p>

<h4 id="centered-layout-fixed-width---">26. Centered Layout Fixed Width(고정폭 중앙 정렬 레이아웃)</h4>

<pre><code>#page-wrap {
    width: 800px;
    margin: 0 auto;
}
</code></pre>

<p><em><a href="http://css-tricks.com/snippets/css/centering-a-website/">Code Source</a></em></p>

<p>고정폭 레이아웃에 완벽한 <strong>수평 배치 스니핏</strong>이다.</p>

<h4 id="css3-column-textcss3--">27. CSS3 Column Text(CSS3 텍스트 열)</h4>

<pre><code>#columns-3 {
    text-align: justify;
    -moz-column-count: 3;
    -moz-column-gap: 12px;
    -moz-column-rule: 1px solid #c4c8cc;
    -webkit-column-count: 3;
    -webkit-column-gap: 12px;
    -webkit-column-rule: 1px solid #c4c8cc;
}
</code></pre>

<p><em><a href="http://www.djavupixel.com/development/css-development/master-css3-ultimate-css-code-snippets/">Code Source</a></em></p>

<p>CSS3 <code>columns</code>은 컬럼(열) 형식으로 텍스트를 분할할 수 있다. 이 스니핏을 사용하여 단락을 원하는 개수의 컬럼으로 나눌 수 있다.</p>

<h4 id="css-fixed-footer-">28. CSS Fixed Footer(고정 푸터)</h4>

<pre><code>#footer {
    position: fixed;
    left: 0px;
    bottom: 0px;
    height: 30px;
    width: 100%;
    background: #444;
}
 
/* IE 6 */
* html #footer {
    position: absolute;
    top: expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+'px');
}
</code></pre>

<p><em><a href="http://www.flashjunior.ch/school/footers/fixed.cfm">Code Source</a></em></p>

<p>웹사이트에 고정 푸터를 매다는 것은 아주 쉽다. 유저의 스크롤을 따니면서 사이트에 도움이 되는 정보 혹은 상세한 연락처를 보여줄 것이다. 이상적으론 유저 인터페이스에 실제로 가치가 있는 경우에만 적용될 것이다.</p>

<h4 id="transparent-png-fix-for-ie6ie6--png-">29. Transparent PNG Fix for IE6(IE6용 투명 PNG 교정)</h4>

<pre><code>.bg {
    width:200px;
    height:100px;
    background: url(/folder/yourimage.png) no-repeat;
    _background:none;
    _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='/folder/yourimage.png',sizingMethod='crop');
}


/* 1px gif method */
img, .png {
    position: relative;
    behavior: expression((this.runtimeStyle.behavior="none")&amp;&amp;(this.pngSet?this.pngSet=true:(this.nodeName == "IMG" &amp;&amp; this.src.toLowerCase().indexOf('.png')&gt;-1?(this.runtimeStyle.backgroundImage = "none",
       this.runtimeStyle.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this.src + "', sizingMethod='image')",
       this.src = "images/transparent.gif"):(this.origBg = this.origBg? this.origBg :this.currentStyle.backgroundImage.toString().replace('url("','').replace('")',''),
       this.runtimeStyle.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this.origBg + "', sizingMethod='crop')",
       this.runtimeStyle.backgroundImage = "none")),this.pngSet=true));
}
</code></pre>

<p><em><a href="http://css-tricks.com/snippets/css/png-hack-for-ie-6/">Code Source</a></em></p>

<p>웹사이트에 투명한 이미지를 사용하는 것은 매우 일반적인 일이다. gif 이미지로 시작되어 알파 투명 PNG로 진화해왔다. 불행히 아주 오랜 버전의 IE는 투명도를 전혀 지원하지 않는다. 이 CSS 스니핏이 문제를 해결해줄 것이다.</p>

<h4 id="cross-browser-minimum-height">30. Cross-Browser Minimum Height</h4>

<pre><code>#container {
    min-height: 550px;
    height: auto !important;
    height: 550px;
}
</code></pre>

<p>많은 최신 브라우저는 <code>min-height</code>를 완벽하게 다루어주나, IE와 오래된 Firefox는 문제가 있다. 이 코드 세트는 관련된 어떤 버그에도 교정해줄 것이다.</p>

<h4 id="css3-glowing-inputs-input-">31. CSS3 Glowing Inputs(빛나는 Input 엘리먼트)</h4>

<p>input[type=text], textarea {
    -webkit-transition: all 0.30s ease-in-out;
    -moz-transition: all 0.30s ease-in-out;
    -ms-transition: all 0.30s ease-in-out;
    -o-transition: all 0.30s ease-in-out;
    outline: none;
    padding: 3px 0px 3px 3px;
    margin: 5px 1px 3px 0px;
    border: 1px solid #ddd;
}</p>

<p>input[type=text]:focus, textarea:focus {
    box-shadow: 0 0 5px rgba(81, 203, 238, 1);
    padding: 3px 0px 3px 3px;
    margin: 5px 1px 3px 0px;
    border: 1px solid rgba(81, 203, 238, 1);
}</p>

<p><em><a href="http://css-tricks.com/snippets/css/glowing-blue-input-highlights/">Code Source</a></em></p>

<p>크롬과 사파리 유저는 폼에서 인풋 외곽선이 거슬리다는 것을 안다. 스타일 시트에 이 스니핏을 넣으면 기본 인풋 엘리먼트를 완전히 새로운 디자인으로 만들어줄 것이다.</p>

<h4 id="style-links-based-on-filetype----">32. Style Links Based on Filetype(화일 형식에 따른 링크 스타일링)</h4>

<pre><code>/* external links */
a[href^="http://"] {
    padding-right: 13px;
    background: url('external.gif') no-repeat center right;
}
 
/* emails */
a[href^="mailto:"] {
    padding-right: 20px;
    background: url('email.png') no-repeat center right;
}
 
/* pdfs */
a[href$=".pdf"] {
    padding-right: 18px;
    background: url('acrobat.png') no-repeat center right;
}
</code></pre>

<p><em><a href="http://www.designyourway.net/blog/resources/31-css-code-snippets-to-make-you-a-better-coder/">Code Source</a></em></p>

<p>CSS 실렉터와 백그라운드 이미지 아이콘을 사용하여 링크의 화일 형식을 결정할 수 있다. 다양한 프로토콜(HTTP, FTP, IRC, mailto) 혹은  단순히 화일 형식 자체(mp3, avi, pdf)를 포함할 수 있다.</p>

<h4 id="force-code-wraps--">33. Force Code Wraps(코드 줄바꿈 강제)</h4>

<pre><code>pre {
    white-space: pre-wrap;       /* css-3 */
    white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
    white-space: -pre-wrap;      /* Opera 4-6 */
    white-space: -o-pre-wrap;    /* Opera 7 */
    word-wrap: break-word;       /* Internet Explorer 5.5+ */
}
</code></pre>

<p><em><a href="http://css-tricks.com/snippets/css/make-pre-text-wrap/">Code Source</a></em></p>

<p>pre 태그는 많은 양의 코드를 보여주는 레이아웃에서 사용된다. 이 CSS는 노트패드나 텍스트에디터에서 보는 것과 같이 줄이 길 때 수평 스크롤바를 하지않게 코드를 보여준다. 즉, 컨테이너 바깥으로 튀어나가지 않고 <strong>모든 pre 태그가 코드를 줄바꿈하게 한다.</strong></p>

<h4 id="force-hand-cursor-over-clickable-items----">34. Force Hand Cursor over Clickable Items(클릭 항목에 손모양 커서 강제)</h4>

<pre><code>a[href], input[type='submit'], input[type='image'], label[for], select, button, .pointer {
    cursor: pointer;
}
</code></pre>

<p><em><a href="http://css-tricks.com/snippets/css/give-clickable-elements-a-pointer-cursor/">Code Source</a></em></p>

<p>손 모양 아이콘을 항상 표시하지 않는 클릭 HTML 엘리먼트가 많다. 이 CSS 실렉터 세트는 핵심 엘리먼트와 <strong>.pointer</strong> 클래스를 사용하는 객체에 포인터를 강제한다.</p>

<h4 id="webpage-top-box-shadow---">35. Webpage Top Box Shadow(웹페이지 탑 박스 그림자)</h4>

<pre><code>body:before {
    content: "";
    position: fixed;
    top: -10px;
    left: 0;
    width: 100%;
    height: 10px;

    -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8);
    -moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8);
    box-shadow: 0px 0px 10px rgba(0,0,0,.8);
    z-index: 100;
}
</code></pre>

<p><em><a href="http://css-tricks.com/snippets/css/top-shadow/">Code Source</a></em></p>

<p><code>body</code> 엘리먼트에 이 CSS 코드를 추가하면 <strong>웹페이시 상단에서부터 아래로 어두워지는 그림자가 생긴다.</strong></p>

<h4 id="css3-speech-bubble-">36. CSS3 Speech Bubble(말 풍선)</h4>

<pre><code>.chat-bubble {
    background-color: #ededed;
    border: 2px solid #666;
    font-size: 35px;
    line-height: 1.3em;
    margin: 10px auto;
    padding: 10px;
    position: relative;
    text-align: center;
    width: 300px;
    -moz-border-radius: 20px;
    -webkit-border-radius: 20px;
    -moz-box-shadow: 0 0 5px #888;
    -webkit-box-shadow: 0 0 5px #888;
    font-family: 'Bangers', arial, serif; 
}
.chat-bubble-arrow-border {
    border-color: #666 transparent transparent transparent;
    border-style: solid;
    border-width: 20px;
    height: 0;
    width: 0;
    position: absolute;
    bottom: -42px;
    left: 30px;
}
.chat-bubble-arrow {
    border-color: #ededed transparent transparent transparent;
    border-style: solid;
    border-width: 20px;
    height: 0;
    width: 0;
    position: absolute;
    bottom: -39px;
    left: 30px;
}
</code></pre>

<p><em><a href="http://html5snippets.com/snippets/35-css3-comic-bubble-using-triangle-trick">Code Source</a></em></p>

<p>이것은 토론 댓글 혹은 게시판 혹은 인용 문구에 편리한다.</p>

<h4 id="default-h1-h5-headers">37. Default H1-H5 Headers</h4>

<pre><code>h1,h2,h3,h4,h5{
    color: #005a9c;
}
h1{
    font-size: 2.6em;
    line-height: 2.45em;
}
h2{
    font-size: 2.1em;
    line-height: 1.9em;
}
h3{
    font-size: 1.8em;
    line-height: 1.65em;
}
h4{
    font-size: 1.65em;
    line-height: 1.4em;
}
h5{
    font-size: 1.4em;
    line-height: 1.25em;
}
</code></pre>

<p><em><a href="https://snipt.net/freshmaker99/headers/">Code Source</a></em></p>

<p>이 템플릿은 H1 ~ H5의 모든 주요 헤딩 엘리먼트에 기본 스타일을 준다. 난 결코 본 적이 없지만, H6를 추가하는 것을 고려할 수도 있다.</p>

<h4 id="pure-css-background-noisecss--">38. Pure CSS Background Noise(CSS만의 배경 노이즈)</h4>

<pre><code>body {
    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAAG3RSTlNAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAvEOwtAAAFVklEQVR4XpWWB67c2BUFb3g557T/hRo9/WUMZHlgr4Bg8Z4qQgQJlHI4A8SzFVrapvmTF9O7dmYRFZ60YiBhJRCgh1FYhiLAmdvX0CzTOpNE77ME0Zty/nWWzchDtiqrmQDeuv3powQ5ta2eN0FY0InkqDD73lT9c9lEzwUNqgFHs9VQce3TVClFCQrSTfOiYkVJQBmpbq2L6iZavPnAPcoU0dSw0SUTqz/GtrGuXfbyyBniKykOWQWGqwwMA7QiYAxi+IlPdqo+hYHnUt5ZPfnsHJyNiDtnpJyayNBkF6cWoYGAMY92U2hXHF/C1M8uP/ZtYdiuj26UdAdQQSXQErwSOMzt/XWRWAz5GuSBIkwG1H3FabJ2OsUOUhGC6tK4EMtJO0ttC6IBD3kM0ve0tJwMdSfjZo+EEISaeTr9P3wYrGjXqyC1krcKdhMpxEnt5JetoulscpyzhXN5FRpuPHvbeQaKxFAEB6EN+cYN6xD7RYGpXpNndMmZgM5Dcs3YSNFDHUo2LGfZuukSWyUYirJAdYbF3MfqEKmjM+I2EfhA94iG3L7uKrR+GdWD73ydlIB+6hgref1QTlmgmbM3/LeX5GI1Ux1RWpgxpLuZ2+I+IjzZ8wqE4nilvQdkUdfhzI5QDWy+kw5Wgg2pGpeEVeCCA7b85BO3F9DzxB3cdqvBzWcmzbyMiqhzuYqtHRVG2y4x+KOlnyqla8AoWWpuBoYRxzXrfKuILl6SfiWCbjxoZJUaCBj1CjH7GIaDbc9kqBY3W/Rgjda1iqQcOJu2WW+76pZC9QG7M00dffe9hNnseupFL53r8F7YHSwJWUKP2q+k7RdsxyOB11n0xtOvnW4irMMFNV4H0uqwS5ExsmP9AxbDTc9JwgneAT5vTiUSm1E7BSflSt3bfa1tv8Di3R8n3Af7MNWzs49hmauE2wP+ttrq+AsWpFG2awvsuOqbipWHgtuvuaAE+A1Z/7gC9hesnr+7wqCwG8c5yAg3AL1fm8T9AZtp/bbJGwl1pNrE7RuOX7PeMRUERVaPpEs+yqeoSmuOlokqw49pgomjLeh7icHNlG19yjs6XXOMedYm5xH2YxpV2tc0Ro2jJfxC50ApuxGob7lMsxfTbeUv07TyYxpeLucEH1gNd4IKH2LAg5TdVhlCafZvpskfncCfx8pOhJzd76bJWeYFnFciwcYfubRc12Ip/ppIhA1/mSZ/RxjFDrJC5xifFjJpY2Xl5zXdguFqYyTR1zSp1Y9p+tktDYYSNflcxI0iyO4TPBdlRcpeqjK/piF5bklq77VSEaA+z8qmJTFzIWiitbnzR794USKBUaT0NTEsVjZqLaFVqJoPN9ODG70IPbfBHKK+/q/AWR0tJzYHRULOa4MP+W/HfGadZUbfw177G7j/OGbIs8TahLyynl4X4RinF793Oz+BU0saXtUHrVBFT/DnA3ctNPoGbs4hRIjTok8i+algT1lTHi4SxFvONKNrgQFAq2/gFnWMXgwffgYMJpiKYkmW3tTg3ZQ9Jq+f8XN+A5eeUKHWvJWJ2sgJ1Sop+wwhqFVijqWaJhwtD8MNlSBeWNNWTa5Z5kPZw5+LbVT99wqTdx29lMUH4OIG/D86ruKEauBjvH5xy6um/Sfj7ei6UUVk4AIl3MyD4MSSTOFgSwsH/QJWaQ5as7ZcmgBZkzjjU1UrQ74ci1gWBCSGHtuV1H2mhSnO3Wp/3fEV5a+4wz//6qy8JxjZsmxxy5+4w9CDNJY09T072iKG0EnOS0arEYgXqYnXcYHwjTtUNAcMelOd4xpkoqiTYICWFq0JSiPfPDQdnt+4/wuqcXY47QILbgAAAABJRU5ErkJggg==);
    background-color: #0094d0;
}
</code></pre>

<p><em><a href="https://coderwall.com/p/m-uwvg">Code Source</a></em></p>

<p>알파투명도와 타일 이미지를 반복사용했더라도 디자이너들은 이 효과를 오래동안 웹사이트 추가해왔다. 그러나, 최신 이미지를 만들기 위해 Base64 코드를 CSS에 집어넣을 수 있다. 위의 스니핏에선 <code>body</code> 배경에 노이즈 텍스처를 만들어냈다. <a href="http://www.noisetexturegenerator.com/">NoiseTextureGenerator</a>를 이용하여 맞춤 노이즈 배경을 만들 수 있다.</p>

<h4 id="continued-list-ordering--">39. Continued List Ordering(항목 번호 이어가기)</h4>

<pre><code>ol.chapters {
    list-style: none;
    margin-left: 0;
}

ol.chapters &gt; li:before {
    content: counter(chapter) ". ";
    counter-increment: chapter;
    font-weight: bold;
    float: left;
    width: 40px;
}

ol.chapters li {
    clear: left;
}

ol.start {
    counter-reset: chapter;
}

ol.continue {
    counter-reset: chapter 11;
}
</code></pre>

<p><em><a href="http://timmychristensen.com/css-ordered-list-numbering-examples.html">Code Source</a></em></p>

<p>아주 인기있는 스니핏은 아니지만 개발자들 사이에선 나름 사용되고 있다. <strong>두 개의 분리된 UL 엘리먼트에서 CSS만으로 항목 번호를 이어지게 한다.</strong></p>

<h4 id="css-tooltip-hoverscss--">40. CSS Tooltip Hovers(CSS 툴팁 호버)</h4>

<pre><code>a { 
    border-bottom:1px solid #bbb;
    color:#666;
    display:inline-block;
    position:relative;
    text-decoration:none;
}
a:hover,
a:focus {
    color:#36c;
}
a:active {
    top:1px; 
}
 
/* Tooltip styling */
a[data-tooltip]:after {
    border-top: 8px solid #222;
    border-top: 8px solid hsla(0,0%,0%,.85);
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    content: "";
    display: none;
    height: 0;
    width: 0;
    left: 25%;
    position: absolute;
}
a[data-tooltip]:before {
    background: #222;
    background: hsla(0,0%,0%,.85);
    color: #f6f6f6;
    content: attr(data-tooltip);
    display: none;
    font-family: sans-serif;
    font-size: 14px;
    height: 32px;
    left: 0;
    line-height: 32px;
    padding: 0 15px;
    position: absolute;
    text-shadow: 0 1px 1px hsla(0,0%,0%,1);
    white-space: nowrap;
    -webkit-border-radius: 5px;
    -moz-border-radius: 5px;
    -o-border-radius: 5px;
    border-radius: 5px;
}
a[data-tooltip]:hover:after {
    display: block;
    top: -9px;
}
a[data-tooltip]:hover:before {
    display: block;
    top: -41px;
}
a[data-tooltip]:active:after {
    top: -10px;
}
a[data-tooltip]:active:before {
    top: -42px;
}
</code></pre>

<p><em><a href="http://www.impressivewebs.com/pure-css-tool-tips/">Code Source</a></em></p>

<p>웹사이트에 적용할 수 있는 오프소스 jQuery 기반의 툴팁은 많다. 그러나, CSS 기반의 툴팁은 드물고 내가 선호하는 스니핏 중 하나다. 스타일시트에 복사하고 HTML data 속성을 사용하여 <code>data-tooltip</code>으로 툴팁 문구를 설정할 수 있다.</p>

<h4 id="dark-grey-rounded-buttons---">41. Dark Grey Rounded Buttons(짙은 회색 라운드 버튼)</h4>

<pre><code>.graybtn {
    -moz-box-shadow:inset 0px 1px 0px 0px #ffffff;
    -webkit-box-shadow:inset 0px 1px 0px 0px #ffffff;
    box-shadow:inset 0px 1px 0px 0px #ffffff;
    background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #ffffff), color-stop(1, #d1d1d1) );
    background:-moz-linear-gradient( center top, #ffffff 5%, #d1d1d1 100% );
    filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffff', endColorstr='#d1d1d1');
    background-color:#ffffff;
    -moz-border-radius:6px;
    -webkit-border-radius:6px;
    border-radius:6px;
    border:1px solid #dcdcdc;
    display:inline-block;
    color:#777777;
    font-family:arial;
    font-size:15px;
    font-weight:bold;
    padding:6px 24px;
    text-decoration:none;
    text-shadow:1px 1px 0px #ffffff;
}
.graybtn:hover {
    background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #d1d1d1), color-stop(1, #ffffff) );
    background:-moz-linear-gradient( center top, #d1d1d1 5%, #ffffff 100% );
    filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#d1d1d1', endColorstr='#ffffff');
    background-color:#d1d1d1;
}
.graybtn:active {
    position:relative;
    top:1px;
}
</code></pre>

<p><em><a href="http://html5snippets.com/snippets/1-a-css-rounded-gray-button">Code Source</a></em></p>

<p>클래스 이름을 색상과 맞는 <strong>.graybtn</strong>를 사용하였지만, 여러분의 웹사이트에 맞게 스타일을 변경할 수 없는 것은 아니다.</p>

<h4 id="display-urls-in-a-printed-webpage--url-">42. Display URLS in a Printed Webpage(인쇄된 웹페이지에 URL 표시하기)</h4>

<pre><code>@media print   {  
  a:after {  
    content: " [" attr(href) "] ";  
  }  
}
</code></pre>

<p><em><a href="http://www.smipple.net/snippet/bramloquet/Print%20the%20url%20after%20your%20links">Code Source</a></em></p>

<p>뉴스 웹사이트나 인쇄할 게 많은 리소스를 운영하고 있다면 정말 훌륭한 스니핏 중 하나가 될 수 있다. 웹페이지의 앵커 링크는 정확히 보통으로 보이고 표현될 것이다. 그러나 인쇄될 때에는 사용자가 풀 하이퍼링크 URL을 볼 수 있을 것이다. 방문자가 링크해 놓은 웹페이지에 접근할 필요가 있으나 <strong>일반적인 인쇄된 문서에선 URL를 볼 수 없을 때</strong> 편리하다.</p>

<h4 id="disable-mobile-webkit-highlights---">43. Disable Mobile Webkit Highlights(모바일 웹킷 하일라이트 제거)</h4>

<pre><code>body {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
</code></pre>

<p>사파리나 웹킷 기반 엔진에서 모바일 웹사이트에 접근할 때 탭한 엘리먼트 주위로 회색 박스가 생기는 것을 눈여겨볼 수 있다. 웹사이트에 이 스타일을 추가하기면 하면 <strong>모든 모바일 브라우저의 하일라이트를 제거할</strong> 것이다.</p>

<h4 id="css3-polka-dot-patterncss3---">44. CSS3 Polka-Dot Pattern(CSS3 폴카-점 패턴)</h4>

<pre><code>body {
    background: radial-gradient(circle, white 10%, transparent 10%),
    radial-gradient(circle, white 10%, black 10%) 50px 50px;
    background-size: 100px 100px;
}
</code></pre>

<p><em><a href="http://dabblet.com/gist/1457668">Code Source</a></em></p>

<p>CSS3만으로 급하게 배경 패턴을 만들어내는 정말 재밌는 방법이다. 기본적으로 <code>body</code> 엘리먼트를 목표로 하지만 웹페이지의 어떤 컨테이너 <code>div</code>에도 적용할 수 있다.</p>

<h4 id="css3-checkered-pattern">45. CSS3 Checkered Pattern</h4>

<pre><code>body {
    background-color: white;
    background-image: linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black), 
    linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black);
    background-size: 100px 100px;
    background-position: 0 0, 50px 50px;
}
</code></pre>

<p><em><a href="http://dabblet.com/gist/1457677">Code Source</a></em></p>

<p>폴카-점 패턴과 비슷하게 체커보드 패턴을 만들 수 있다. 이 방법은 약간 더 많은 문법이 필요하지만 모든 CSS3 지원 브라우저에서 완벽하게 보인다. 웹사이트 컬러스킴에 맞게 흑백 색상 값을 변경할 수 있다.</p>

<h4 id="github-fork-ribbon--">46. Github Fork Ribbon(깃허브 포크 리본)</h4>

<pre><code>.ribbon {
    background-color: #a00;
    overflow: hidden;
    /* top left corner */
    position: absolute;
    left: -3em;
    top: 2.5em;
    /* 45 deg ccw rotation */
    -moz-transform: rotate(-45deg);
    -webkit-transform: rotate(-45deg);
    /* shadow */
    -moz-box-shadow: 0 0 1em #888;
    -webkit-box-shadow: 0 0 1em #888;
}
.ribbon a {
    border: 1px solid #faa;
    color: #fff;
    display: block;
    font: bold 81.25% 'Helvetiva Neue', Helvetica, Arial, sans-serif;
    margin: 0.05em 0 0.075em 0;
    padding: 0.5em 3.5em;
    text-align: center;
    text-decoration: none;
    /* shadow */
    text-shadow: 0 0 0.5em #444;
}
</code></pre>

<p><em><a href="http://unindented.org/articles/2009/10/github-ribbon-using-css-transforms/">Code Source</a></em></p>

<p>CSS3 <code>transform</code> 속성을 사용하여 웹사이트에 깃허브 코너 리본을 빠르게 만들어낼 수 있다.</p>

<h4 id="condensed-css-font-propertiescss---">47. Condensed CSS Font Properties(CSS 폰트 속성 요약)</h4>

<pre><code>p {
  font: italic small-caps bold 1.2em/1.0em Arial, Tahoma, Helvetica;
}
</code></pre>

<p><em><a href="http://www.csspop.com/view/542">Code Source</a></em></p>

<p>웹 개발자들이 이 요약된 폰트 속성을 항상 사용하지는 않는 주요 이유는 모든 설정이 필요하지 않기 때문이다. 그러나, 이 숏핸드를 이해하면 많은 시간과 스타일시트의 공간을 절약할 것이다.</p>

<h4 id="paper-page-curl-effect---">48. Paper Page Curl Effect(종이 페이지 휘는 효과)</h4>

<pre><code>ul.box {
    position: relative;
    z-index: 1; /* prevent shadows falling behind containers with backgrounds */
    overflow: hidden;
    list-style: none;
    margin: 0;
    padding: 0; 
}

ul.box li {
    position: relative;
    float: left;
    width: 250px;
    height: 150px;
    padding: 0;
    border: 1px solid #efefef;
    margin: 0 30px 30px 0;
    background: #fff;
    -webkit-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset;
    -moz-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; 
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; 
}

ul.box li:before,
ul.box li:after {
    content: '';
    z-index: -1;
    position: absolute;
    left: 10px;
    bottom: 10px;
    width: 70%;
    max-width: 300px; /* avoid rotation causing ugly appearance at large container widths */
    max-height: 100px;
    height: 55%;
    -webkit-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    -moz-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    -webkit-transform: skew(-15deg) rotate(-6deg);
    -moz-transform: skew(-15deg) rotate(-6deg);
    -ms-transform: skew(-15deg) rotate(-6deg);
    -o-transform: skew(-15deg) rotate(-6deg);
    transform: skew(-15deg) rotate(-6deg); 
}

ul.box li:after {
    left: auto;
    right: 10px;
    -webkit-transform: skew(15deg) rotate(6deg);
    -moz-transform: skew(15deg) rotate(6deg);
    -ms-transform: skew(15deg) rotate(6deg);
    -o-transform: skew(15deg) rotate(6deg);
    transform: skew(15deg) rotate(6deg); 
}
</code></pre>

<p><em><a href="http://www.csspop.com/view/524">Code Source</a></em></p>

<p>이 페이지 휘는 효과는 웹사이트 컨텐츠를 담는 거의 모든 컨테이너에 적용될 수 있다. 이미지 미디어, 인용 문구 등을 즉시 생각해낼 수 있지만 실제로는 모든 것에 가능할 것이다. 링크된 소스코드 페이지에 데모를 체크해보라.</p>

<h4 id="glowing-anchor-links--">49. Glowing Anchor Links(빛나는 앵커 링크)</h4>

<pre><code>a {
    color: #00e;
}
a:visited {
    color: #551a8b;
}
a:hover {
    color: #06e;
}
a:focus {
    outline: thin dotted;
}
a:hover, a:active {
    outline: 0;
}
a, a:visited, a:active {
    text-decoration: none;
    color: #fff;
    -webkit-transition: all .3s ease-in-out;
}
a:hover, .glow {
    color: #ff0;
    text-shadow: 0 0 10px #ff0;
}
</code></pre>

<p><em><a href="http://www.csspop.com/view/625">Code Source</a></em></p>

<p>CSS3 텍스트 그림자는 웹페이지 타이포그래피를 스타일링하는 유일한 방법이다. 이 스니핏은 <strong>링크가 빛나는 호버 효과가 나도록 한다.</strong></p>

<h4 id="featured-css3-display-banner-css3-">50. Featured CSS3 Display Banner(주목받는 CSS3 배너)</h4>

<pre><code>.featureBanner {
    position: relative;
    margin: 20px
}
.featureBanner:before {
    content: "Featured";
    position: absolute;
    top: 5px;
    left: -8px;
    padding-right: 10px;
    color: #232323;
    font-weight: bold;
    height: 0px;
    border: 15px solid #ffa200;
    border-right-color: transparent;
    line-height: 0px;
    box-shadow: -0px 5px 5px -5px #000;
    z-index: 1;
}

.featureBanner:after {
    content: "";
    position: absolute;
    top: 35px;
    left: -8px;
    border: 4px solid #89540c;
    border-left-color: transparent;
    border-bottom-color: transparent;
}
</code></pre>

<p><em><a href="http://www.csspop.com/view/553">Code Source</a></em></p>

<p>일반적으론 이 효과를 대체할 배경 이미지를 설정할 필요가 있지만 CSS3 지원 엔진에선 <strong>이미지 없이 컨텐츠 래퍼의 가장자리에 걸리는 동적 배너</strong>를 만들어낼 수 있다. 전자상거래 상품이나 이미지 섬네일, 비디오 프리뷰 혹은 블로그 기사 위에 붙여져 멋져 보일 수 있다.</p>

<h3 id="final-thoughts">Final Thoughts</h3>

<p>모든 독자는 여기의 스니핏을 어떤 의무나 권한도 요구되지않고 복사하거나 저장할 수 있다. 대부분의 CSS 코드가 오픈소스 라이센스이며 무료로 제공된다.</p>

<h4 id="section">역자 추가 링크</h4>
<ul>
  <li><a href="http://www.designresourcebox.com/web-design-issues-that-you-can-solve-with-css-snippets/">Web Design Issues That You Can Solve With CSS Snippets</a></li>
  <li><a href="http://www.djavupixel.com/development/css-development/master-css3-ultimate-css-code-snippets/">Master your CSS3! Ultimate CSS code snippets</a></li>
  <li><a href="http://www.designyourway.net/blog/resources/31-css-code-snippets-to-make-you-a-better-coder/">31 CSS Code Snippets To Make You A Better Coder</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS 프리프로세서 LESS 튜토리얼과 프리젠테이션]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/less-tutorial-and-presentation/"/>
    <updated>2013-07-22T21:38:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/less-tutorial-and-presentation</id>
    <content type="html"><![CDATA[<p>원본 : <a href="http://brianflove.com/2012/10/03/less-tutorial-and-presentation/">LESS tutorial and presentation</a></p>

<h3 id="less">LESS란?</h3>

<p><a href="http://css-tricks.com/poll-results-popularity-of-css-preprocessors/">css-tricks에서 2012년 6월 실시한 조사</a>에 의하면 46%의 사람들이 CSS preprocessor를 경험하지 않았다. LESS가 51%이다.</p>

<ul>
  <li>LESS는 프로그래밍이다.</li>
  <li>LESS는 CSS로 컴파일된다.</li>
  <li>LESS는 CSS 프리프로세서다.</li>
  <li>LESS 문법은 전통적인 CSS 모델을 따른다.</li>
  <li>LESS는 다이내믹 CSS로 불리기도 한다.
<!-- more --></li>
</ul>

<h3 id="less-">왜 LESS를 사용하나?</h3>

<ul>
  <li>시간 절약</li>
  <li>실수 줄이기</li>
  <li>반복 줄이기(DRY)</li>
  <li>CSS를 여러 화일로 쪼개 logical sense하게 관리한다.
  CSS @import는 각 화일마다 새로운 HTTP 요청을 발생시켜 성능에 좋지 않다.</li>
  <li>LESS는 쿨하다!</li>
</ul>

<p>CSS 프리프로세서는 CSS를 기능적으로 확장시키진 않는다. 대신에 개발 플로우를 더 쉽게 해준다. CSS를 압축하고 있다면, CSS 프리프로세서를 사용하는 것이 다음 단계다.</p>

<h3 id="less--1">LESS 설치</h3>

<pre><code>npm install less --global
</code></pre>

<h3 id="less----">LESS로 뭘 할 수 있나?</h3>

<p>LESS는 CSS가 제공하지 않는 기능을 제공한다.</p>

<ul>
  <li>변수</li>
  <li>Mixins : 룰셋을 재사용할 수 있게 해주는 함수</li>
  <li>DOM 구조와 유사한 스타일 nesting</li>
  <li>간단한 수학적 연산자 : 숫자와 컬러의 +,-,*,/</li>
  <li>floor(), ceilling(), round()와 같은 수학적 연산자</li>
  <li>darken(), lighten(), fadein(), fadeour()과 같은 컬러 연산자</li>
</ul>

<h3 id="section">변수</h3>

<ul>
  <li>@로 시작</li>
  <li><code>#333</code> 혹은 <code>#fefefe</code>와 같은 헥사컬러값을 저장할 수 있다.</li>
  <li>“Webcubator, Inc”와 같은 문자열을 저장할 수 있다.</li>
  <li>10px와 같은 사이즈를 저장할 수 있다.
<img src="http://uploads.brianflove.com/wp-content/uploads/2012/10/string-variables-in-less.png" alt="" /></li>
</ul>

<h3 id="mixins">Mixins</h3>

<ul>
  <li>여러 곳에 쓰일 수 있는 룰셋의 속성들을 가지고 있다.</li>
  <li>코드 재사용</li>
  <li>패러미터를 줄 수 있으나, 필수는 아니다.</li>
  <li>패러미터의 기본값을 줄 수 있다.</li>
  <li>@argument는 모든 패러미터에 저장된 순서대로의 값을 포함하는 특별한 변수다.
<img src="http://uploads.brianflove.com/wp-content/uploads/2012/10/mixins-in-less.png" alt="" /></li>
</ul>

<h3 id="cascading--nesting">Cascading + Nesting</h3>

<ul>
  <li>cascading(들여쓰기)으로 룰셋을 nest한다.</li>
  <li>기존의 cascading 접근 방식과 함께 사용할 수 있다.</li>
  <li>DOM 구조와 유사하게 할 수 있다.</li>
  <li>cascading된 룰셋으로 <em>컴파일할 수 있다.</em>
![](http://uploads.brianflove.com/wp-content/uploads/2012/10/nested-styles-in-less.png “”)</li>
</ul>

<h3 id="combinator">&amp;연결자(combinator)</h3>

<ul>
  <li>&amp;연결자가 쓰이면 nesting된 실렉터는 부모 실렉터와 연쇄적으로 해석한다.</li>
  <li>:focus나 :hover와 같은 의사 클래스에 매우 유용하다.
<img src="http://uploads.brianflove.com/wp-content/uploads/2012/10/combinator-in-less.png" alt="&amp;연결자" title="&amp;연결자" /></li>
</ul>

<p>그림은 @.inline으로 설명은 &amp;.inline으로 <em>일치하지 않음</em></p>

<h3 id="operations">연산자(Operations)</h3>

<ul>
  <li>모든 사이즈와 컬러 변수에서 작동한다.</li>
  <li>+,-,*,/</li>
  <li>컬러 함수</li>
  <li>수학 함수</li>
</ul>

<p><img src="http://uploads.brianflove.com/wp-content/uploads/2012/10/math-operators-in-less.png" alt="" /></p>

<ul>
  <li>padding: @padding * 10% // outputs “padding: 20px;”</li>
  <li>padding: ((@padding * 10%) / 2) + 5px; //outputs “padding: 15px;”</li>
  <li>adding: @padding + (2 * @padding); //outputs “padding:6px;”</li>
</ul>

<p>LESS에는 여러 수학 함수가 있다.</p>

<ul>
  <li>round()</li>
  <li>ceiling()</li>
  <li>floot()</li>
  <li>percentage()</li>
</ul>

<h3 id="section-1">컬러 함수</h3>

<p>여러 함수를 적용하여 새로운 컬러를 만들거나 기존 컬러에 대한 정보를 얻을 수 있다.</p>

<ul>
  <li>darken(@color, 20%); //20% 어둡게 한다.</li>
  <li>lighten(@color, 20%); //20% 밝게 한다.</li>
  <li>fadein(@color, 20%); //20% 더 투명하게 한다.</li>
  <li>fadeout(@color, 20%); //20% 덜 투명하게 한다.</li>
  <li>fade(@color, 80%); //80%투명도를 가진다.</li>
  <li>hue(@color); //색상 채널</li>
  <li>saturation(@color); //채도(chroma) 채널</li>
  <li>lightness(@color); //명도(value) 채널</li>
  <li>alpha(@color); //알파(투과도) 채널</li>
</ul>

<p>참조 : <a href="http://ko.wikipedia.org/wiki/%EC%83%89_%EA%B3%B5%EA%B0%84" title="위키피디어 - 색 공간">색 공간</a>, <a href="http://ko.wikipedia.org/wiki/%EC%83%89_%EB%AA%A9%EB%A1%9D" title="위키피디어 - 색 목록">색 목록</a></p>

<p><img src="http://uploads.brianflove.com/wp-content/uploads/2012/10/color-functions-in-less.png" alt="" /></p>

<h3 id="comments">주석(Comments)</h3>

<p>여러 줄의 주석은 컴파일된 CSS에 유지되지만 한줄 주석은 유지되지 않는다. 그러므로 컴파일된 CSS에 포함되기를 원하지 않는 경우에는 한줄 주석을 일반적으로 이용해야 한다.</p>

<ul>
  <li><code>/*</code> 이 주석은 컴파일된 CSS에 유지된다. */</li>
  <li>//이 주석은 컴파일된 CSS에서 빠진다.</li>
</ul>

<h3 id="import">@Import</h3>

<p>CSS에서 @import()으 사용은 의심할 필요도 없이 아주 나쁜 생각이다. import된 각 화일 마다 서버에 추가적인 HTTP 요청을 하기 때문이다. CSS를 5개의 화일로 나누면 5번 요청한다. 사이트의 성능때문에 클라이언트에서 요청하는 CSS 화일은 하나로 해야한다. </p>

<p>또한, 인라인 스타일의 사용은 널리 알려진대로 최고로 피해야할 규칙이다. 클라이언트에서 요청된 CSS 화일은 브라우저에 의해 캐싱되므로 서브 페이지 방문에서는 다운로드되지 않는다. HTML은 일반적으로 캐쉬되지 않으므로 인라인 CSS 코드는 매번 포함되어 다운로드된다.</p>

<p>LESS에서는?</p>

<ul>
  <li>@import하면 하나의 화일로 모두 복사되어 컴파일된다.</li>
  <li>모든 변수와 mixin 선언된 이후 <em>are available to main file or files imported after declarations</em></li>
  <li><em>Order matters</em></li>
  <li>.less 확장자는 포함하거나 생략할 수 있다.</li>
  <li>.css 확장자를 사용하여 CSS화일을 import할 수 있다.</li>
</ul>

<p>다음과 같이 필요한 모든 CSS화일을 하나의 .less 화일에 포함하는 것을 추천한다.</p>

<pre><code>// import normalize for CSS resets
@import "normalize";  // same as @import “normalize.less”;
 
// import mixins for all of my "global" variables and mixins
@import "mixins";
 
// base for mobile devices
@import "base";
 
//tablets
@media only screen and (min-width: 768px) {
@import "768";
}
 
//desktops
@media only screen and (min-width: 1030px) {
@import "1030";
}
</code></pre>

<h3 id="section-2">문자열 삽입</h3>

<ul>
  <li>@{name} 구성을 사용</li>
  <li>선언시 변수값을 임베딩</li>
</ul>

<p><img src="http://uploads.brianflove.com/wp-content/uploads/2012/10/string-interpolation-in-less.png" alt="" /></p>

<h3 id="escaping">Escaping</h3>

<ul>
  <li>유효한 CSS 문법이 아닌 CSS 출력이 필요하면</li>
  <li>Proprietary syntax not recognized by LESS</li>
  <li>If not used, LESS compiler will throw an error</li>
  <li>
    <p>Simple prefix with ~ symbol and put in quotes (string)</p>

    <p>filter: ~”progid:DXImageTransform.Microsoft.gradient(startColorstr=’#dfdfdf’, endColorstr=’#f8f8f8’)”;</p>
  </li>
</ul>

<p>&#8220;”앞에 ~를 붙이면 LESS 컴파일러가 코드 문자열을 무시한다.</p>

<h3 id="pre-compile">Pre-compile</h3>

<ul>
  <li>LESS를 CSS3로 컴파일하면 웹앱에서는 하나의 CSS화일만 로드된다.</li>
  <li>포로덕션에만 사용되어져야 한다.</li>
  <li>개발할 때는 덜 편리하다.</li>
  <li>
    <p>LESS 컴파일러가 디렉토리를 “watch”하게 하면 디렉토리에 저장될 때마다 재컴파일하게 할 수 있다.</p>

    <p>$ lessc style.less &gt; ../css/style.css</p>
  </li>
</ul>

<h3 id="post-compile">Post-compile</h3>

<ul>
  <li>less.js 사용할 수 있으며, HTML에 less 화일을 포함해라.</li>
  <li>프로덕션에는 사용하지 말아야 한다.</li>
  <li>
    <p>개발할 때 가장 편리하다.</p>

    <p><!--LESS stylesheets first--></p>

    <p><!---Post-compile LESS to CSS3--->
  <script type="text/javascript" src="less.js"></script><script type="text/javascript">// &lt;![CDATA[
  less.watch();
  // ]]&gt;</script></p>
  </li>
</ul>

<h3 id="less-elements">LESS Elements</h3>

<p>LESS 화일은 크로스 브라우저되는 몇몇 유용한 mixin을 포함한다.</p>

<ul>
  <li>.gradient</li>
  <li>.rounded</li>
  <li>.opacity</li>
  <li>.box-shadow</li>
  <li>.inner-shadow</li>
</ul>

<h3 id="minification-and-compression">Minification and compression</h3>

<p>프로덕션 사용으로는 CSS 코드를 minimize하고 compress하는 것이 가장 좋다. 코드를 가볍게 만들어 웹 사이트를 더 빠르게 할 것이다. LESS 컴파일러 -x 옵션을 사용하여 minify할 수 있다. -yui-compress 플래그를 사용하여 YUI CSS 컴프레서를 사용하여 컴파일할 수 있다.</p>

<pre><code>$ lessc -x styles.less &gt; ../css/styles.css
$ lessc -x --yui-compress styles.less &gt; ../css/styles.css
</code></pre>

<h3 id="less--2">LESS 대안</h3>

<ul>
  <li><a href="http://sass-lang.com/">SASS: Syntactically Awesome StyleSheets</a></li>
  <li>SCSS: v2 of SASS</li>
  <li><a href="http://learnboost.github.com/stylus/">Stylus</a></li>
</ul>

<h3 id="presentation">Presentation(영문)</h3>

<ul>
  <li><a href="https://s3.amazonaws.com/uploads.brianflove.com/wp-content/uploads/2013/01/less.pdf">영문 Less.pdf</a></li>
</ul>

<h3 id="section-3">추가 자료</h3>

<ul>
  <li><a href="http://lesscss.org/">LESS 공식 홈페이지</a></li>
  <li><a href="http://opentutorials.org/course/253/1748">개발자 영어 한글 번역 및 강좌</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML & CSS 중급자 가이드 - 6강 : jQuery]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/advanced-guide-to-html-and-css-6-slash-10/"/>
    <updated>2013-07-22T21:20:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/advanced-guide-to-html-and-css-6-slash-10</id>
    <content type="html"><![CDATA[<p>원본 : <a href="http://learn.shayhowe.com/advanced-html-css/jquery">An Advanced Guide to HTML &amp; CSS - LESSON 6 : jQuery</a></p>

<p>웹 디자이너나 프론트 엔드 개발자가 되려면 일반적으로 어느 정도는 (종종 JS라고 불리우는) 자바스크립트와 jQuery에 부딪칠 것이다. 상위 10,000 웹사이트에서 자바스크립트는 <a href="http://trends.builtwith.com/docinfo/Javascript">92%가 넘게</a> 사용되고, jQuery는 <a href="http://trends.builtwith.com/javascript/jQuery">63%를 넘게</a> 사용되고 있다. 말할 필요도 없이 매우 인기가 있다. 미래의 어떤 시기에 자신의 행동을 구축하기위해 자바스크립트나 jQuery를 <a href="http://jsforcats.com/">코딩하길</a> 열망할 수도 있다.</p>

<p>자바스크립트와 jQuery가 정확히 무엇인지 묻고 있다면, 두려워말라. 이 단원에서 자바스크립트의 간략한 개요를 보여줄 것이고 jQuery도 살펴볼 것이다.</p>

<h2 id="javascript-intro">JavaScript Intro</h2>

<p><a href="https://developer.mozilla.org/en-US/docs/JavaScript/A_re-introduction_to_JavaScript">자바스크립트</a>는 웹사이트에 상호작용성을 추가할 수 있게 해주고 유저 경험을 풍부하게 하는 것을 돕는다. HTML은 페이지에 <strong>구조</strong>를 제공하고 CSS는 <strong>외모</strong>를 제공하고 자바스크립트는 <strong>행동</strong>을 제공한다.
<!-- more -->
CSS처럼, 자바스크립트는 <code>.js</code> 화일 확장자로 외부 화일에 저장해야하며, <code>script</code> 엘리먼트를 사용하여 HTML 문서 안에서 참조(reference)된다. HTML 안의 자바스크립트 참조가 어디에 있느냐는 그것이 언제 실행되야하는가에 따라 다르다. 일반적으로 말하면 자바스크립트 화일이 연급되는 가장 좋은 위치는 - 모든 HTML이 파싱되고난 후에 자바스크립트가 로드되도록 - <code>&lt;/body&gt;</code>태그가 끝나기 바로 전이다. 그러나, 때론 HTML을 렌더링하거나 그것의 행동을 결정하는 것을 도와야하기 때문에 문서의 <code>head</code> 안에서 참조될 수 있다.</p>

<pre><code>&lt;script src="script.js"&gt;&lt;/script&gt;
</code></pre>

<h3 id="values--variables">Values &amp; Variables</h3>

<p>값(value)과 변수(variable)는 자바스크립트 기초의 일부다. 일반적으로  값은 자바스크립트가 인식할 다양한 종류의 값이고, 변수는 이 값들을 저장하고 공유하기 위해 사용된다.</p>

<p>값은 문자열, 참/거짓 불린(Boolean), 숫자, <code>undefined</code>, <code>null</code>, 혹은 함수와 객체 같은 값들도 포함할 수 있다.</p>

<p>변수가 정의되는 인기있는 방법 중 하나는 <code>var</code> 키워드와 뒤따르는 변수명, 등호 기호 (<code>=</code>), 그리고 값과 세미콜론 (<code>;</code>)으로 마친다. 변수 이름은 문자, 밑줄 (<code>_</code>)이나 달러 기호 (<code>$</code>)로 시작되어야 한다. 변수는 숫자로 시작될 수 없으나 시작 이후에는 사용될 수 있다. 어떤 경우에도 하이픈은 사용할 수 없다. 더불어 자바스크립트는 대소문자를 구분하기 때문에 문자는 <code>a</code>에서 <code>z</code>까지의 대/소문자 모두가 포함된다.</p>

<p>역자 참조 : MDN <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Values,_variables,_and_literals#Variables">Values, variables, and literals</a></p>

<p>변수를 명하는 일반적인 규칙은 대쉬나 밑줄을 젼혀 사용하지 않고 캐멀케이스(<a href="http://en.wikipedia.org/wiki/CamelCase">camelCase</a>)를 사용하는 것이다. 캐멀케이스는 빈칸을 없애고 첫 단어를 제외한 각 단어를 대문자로 시작하여 단어들을 조합한다. 예를 들면 <code>shay_is_awesome</code>은 <code>shayIsAwesome</code>으로 이름짓는 것이 더 일반적이다.</p>

<pre><code>var theStarterLeague = 125;
var food_truck = 'Coffee';
var mixtape01 = true;
var vinyl = ['Miles Davis', 'Frank Sinatra', 'Ray Charles'];
</code></pre>

<h3 id="statements">Statements</h3>

<p>전반적으로 자바스크립트는 쓰여진 순서대로 브라우저에 의해 실행되는 문장(statement)의 집합이다. 이 문장들은 수행될 댜양한 행동들을 결정하는 명령을 제공한다. 문장들은 다양한 형태와 크기가 되고, 여러 문장은 세미콜론 <code>;</code>으로 나뉜다. 새로운 문장은 새로운 줄에서 시작되어야하며 들여쓰기는 문장들을 더 읽기쉽게 하기위해 사용해야하지만, 반드시 요구되는 것은 아니다.</p>

<pre><code>log(polaroid);
return('bicycle lane');
alert('Congratulations, you ' + outcome);
</code></pre>

<h3 id="functions">Functions</h3>

<p>자바스크립트 기초에 더해, 함수(function)을 살펴보는 것은 중요하다. 함수는 지금, 또는 나중을 위해 저장된, 다른 인수(argument)를 받아들이기도 하는 함수에 의존하는, 기술된 일련의 행동을 수행하는 방법을 제공한다.</p>

<p>함수는 <code>function</code> 키워드와 뒤따르는 함수명, 필요할 경우, 쉼표로 분리된 인수 목록(전체가 소괄호로 감싸진다)과 함수를 정의하는 자바스크립트 문장 또는 문장들(전체가 중괄호 <code>{}</code>로 둘러싸여진다)을 사용해 정의된다.</p>

<pre><code>function sayHello(name) {
  return('Hello ' + name);
}
</code></pre>

<h3 id="arrays">Arrays</h3>

<p>인정하듯이 몇몇 값은 배열로 반환될 수 있다. 배열은 항목이나 값의 목록을 저장하는 방법을 포함한다. 여러 가지 이유로 배열은 다양한 매서드와 연산자로 팀색할 수 있어 도움이 된다. 게다가 상황에 따라 배열은 다양한 값을 저장하고 반환하는 데 사용될 수 있다.</p>

<p>일반적으로 말하면 배열은 대괄호 <code>[]</code>와 쉼표로 분리된 항목들로 식별된다. 항목은 <code>0</code>에서 시작되어 증가한다. 한 목록에서 세번째 아이템을 식별할 때는 실제 <code>[2]</code>로서 식별된다.</p>

<h3 id="objects">Objects</h3>

<p>자바스크립트는 키/값의 한 쌍인 객체의 기초 위에 만들어진 것이기도 하다. 예를 들어 <code>school</code>로 이름지어진 객체가 있고, 이 객체가 <code>name</code>, <code>location</code>, <code>students</code>, <code>teachers</code> 키들(프로퍼티/속성으로도 알려짐)과 그들의 값을 포함하고 있다고 하자.</p>

<p>아래 예제에서 변수 <code>school</code>은 여러 속성을 보유하는 객체로 설정된다. 각 속성은 하나의 키와 값을 가진다. 전체 객체는 중괄호 <code>{}</code>로 감싸졌고, 속성은 쉽표로 분리되며, 각 속성은 콜론과 값이 뒤따르는 하나의 키를 갖는다.</p>

<p>OBJECTS</p>

<pre><code>var school = {
  name: 'The Starter League',
  location: 'Merchandise Mart',
  students: 120,
  teachers: ['Jeff', 'Raghu', 'Carolyn', 'Shay']
};
</code></pre>

<p>ARRAY</p>

<pre><code>var school = ["Austin", "Chicago", "Portland"];
</code></pre>

<p><img src="http://learn.shayhowe.com/assets/courses/advanced-html-css-guide/jquery/console.png" alt="Web Inspector Console" /></p>

<p><strong>Fig. 6.01</strong></p>

<p>크롬 웹브라우저 안에 내장된 개발자 도구를 사용하면 자바스크립트를 콘솔 안에서 실행시킬 수 있다.</p>

<h2 id="jquery-intro">jQuery Intro</h2>

<p>자바스크립트와 그 기초의 일부에 대한 기본적인 이해와 함께 jQuery를 살펴볼 차례다. jQuery는 HTML, CSS와 자바스크립트 간의 상호 작용을 단순화시키기 위해 존 레식이 작성한 오픈소스 자바스크립트 라이브러리다. jQuery가 출시된 2006년 이후 급성장하였고 크고 작은 웹사이트와 기업에서 사용되고 있다.</p>

<p>jQuery를 그렇게 인기있게 만든 것은 CSS를 닯은 실렉션과 동작의 알기쉬운 분리와 같은 <a href="https://tutsplus.com/course/30-days-to-learn-jquery/">손쉬운 사용</a>이었다. jQuery의 이점은 막대하지만 우리 목적은 엘리먼트를 찾고 그것들과 작업을 수행하는 능력에 대해서만 고려해볼 것이다.</p>

<h3 id="getting-started-with-jquery">Getting Started with jQuery</h3>

<p>jQuery 사용의 첫걸음은 HTML 문서 안에 그것을 참조하는 것이다. 자바스크립트에서 이전에 말했듯이 <code>&lt;/body&gt;</code> 태그의 바로 앞에 <code>script</code> 엘리먼트를 사용함으로 행해진다. jQuery는 자신이 라이브러리이기 때문에 다른 자바스트립트가 쓰여진 것과는 전부 분리시키는 것이 가장 좋다.</p>

<p>jQuery를 참조하는 것은 몇 가지 옵션이 있다. 특히, 축소되거나 압축되지 않은 버전을 사용할지 여부, 그리고 <a href="https://developers.google.com/speed/libraries/devguide">구글 호스팅 라이브러리</a>와 같은 컨텐츠 전송 네트워크(CDN)을 사용할지 여부와 같은 옵션이 있다. 라이브 프로덕션 환경에서 코드가 쓰여지는 경우에는 더 나은 로딩 시간을 위해 축소된 버전을 사용하는 것이 권장된다. 게다가 구글과 같은 CDN은 로딩 시간과 잠재적인 캐싱 이득에 도움이 된다.</p>

<pre><code>&lt;script src="http://nolboo.github.io//ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"&gt;&lt;/script&gt;
&lt;script src="script.js"&gt;&lt;/script&gt;    
</code></pre>

<p>위의 코드 예제에서 두번째 <code>script</code> 엘리먼트는 또 하나의 자바스크립트 화일을 참조하고 있는 것을 주목하라. 모든 커스텀, 직접 쓴 자바스크립트과 JQuery는 이 화일에서 쓰여져야한다. 더불어 이 화일은 이미 정의된 JQuery 함수를 참조할 수 있도록 jQuery 화일 뒤에 명확하게 위치하여야 한다.</p>

<blockquote>
  <h4 id="where-is-the-leading-http">Where is the leading http?</h4>

  <p>위 예제에서 구글 CDN 참조 안에 선행하는(leading) <code>http</code>가 없는 것을 발견할 수 있다. <code>http</code>와 <code>https</code> 연결을 모두 허용하기위해, <code>http</code>를 의도적으로 생략한 것이다. 웹 서버의 이점없이 로컬에서 동작할 때는 시스템의 로컬 디스크 드라이브의 화일을 찾는 것을 방지하려면 선행하는 <code>http</code>가 필요할 것이다.</p>
</blockquote>

<h3 id="jquery-object">jQuery Object</h3>

<p>jQuery는 자신의 객체 - 달러 기호 <code>$</code>, <code>jQuery</code>라고도 알려진 - 와 함께 제공된다. <code>$</code> 객체는 엘리먼트를 선택하고 작업을 수행하려하는 엘리먼트 노드를 반환하기위해 특별히 만들어졌다. 이 선택과 행동은 실제 jQuery 라이브러리의 바깥에서 참조되는 새로운 화일에 작성되어야 한다.</p>

<pre><code>$();
jQuery();
</code></pre>

<h3 id="document-ready">Document Ready</h3>

<p>페이지를 탐색하고 조작하기위해 jQuery를 시동하기(역자주 : trigging은 triggering의 오타인듯) 전에 DOM의 로딩이 끝날 때까지 기다리는 것이 가장 좋다. 다행히 jQuery는 <code>.ready()</code> 이벤트를 가지고 있다.
우리가 손수 쓴 jQuery 코드를 이 함수 안에 모두 배치하여 페이지가 로드되어 DOM이 준비될 때 까지 그것이 실행되지 않을 것을 보장할 수 있다.</p>

<pre><code>$(document).ready(function(event){ 
  // jQuery code 
});
</code></pre>

<h2 id="selectors">Selectors</h2>

<p>앞에서 언급하였듯이 jQuery의 핵심 개념 중 하나는 <a href="http://api.jquery.com/category/selectors/">엘리먼트를 선택</a>하는 것과 작업을 수행하는 것이다. jQuery는, CSS를 모방함으로써 극도로 쉽게, 선택 작업과 엘리먼트나 엘리먼트들의 작업을 훌륭하게 해왔다. 일반적인 CSS 실렉터에 뛰어넘어 jQuery는 사용 브라우저에 상관없이 작동하는 고유 CSS3 실렉터를 모두 지원한다.</p>

<p>jQuery 객체 <code>$()</code>를 호출할 때 실렉터를 포함하면 그것을 조작할 수 있는 DOM 노드를 반환할 것이다. 실렉터는 소괄호 <code>('...')</code> 안에 넣고 CSS의 실렉터와 똑같은 엘리먼트를 선택할 수 있다.</p>

<pre><code>$('.feature');              // Class selector
$('li strong');             // Descendant selector
$('em, i');                 // Multiple selector
$('a[target="_blank"]');    // Attribute selector
$('p:nth-child(2)');        // Pseudo-class selector
</code></pre>

<h3 id="this-selection-keyword">This Selection Keyword</h3>

<p>jQuery 함수 안에서 작업할 때 원래의 실렉터 안에서 참조되었던 엘리먼트를 선택하고 싶을 것이다. 이 경우에는 <code>this</code> 키워드가 현재 핸들러에서 선택된 엘리먼트를 참조하는 데 사용될 수 있다.</p>

<pre><code>$('div').click(function(event){ 
  $(this);
});
</code></pre>

<blockquote>
  <h4 id="jquery-selection-filters">jQuery Selection Filters</h4>

  <p>CSS 실렉터가 충분치 못하다면 JQuery에 내장된 커스텀 <a href="http://api.jquery.com/category/selectors/jquery-selector-extensions/">필터들</a>이 도움이 될 것이다. 이 필터들은 CSS의 확장이고 엘리먼트나 관련자를 선택할 때 더 많은 제어할 수 있다.</p>

  <pre><code>  $('div:has(strong)');
</code></pre>

  <p>있는 그대로 이 필터들은 실렉터 안에서 사용될 수 있지만, DOM에 순수하지(native) 않기 때문에 약간 느려진다. 필터를 사용할 때 최고의 결과는 jQuery 탐색 기능 중 <code>:filter()</code> 매서드를 이용하여 얻어진다.</p>
</blockquote>

<h2 id="traversing">Traversing</h2>

<p>종종 일반적인 CSS 실렉터만으로는 잘라내듯 선택되지 않아 좀 더 세세한 제어가 요구된다. 다행히 jQuery는 DOM 트리를 위아래로 탐색(traverse)하여 필요한 대로 엘리먼트를 걸러내고 선택하는 몇 가지 매서드를 제공한다.</p>

<p>DOM 내부의 엘리먼트를 걸러내기 시작하려면 상대적으로 탐색하는 것이 필요하다. 아래 예에서 애초의 선택은 DOM의 모든 <code>div</code> 엘리먼트를 찾고 난 후, <code>.not()</code> 매서드를 사용하여 필터링한다. 이 구체적인 매서드로 <code>type</code>나 <code>collection</code> 클래스를 갖지 않는 <code>div</code> 엘리먼트가 선택될 것이다.</p>

<pre><code>$('div').not('.type, .collection');
</code></pre>

<h3 id="chaining-methods">Chaining Methods</h3>

<p>선택된 엘리먼트를 훨씬 더 많이 제어하기 위해, 다양한 탐색 매서드들을 단순히 점을 사용하여 서로 연결할 수 있다.</p>

<p>아래 코드 예제는  <code>.not()</code> 매서드와 <code>.parent()</code>를 모두 사용한다. 함께 결합해서 <code>type</code> 혹은 <code>collection</code> 클래스를 갖지않는 <code>div</code> 엘리먼트의 부모 엘리먼트만을 선택할 것이다.</p>

<pre><code>$('div').not('.type, .collection').parent();
</code></pre>

<h3 id="traversing-methods">Traversing Methods</h3>

<p>JQuery는 상당수의 <a href="http://api.jquery.com/category/traversing/">탐색</a> 매서드를 사용할 수 있다. 그것들은 일반적으로 필터링(filtering), 기타 탐색(miscellaneous traversing), DOM 트리 탐색(DOM tree traversing)의 세가지 범주에 속한다. 각 범주의 구체적인 메서드는 아래와 같다.</p>

<h4 id="filtering">Filtering</h4>

<ul>
  <li><code>.eq()</code></li>
  <li><code>.filter()</code></li>
  <li><code>.first()</code></li>
  <li><code>.has()</code></li>
  <li><code>.is()</code></li>
  <li><code>.last()</code></li>
  <li><code>.map()</code></li>
  <li><code>.not()</code></li>
  <li><code>.slice()</code></li>
</ul>

<h4 id="miscellaneous-traversing">Miscellaneous Traversing</h4>

<ul>
  <li><code>.add()</code></li>
  <li><code>.andSelf()</code></li>
  <li><code>.contents()</code></li>
  <li><code>.end()</code></li>
</ul>

<h4 id="dom-tree-traversal">DOM Tree Traversal</h4>

<ul>
  <li><code>.children()</code></li>
  <li><code>.closest()</code></li>
  <li><code>.find()</code></li>
  <li><code>.next()</code></li>
  <li><code>.nextAll()</code></li>
  <li><code>.nextUntil()</code></li>
  <li><code>.offsetParent()</code></li>
  <li><code>.parent()</code></li>
  <li><code>.parents()</code></li>
  <li><code>.parentsUntil()</code></li>
  <li><code>.prev()</code></li>
  <li><code>.prevAll()</code></li>
  <li><code>.prevUntil()</code></li>
  <li><code>.siblings()</code></li>
</ul>

<h2 id="manipulation">Manipulation</h2>

<p>DOM에서 엘리먼트를 선택하고 탐색하는 것은 jQuery가 제공하는 것의 부분일 뿐이고, 또 다른 주요 부분은 일단 찾아낸 엘리먼트와 뭘 할 수있는 것인가이다. 가능한 것 중 하나는 이 엘리먼트들을 읽거나 추가하고, 속성이나 스타일을 변경하여 <a href="http://api.jquery.com/category/manipulation">조작</a>하는 것이다. 추가적으로 엘리먼트는 DOM 안에서 변경되고, 위치를 바꾸고, 제거하고, 새 엘리먼트를 추가하는 것 등을 할 수 있다. 전반적으로 엘리먼트를 조작하는 옵션은 매우 광대하다.</p>

<h3 id="getting--setting">Getting &amp; Setting</h3>

<p>주목해야힐 조작 매서드는 정보를 얻거나(<em>getting</em>) 혹은 설정하는(<em>setting</em>) 두 개의 지시자 중 하나로 사용된다는 것이 매우 일반적이다. 정보를 얻는다는 것은 가져올 정보 조각이 무엇인지를 결정하기 위해 매서드와 함께 실렉터를 사용하게 되는 것이다. 더불어 똑같은 실렉터와 매서드를 정보 조각을 설정하는 데에도 사용할 수 있다.</p>

<pre><code>// Gets the value of the alt attribute
$('img').attr('alt');

// Sets the value of the alt attribute
$('img').attr('alt', 'Wild kangaroo');
</code></pre>

<p>뒤따르는 예제와 스니핏에서, 매서드는 주로 설정 모드에서 사용되지만, getting 모드에서도 사용될 수 있다.</p>

<h3 id="attribute-manipulation">Attribute Manipulation</h3>

<p>검사되고 조작될 수 있는 엘리먼트의 한 부분은 속성이다. 몇 가지 선택사항은 속성이나 값을 추가, 제거, 변경할 수 있는 것이다. 아래 예제에서 <code>.addClass()</code> 매서드는 모든 짝수번 째의 <code>li</code> 항목에 클래스를 추가한다. <code>.removeClass()</code> 매서드는 모든 단락에서 클래스를 모두 제거하고 마지막으로 <code>.attr()</code> 매서드는 <code>abbr</code> 엘리먼트의 <code>title</code> 속성을 찾아서 그것을 <code>Hello World</code>로 설정한다.</p>

<pre><code>$('li:even').addClass('even-item');
$('p').removeClass();
$('abbr').attr('title', 'Hello World');
</code></pre>

<h4 id="attribute-manipulation-methods">Attribute Manipulation Methods</h4>

<ul>
  <li><code>.addClass()</code></li>
  <li><code>.attr()</code></li>
  <li><code>.hasClass()</code></li>
  <li><code>.prop()</code></li>
  <li><code>.removeAttr()</code></li>
  <li><code>.removeClass()</code></li>
  <li><code>.removeProp()</code></li>
  <li><code>.toggleClass()</code></li>
  <li><code>.val()</code></li>
</ul>

<h3 id="style-manipulation">Style Manipulation</h3>

<p>속성을 조작하는 것에 더해, 엘리먼트의 스타일도 다양한 매서드로 조작될 수 있다. 엘리먼트의 높이, 너비, 위치를 읽거나 설정할 때 몇몇 특정 매서드를 사용할 수 있고, <code>.css()</code> 매서드를 사용하면 어떤 CSS 스타일 변경도 다룰 수 있다.</p>

<p>특별히 <code>.css()</code> 매서드는 하나 또는 여러 개의 속성을 설정하거나, 각 변화에 대한 문법을 설정할 수 있다. 하나의 속성을 설정하려면 속성 이름과 값은 각각 따옴표와 쉼표로 분리되어야 한다. 여러 속성을 설정하려면 속성은 중괄호 안에 포함되어야 한다. 속성명은 캐멀케이스되어야 하고, 필요한 경우 하이픈은 제거된다. 그 뒤에 콜론과 인용부호로 감싼 값이 따른다. 속성과 값으로 짝지워진 각 쌍은 쉼표로 분리된다.</p>

<p>높이, 너비, 위치 매서드는 모두 픽셀값을 기본으로 하나, 다른 측정 단위도 사용될 수 있다. 아래에서 보여지듯이, 측정 단위를 변경하면 값 다음에 더하기 부호와 뒤따르는 인용부호된 측정단위를 사용하여 식별한다.</p>

<pre><code>$('h1 span').css('font-size', 'normal');
$('div').css({
  fontSize: '13px', 
  background: '#f60'
});
$('header').height(200);
$('.extend').height(30 + 'em');
</code></pre>

<h4 id="style-manipulation-methods">Style Manipulation Methods</h4>

<ul>
  <li><code>.css()</code></li>
  <li><code>.height()</code></li>
  <li><code>.innerHeight()</code></li>
  <li><code>.innerWidth()</code></li>
  <li><code>.offset()</code></li>
  <li><code>.outerHeight()</code></li>
  <li><code>.outerWidth()</code></li>
  <li><code>.position()</code></li>
  <li><code>.scrollLeft()</code></li>
  <li><code>.scrollTop()</code></li>
  <li><code>.width()</code></li>
</ul>

<h3 id="dom-manipulation">DOM Manipulation</h3>

<p>마지막으로, 엘리먼트의 위치를 변경하거나 추가하고 제거하고, 노골적으로 엘리먼트를 변경하여 DOM을 검사하고 조작할 수 있다. 여기서의 선택사항은 DOM 안에서 어떤 잠재적인 변화도 허용할 정도로 깊고 다양하다.</p>

<p>각 개개의 DOM 조작 매서드는 자신의 문법을 가지고 있지만, 아래 예에서 그 중 일부를 대강 설명해본다. <code>.prepend()</code> 매서드는 모든 <code>section</code>에 <code>h3</code> 엘리먼트를 새로 추가하고, <code>.after()</code> 매서드는 링크 바로 뒤에 <code>em</code> 엘리먼트를 새로 추가하며, <code>.text()</code> 매서드는 모든 <code>h1</code> 엘리먼트의 문자를 <code>Hello World</code>로 바꾼다.</p>

<pre><code>$('section').prepend('&lt;h3&gt;Featured&lt;/h3&gt;');
$('a[target="_blank"]').after('&lt;em&gt;New window.&lt;/em&gt;');
$('h1').text('Hello World');
</code></pre>

<h4 id="dom-manipulation-methods">DOM Manipulation Methods</h4>

<ul>
  <li><code>.after()</code></li>
  <li><code>.append()</code></li>
  <li><code>.appendTo()</code></li>
  <li><code>.before()</code></li>
  <li><code>.clone()</code></li>
  <li><code>.detach()</code></li>
  <li><code>.empty()</code></li>
  <li><code>.html()</code></li>
  <li><code>.insertAfter()</code></li>
  <li><code>.insertBefore()</code></li>
  <li><code>.prepend()</code></li>
  <li><code>.prependTo()</code></li>
  <li><code>.remove()</code></li>
  <li><code>.replaceAll()</code></li>
  <li><code>.replaceWith()</code></li>
  <li><code>.text()</code></li>
  <li><code>.unwrap()</code></li>
  <li><code>.wrap()</code></li>
  <li><code>.wrapAll()</code></li>
  <li><code>.wrapInner()</code></li>
</ul>

<h2 id="events">Events</h2>

<p>jQuery의 아름다움 중 하나는 벌어지는 특정 이벤트나 액션에서만 호출되는 매서드인 <a href="http://api.jquery.com/category/events/">이벤트 핸들러</a>를 쉽게 추가하는 수 있는 것이다. 예를 들어, 엘리먼트에 클래스를 추가하는 매서드를 클릭된 엘리먼트에서 발생되도록 설정될 수 있다.</p>

<p>아래에서 모든 <code>li</code> 항목을 잡아채는 표준 실렉터가 있다. <code>.click()</code> 이벤트 매서드는 <code>li</code> 아이템 실렉터에 구속되어 있으며(binding), <code>li</code> 아이템을 클릭할 때 발생되는 액션을 설정한다. <code>.click()</code> 이벤트 매서드 안에 실행될 액션을 보장하는 함수가 있다. 함수 바로 다음의 소괄호는 함수를 위한 패러미터(속성)를 전달할 수있으며, 이 예제에서는 <code>event</code> 객체가 사용되었다.</p>

<p>함수 안에 <code>.addClass()</code> 매서드가 구속된 또하나의 실렉터가 있다. 이제 <code>li</code> 항목이 클릭되면 <code>this</code> 키워드를 통해 <code>li</code> 항목은 <code>saved-item</code> 클래스를 받을 수 있다.</p>

<pre><code>$('li').click(function(event){
  $(this).addClass('saved-item');
});
</code></pre>

<h3 id="event-flexibility">Event Flexibility</h3>

<p><code>.click()</code> 이벤트 매서드는, 소수의 다른 이벤트 매서드와 함께, jQuery 1.7부터 도입된 <code>.on()</code> 매서드를 사용하는 숏핸드 매서드이다. <code>.on()</code> 매서드는, 페이지에 동적으로 추가되는 엘리먼트를 위한 자동 위임을 사용하여, 상당한 유연성을 제공한다. </p>

<p><code>.on()</code> 매서드를 이용하여 첫번째 인수는 네이티브 이벤트 이름이어야 하는 반면 두번째 인수는 이벤트 핸들러 함수이어야 한다. 이전의 예제를 살펴보면 <code>.on()</code> 매서드가 <code>.click()</code> 매서드의 자리에서 호출되고 있다. 이제 <code>click</code> 이벤트 이름은 전과 똑같이 자리잡은 이벤트 핸들러 함수와 함께 <code>.on()</code> 매서드 안에서 첫번째 인수로서 전달된다.</p>

<pre><code>$('li').on('click', function(event){
  $(this).addClass('saved-item');
});
</code></pre>

<h3 id="nesting-events">Nesting Events</h3>

<p>또 다른 하나 안에 하나를 품게함으로써 여러 개의 이벤트 핸들러와 트리거를 가질 수 있다. 예재로 <code>.on()</code> 이벤트 매서드 밑으로 <code>hover</code>  인수를 전달하여 <code>pagination</code> 클래스를 가진 엘리먼트 위를 호버할 때 호출될 수 있다. <code>.on()</code> 이벤트를 호출하면 <code>.click()</code> 아벤트 <code>up</code> ID를 가진 앵커를 호출된다.</p>

<pre><code>$('.pagination').on('hover', function(event){
  $('a#up').click();
});
</code></pre>

<h3 id="event-demo">Event Demo</h3>

<p>데모로서 경고 메시지를 사용하여 다음 코드 스니핏은 경고 메시지를 만들고나서 닫기 아이콘을 클릭하면 메시지를 제거하는 방법을 보여준다. </p>

<blockquote>
  <h6 id="html">HTML</h6>

  <pre><code>&lt;div class="alert-warning"&gt;
  &lt;strong&gt;Warning!&lt;/strong&gt; I’m about to lose my cool.
  &lt;div class="alert-close"&gt;×&lt;/div&gt;
&lt;/div&gt;
</code></pre>

  <h6 id="javascript">JavaScript</h6>

  <pre><code>$('.alert-close').on('click', function(event){
  $('.alert-warning').remove();
});
</code></pre>

  <h4 id="demohttpjmp19lrgr1"><a href="http://j.mp/19Lrgr1">Demo</a></h4>
</blockquote>

<h3 id="event-methods">Event Methods</h3>

<p>jQuery는 브라우저와 상호작용할 때 유저 행동을 등록하는 데에 기반을 둔 모든 매서드를 아주 많이 제공한다. 이런 매서드들은 아주 인기가 많지만 브라우저, 폼, 키보드, 마우스 등의 이벤트에 제한적이지 않은 꽤 많은 이벤트를 등록한다. 가장 인기있는 매서드들은 다음과 같다:</p>

<h4 id="browser-events">Browser Events</h4>

<ul>
  <li><code>.resize()</code></li>
  <li><code>.scroll()</code></li>
</ul>

<h4 id="document-loading">Document Loading</h4>

<ul>
  <li><code>.ready()</code></li>
</ul>

<h4 id="event-handler-attachment">Event Handler Attachment</h4>

<ul>
  <li><code>.off()</code></li>
  <li><code>.on()</code></li>
  <li><code>.one()</code></li>
  <li><code>jQuery.proxy()</code></li>
  <li><code>.trigger()</code></li>
  <li><code>.triggerHandler()</code></li>
  <li><code>.unbind()</code></li>
  <li><code>.undelegate()</code></li>
</ul>

<h4 id="event-object">Event Object</h4>

<ul>
  <li><code>event.currentTarget</code></li>
  <li><code>event.preventDefault()</code></li>
  <li><code>event.stopPropagation()</code></li>
  <li><code>event.target</code></li>
  <li><code>event.type</code></li>
</ul>

<h4 id="form-events">Form Events</h4>

<ul>
  <li><code>.blur()</code></li>
  <li><code>.change()</code></li>
  <li><code>.focus()</code></li>
  <li><code>.select()</code></li>
  <li><code>.submit()</code></li>
</ul>

<h4 id="keyboard-events">Keyboard Events</h4>

<ul>
  <li><code>.focusin()</code></li>
  <li><code>.focusout()</code></li>
  <li><code>.keydown()</code></li>
  <li><code>.keypress()</code></li>
  <li><code>.keyup()</code></li>
</ul>

<h4 id="mouse-events">Mouse Events</h4>

<ul>
  <li><code>.click()</code></li>
  <li><code>.dblclick()</code></li>
  <li><code>.focusin()</code></li>
  <li><code>.focusout()</code></li>
  <li><code>.hover()</code></li>
  <li><code>.mousedown()</code></li>
  <li><code>.mouseenter()</code></li>
  <li><code>.mouseleave()</code></li>
  <li><code>.mousemove()</code></li>
  <li><code>.mouseout()</code></li>
  <li><code>.mouseover()</code></li>
  <li><code>.mouseup()</code></li>
</ul>

<h2 id="effects">Effects</h2>

<p>이벤트와 버금가게, jQuery는 소수의 커스터마이징 가능한 효과도 제공한다. 이 효과들은 다양한 매서드로 행해지며, 컨텐츠를 보여주고 숨기고, 페이드 인/아웃, 슬라이드 업/다운 등을 위한 이벤트 매서드를 포함한다. 이들 모두가 사용될 매서드가 준비되어 있으며 최적으로 보이도록 커스터마이징될 수 있다.</p>

<p>각 이펙트 매서드는 자신만의 구문을 가지고 있어서, 각 매서드의 특정 구문은 jQuery <a href="http://api.jquery.com/category/effects/">효과 문서</a>를 참조하는 것이 가장 좋다. 그렇지만, 일반적으로 효과는 지속기간(duraton), 이징(easing 역자주: 움직일 때의 애니메이션 <a href="http://gsgd.co.uk/sandbox/jquery/easing/">효과</a>), 콜백함수(역자주 : 애니메이션이 끝난 후 실행되는 함수) 지정 등을 허용한다.</p>

<blockquote>
  <h4 id="jquery-css-animations">jQuery CSS Animations</h4>

  <p>CSS 자체가 최근 애니메이션을 다루는 것과는 관계가 좀 떨어지지만, 다양한 CSS 속성의 맞춤형 애니메이션이 jQuery에서 수행될 수 있다. CSS 애니메이션은 브라우저 처리 관점에서 더 나은 성능을 제공하며, 가능한 곳에선 더 선호된다. jQuery 애니메이션 효과는 - Modernizr의 도움을 받아 - CSS 애니메이션을 지원하는 브라우저에 완벽한 백업 솔루션을 만들어준다.</p>
</blockquote>

<h3 id="effect-duration">Effect Duration</h3>

<p>예로서 <code>.show()</code> 매서드를 사용하면, (선택적으로) 대입할 수 있는 첫 패러미터는 지속시간이며, 키워드와 밀리초 값을 사용해 수행될 수 있다. <code>slow</code> 키워드는 <code>600</code> 밀리초를, <code>fast</code> 키워드는 <code>200</code> 밀리초를 기본으로 한다. 키워드 값을 사용하는 건 완벽하지만, 밀리초 값을 직접 대입할 수도 있다. 키워드 값은 인용부호로 감싸지만, 밀리초 값은 그러지 않는다.</p>

<pre><code>$('.error').show();
$('.error').show('slow');
$('.error').show(500);
</code></pre>

<h3 id="effect-easing">Effect Easing</h3>

<p>지속시간을 설정함과 더불어, 애니메이션 안에서 다양한 시간 동안 애니메이션이 처리되는 이징(easing) 혹은 속도 등도 설정될 수 있다. 기본적으로 jQuery는 두 개의 이징 키워드 값이 있다. 기본값은 <code>swing</code>이고 추가적인 값은 <code>linear</code>이다. 기본 <code>swing</code> 값은 느린 속도로 애니메이션을 시작하여 애니메이션 되는 중에 속도를 내지만, 끝나기 전에는 속도를 늦춘다. <code>linear</code> 값은 처움부터 끝까지 하나의 일정한 속도로 애니메이션이 진행된다.</p>

<pre><code>$('.error').show('slow', 'linear');
$('.error').show(500, 'linear');
</code></pre>

<blockquote>
  <h4 id="jquery-ui">jQuery UI</h4>

  <p>jQuery에서 제공되는 두 개의 이징 값은 추가적인 값을 제공할 수 있는 다양한 플러그인을 사용하여 확장될 수 있다. 가장 인기있는 플러그인 중 하나는 <a href="http://jqueryui.com/">jQuery UI</a> 이다.</p>

  <p>새 이징 값에 더해 jQuery UI는 살펴볼만한 소수의 다른 상호작용, 효과, 위젯과 도움되는 리소스를 제공한다.</p>
</blockquote>

<h3 id="effect-callback">Effect Callback</h3>

<p>애니메이션이 끝나면 콜백 함수라 불리는 또 다른 함수를 실행할 수 있다. 콜백 함수는, 존재한다면, 지속시간(duration)이나 이징(easing) 뒤에 배치해야 한다. 이 함수에서 새로운 이벤트나 효과가 배치될 수 있으며, 각각 자신의 필요한 구문을 따른다.</p>

<pre><code>$('.error').show('slow', 'linear', function(event){
  $('.error .status').text('Continue');
});
</code></pre>

<h3 id="effect-syntax">Effect Syntax</h3>

<p>전에 언급되었듯이 각 효과 매서드는 jQuery <a href="http://api.jquery.com/category/effects/">효과 문서</a>에서 찾을 수 있는 자신의 구문을 가진다. 여기서 약술한 지속시간, 이징, 콜백 매개변수는 일반적인 것이고 모든 매서드에서 쓸 수 있는 것은 아니다. 관련해서 의문 사항이 생기면 매서드의 구문을 재검토하는 것이 가장 좋다.</p>

<h3 id="effects-demo">Effects Demo</h3>

<p>위에서와 같은 이벤트 데모를 취하면, 여기서 <code>.remove()</code> 매서드는 <code>.fadeOut()</code> 매서드에서 콜백 함수의 부분으로 사용된다. <code>.fadeOut()</code> 매서드를 사용하면 경고 메시지가 재빨리 사라지기 보단 점차로 페이드 아웃되게 하며, 애니메이션이 완료된 후 DOM에서 제거된다.</p>

<blockquote>
  <h6 id="html-1">HTML</h6>

  <pre><code>&lt;div class="alert-warning"&gt;
  &lt;strong&gt;Warning!&lt;/strong&gt; I’m about to lose my cool.
  &lt;div class="alert-close"&gt;×&lt;/div&gt;
&lt;/div&gt;
</code></pre>

  <h6 id="javascript-1">JavaScript</h6>

  <pre><code>$('.alert-close').on('click', function(event){
  $('.alert-warning').fadeOut('slow', function(event){
    $(this).remove();
  });
});
</code></pre>

  <h4 id="demohttpjmpzexzyb"><a href="http://j.mp/ZExZyB">Demo</a></h4>
</blockquote>

<h4 id="basic-effects">Basic Effects</h4>

<ul>
  <li><code>.hide()</code></li>
  <li><code>.show()</code></li>
  <li><code>.toggle()</code></li>
</ul>

<h4 id="custom-effects">Custom Effects</h4>

<ul>
  <li><code>.animate()</code></li>
  <li><code>.clearQueue()</code></li>
  <li><code>.delay()</code></li>
  <li><code>.dequeue()</code></li>
  <li><code>jQuery.fx.interval</code></li>
  <li><code>jQuery.fx.off</code></li>
  <li><code>.queue()</code></li>
  <li><code>.stop()</code></li>
</ul>

<h4 id="fading-effects">Fading Effects</h4>

<ul>
  <li><code>.fadeIn()</code></li>
  <li><code>.fadeOut()</code></li>
  <li><code>.fadeTo()</code></li>
  <li><code>.fadeToggle()</code></li>
</ul>

<h4 id="sliding-effects">Sliding Effects</h4>

<ul>
  <li><code>.slideDown()</code></li>
  <li><code>.slideToggle()</code></li>
  <li><code>.slideUp()</code></li>
</ul>

<blockquote>
  <h3 id="slide-demo">Slide Demo</h3>

  <h6 id="html-2">HTML</h6>

  <pre><code>&lt;div class="panel"&gt;
  &lt;div class="panel-stage"&gt;&lt;/div&gt;
  &lt;a href="#" class="panel-tab"&gt;Open &lt;span&gt;▼&lt;/span&gt;&lt;/a&gt;
&lt;/div&gt;
</code></pre>

  <h6 id="javascript-2">JavaScript</h6>

  <pre><code>$('.panel-tab').on('click', function(event){
  event.preventDefault();
  $('.panel-stage').slideToggle('slow', function(event){
    if($(this).is(':visible')){
      $('.panel-tab').html('Close ▲');
    } else {
      $('.panel-tab').html('Open ▼');
    }
  });
});
</code></pre>

  <h4 id="demohttpjmp11cl156"><a href="http://j.mp/11Cl156">Demo</a></h4>
</blockquote>

<h3 id="tabs-demo">Tabs Demo</h3>

<blockquote>
  <h6 id="html-3">HTML</h6>

  <pre><code>&lt;ul class="tabs-nav"&gt;
  &lt;li&gt;&lt;a href="#tab-1"&gt;Features&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="#tab-2"&gt;Details&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="tabs-stage"&gt;
  &lt;div id="tab-1"&gt;...&lt;/div&gt;
  &lt;div id="tab-2"&gt;...&lt;/div&gt;
&lt;/div&gt;
</code></pre>

  <h6 id="javascript-3">JavaScript</h6>

  <pre><code>// Show the first tab by default
$('.tabs-stage div').hide();
$('.tabs-stage div:first').show();
$('.tabs-nav li:first').addClass('tab-active');
// Change tab class and display content
$('.tabs-nav a').on('click', function(event){
  event.preventDefault();
  $('.tabs-nav li').removeClass('tab-active');
  $(this).parent().addClass('tab-active');
  $('.tabs-stage div').hide();
  $($(this).attr('href')).show();
});
</code></pre>

  <h4 id="demohttpjmp1052yx1"><a href="http://j.mp/1052YX1">Demo</a></h4>
</blockquote>

<h2 id="resources-amp-links">Resources &amp; Links</h2>

<ul>
  <li><a href="http://jsforcats.com/">JavaScript For Cats</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/JavaScript/A_re-introduction_to_JavaScript">A Re-introduction to JavaScript</a> via Mozilla Developer Network</li>
  <li><a href="https://tutsplus.com/course/30-days-to-learn-jquery/">30 Days to Learn jQuery</a> via Tuts+ Premium</li>
  <li><a href="https://developers.google.com/speed/libraries/devguide">Google Hosted Libraries</a></li>
  <li><a href="http://docs.jquery.com/">jQuery Documentation</a></li>
  <li><a href="http://jqfundamentals.com/">jQuery Fundamentals</a> via Bocoup</li>
  <li><a href="http://jqueryui.com/">jQuery UI</a></li>
</ul>

<h3 id="section">역자참조링크</h3>
<ul>
  <li><a href="http://www.jquerykorea.pe.kr/xe/?mid=document&amp;CT=All">jQuery API 한글 번역</a></li>
  <li><a href="http://direct.co.kr/cs/jQuery.pdf">한글 jQuery 시리즈 강좌 리스트 : PDF와 동영상 링크</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML & CSS 중급자 가이드 - 4강 : 반응형 웹 디자인]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/advanced-guide-to-html-and-css-4-slash-10/"/>
    <updated>2013-07-22T21:20:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/advanced-guide-to-html-and-css-4-slash-10</id>
    <content type="html"><![CDATA[<p>원본 : <a href="http://learn.shayhowe.com/advanced-html-css/responsive-web-design">An Advanced Guide to HTML &amp; CSS - LESSON 4 : Responsive Web Design</a></p>

<p>인터넷은 누구도 예측할 수 없을 정도로 빠르게, 미친듯이 성장했다. 최근 수 년간 모바일 성장이 현장에서 폭발하고 있다. 모바일 인터넷 사용의 성장도 일반 인터넷 사용의 성장을 훨씬 뛰어넘고 있다.</p>

<p>요즘 인터넷에 연결되는 모바일 기기를 하나 이상 갖고 있지 않은 사람을 찾는 것은 힘들다. 영국에선 인구보다 <a href="http://www.gpmd.co.uk/blog/2012-mobile-internet-statistics/">모바일 폰</a>이 더 많고, 모바일 인터넷 사용이 데스크탑 인터넷 사용을 올해 추월하는 <a href="http://www.digitalbuzzblog.com/2011-mobile-statistics-stats-facts-marketing-infographic/">트랜드가 이어지고 있다</a>.</p>

<p>모바일 인터넷 사용이 계속 성장하면서 어떻게 모든 유저에게 적합한 웹사이트를 만들 것인가 하는 질문이 제기되고있다. 업계는 이 질문에 반응형 웹 디자인(responsive web design : RWD로 응답하고 있다.
<!-- more --></p>

<h2 id="responsive-overview">Responsive Overview</h2>

<p>반응형 웹 디자인은 모바일 혹은 데스트탑의 모든 기기와 크고 작은 모든 스크린 사이즈에서 적절하게 작동하는 웹사이트를 만드는 것이다.</p>

<p>반응형 웹 디자인은 모든 사람에게 직관적이고 만족스런 경험을 제공하는 것에 초점을 두며, 데스크탑 유저와 폰 유저 모두에게 같은 이익을 제공한다.</p>

<p>반응형 웹 디자인<a href="http://www.alistapart.com/articles/responsive-web-design/">responsive web design</a> 용어는 Ethan Marcotte가 만들어냈고 주로 키웠다. 이 강의에서 다루는 많은 것은 Ethan 온라인과 그의 책 <a href="http://www.abookapart.com/products/responsive-web-design/">Responsive Web Design</a>에서 먼저 이야기된 것이다.</p>

<p><img src="http://learn.shayhowe.com/assets/courses/advanced-html-css-guide/responsive-web-design/food-sense.png" alt="Food Sense Responsive Layout" /></p>

<p><strong>Fig. 4.01</strong> </p>

<p><a href="http://foodsense.is/">Food Sense</a>는 아름다운 웹사이트이며, 모든 다른 뷰포트 사이즈에 반응한다. 크건 작건 뷰포트에 웹사이트가 조절되어 자연스런 사용자 경험을 만든다.</p>

<p>역자 참조 링크</p>

<ul>
  <li><a href="http://www.w3.org/TR/CSS2/visuren.html#viewport">Viewport</a> : 화면의 창 또는 보이는 영역</li>
</ul>

<h3 id="responsive-vs-adaptive-vs-mobile">Responsive vs. Adaptive vs. Mobile</h3>

<p><em>Responsive</em>(반응형) 와 <em>adaptive</em>(적응형) 웹 디자인은 밀접하게 연관되며, 종종 같은 의미로 사용된다. 반응형은 일반적으로 어떤 변화에도 빠르고 적극적으로 반응하는 것을 의미하는 반면 적응형은 (<em>변화</em>와 같은) 새로운 목적이나 상황에 쉽게 변경되는 것을 의미한다. 반응형 디자인에서는 웹사이트가 뷰포트 너비와 같은 요인에 지속적으고 유동적으로 변하지만, 적응형 웹사이트는 미리 정해진 요인들에 맞추어 만들어진다. 두 가지의 결합이 이상적이며, 기능적 웹사이트를 위한 완벽한 공식을 제공한다. 어떤 용어가 사용되는가가 특별히 커다란 차이를 만들지는 않는다.</p>

<p><em>Mobile</em>은 일반적으로 모바일 유저만을 위한 새 도메인에 별도의 웹사이트를 만드는 것을 의미한다. 모바일 웹사이트는 극도로 가벼울 수 있지만 새 코드 베이스와 브라우저 스니핑에 의존한다. 이는 개발자와 유저 모두에게 장애물이 될 수 있다.</p>

<p>역자 주 - <a href="http://en.wikipedia.org/wiki/Browser_sniffing">Browser sniffing</a> : 유저의 브라우저가 어떤 것인지 판별하는 것</p>

<p>현재 가장 인기있는 기술은 다른 브라우저와 기기 뷰포트에 따라 레이아웃과 컨텐츠가 변하면서 생동적으로 적응하는 디자인을 선호하는 반응형 웹 디자인에 있다. 이러 해법은 반응형, 적응형과 모바일 모두의 이점을 가지고 있다.</p>

<h2 id="flexible-layouts">Flexible Layouts</h2>

<p>반응형 웹 디자인은 가변(flexible) 레이아웃, 미디어 쿼리, 가변(flexible) 미디어의 세 가지 주요 부분으로 나뉜다.  첫번째 부분인 가변 레이아웃은 어떠한 너비에도 생동적으로 재조정할 수 있는 가변 그리드로 웹 사이트의 레이아웃을 만드는 것이다. 가변 그리드는 대부분 퍼센트나 <code>em</code> 등의 상대적인 길이 단위를 사용한다. 이 상대적인 길이들은 <code>width</code>, <code>margin</code>, <code>padding</code>과 같은 일반적인 그리드 속성값으로 사용된다.</p>

<h4 id="relative-viewport-lengths">Relative Viewport Lengths</h4>

<p>CSS3에서는 몇 개의 새로운 상대 길이 단위가 <a href="http://dev.w3.org/csswg/css3-values/#viewport-relative-lengths">도입되었다</a>. 이는 브라우저나 디바이스의 뷰포트 크기와 특히 관련된 것이며, <code>vw</code>, <code>vh</code>, <code>vmin</code>, <code>vmax</code> 등을 포함한다. 이러한 새로운 단위들에 대한 전체적인 지원은 훌륭하진 않으나 확대되고 있고, 조만간 반응형 웹사이트를 만드는 데에 커다란 역할을 하는 것이다.</p>

<ul>
  <li><code>vw</code>        : Viewports width</li>
  <li><code>vh</code>        : Viewports height</li>
  <li><code>vmin</code>  : Minimum of the viewport’s height and width</li>
  <li><code>vmax</code>  : Maximum of the viewport’s height and width</li>
</ul>

<p>가변 레이아웃은 픽셀이나 인치와 같은 고정 측정 단위를 지원하지 않는다. 기기마다 뷰포트 높이와 너비가 지속적으로 변하기 때문이다. 웹사이트 레이아웃은 이런 변화에 적응할 필요가 있으며 고정 값은 너무 많은 제약이 있다. 다행히 Ethan이 상대값을 사용한 가변 레이아웃의 비율을 선언하는 것을 도와주는 쉬운 공식을 밝혀냈다.</p>

<p>그 공식은 엘리먼트의 목표(target) 너비를 부모 엘리먼트의 너비로 나누어 목표 엘리먼트의 상대적인 너비를 구하는 것이다.</p>

<pre><code>반응형 디자인 공식 : target ÷ context = result
</code></pre>

<h3 id="flexible-grid">Flexible Grid</h3>

<p>이 공식이 두 열(column) 레이아웃 안에서 어떻게 동작하는지 보자. 아래에서 <code>container</code> 클래스의 부모 <code>div</code>가 <code>section</code>과 <code>aside</code> 엘리먼트를 감싸고 있다. <code>section</code>을 왼쪽으로 <code>aside</code>를 오른쪽으로 위치하면서 둘 사이에 같은 마진을 갖게하는 것이 목표다. 보통 이러한 레이아웃의 마크업과 스타일은 다음과 유사할 것이다.</p>

<h6 id="html">HTML</h6>

<pre><code>&lt;div class="container"&gt;
  &lt;section&gt;...&lt;/section&gt;
  &lt;aside&gt;...&lt;/aside&gt;
&lt;/div&gt;
</code></pre>

<h6 id="css">CSS</h6>

<pre><code>.container {
  width: 660px;
}
section {
  float: left;
  margin: 10px;
  width: 420px;
}
aside {
  float: right;
  margin: 10px;
  width: 200px;
}
</code></pre>

<h4 id="fixed-grid-demohttplearnshayhowecomadvanced-html-cssresponsive-web-designfixed-grid-demo"><a href="http://learn.shayhowe.com/advanced-html-css/responsive-web-design#fixed-grid-demo">Fixed Grid Demo</a></h4>

<p>가변 그리드 공식을 사용하여 길이의 고정 단위를 상대 단위로 변경할 수 있다. 이 예제에선 퍼센트를 사용하겠지만 <code>em</code> 단위도 동일하게 작동할 것이다. 부모 <code>container</code>의 너비에 상관없이 <code>section</code>과 <code>aside</code>의 마진과 너비는 비율적으로 크기가 변동될 것이다.</p>

<pre><code>.container {
  max-width: 660px;
}
section {
  float: left;
  margin: 1.51515151%;   /*  10px ÷ 660px = .01515151 */
  width: 63.63636363%;   /* 420px ÷ 660px = .63636363 */   
}
aside {
  float: right;
  margin: 1.51515151%;   /*  10px ÷ 660px = .01515151 */
  width: 30.30303030%;   /* 200px ÷ 660px = .30303030 */
}
</code></pre>

<h4 id="flexible-grid-demohttplearnshayhowecomadvanced-html-cssresponsive-web-designflexible-grid-demo"><a href="http://learn.shayhowe.com/advanced-html-css/responsive-web-design#flexible-grid-demo">Flexible Grid Demo</a></h4>

<p>가변 레이아웃 개념과 공식을 갖고 그리드의 모든 부분에 재적용하면 완벽하게 동적인 웹사이트를 만들 수 있다. 위의 부모 <code>container</code>에서 했듯이 <code>min-width</code>, <code>max-width</code>, <code>min-height</code>, <code>max-height</code> 속성을 수단으로 가변 레이아웃에서 훨씬 더 많은 컨트롤을 할 수 있다.</p>

<p>가변 레이아웃 접근법만으론 충분치 않다. 브라우저 뷰포트의 너비가 너무 작을 때는 레이아웃의 크기를 비율적으로 조절하더라도 열의 크기가 너무 작아 컨텐츠를 효과적으로 표시할 수 없다. 레이아웃이 너무 작거나 크면 텍스트는 읽기 어렵게 되고, 레이아웃이 깨지기 시작할 것이다. 이런 경우엔 미디어 쿼리가 더 나은 경험을 만드는데 도움이 될 수 있다.</p>

<h2 id="media-queries">Media Queries</h2>

<p>미디어 쿼리는 개별 브라우저와 디바이스 환경(예를 들면 뷰포트 너비 혹은 기기 오리엔테이션 등)에 각기 다른 스타일을 제공할 수 있는 확장 기능이다. <a href="http://css-tricks.com/css-media-queries/">타겟 스타일</a>을 독자적으로 제공할 수 있다는 것은 반응형 웹 디자인에 기회과 수단의 세계를 활짝 열어준다.</p>

<h3 id="initializing-media-queries">Initializing Media Queries</h3>

<p>미디어 쿼리를 사용하는 방법은 두 가지가 있다. 기존의 스타일 시트에 <code>@media</code> 룰을 사용하고 <code>@import</code> 룰을 사용하여 새로운 스타일 시트를 들여오거나(import), HTML 문서 안에서 별도의 스타일을 링크하는 것이다. 일반적으로 추가적인 HTTP 요청을 피하기 위해 기존 스타일 시트안에 <code>@media</code> 룰을 사용하는 것이 추천된다.</p>

<h6 id="html-1">HTML</h6>

<pre><code>&lt;!-- Separate CSS File --&gt;
&lt;link href="styles.css" rel="stylesheet" 
media="all and (max-width: 1024px)"&gt;
</code></pre>

<h6 id="css-1">CSS</h6>

<pre><code>/* @media Rule */
@media all and (max-width: 1024px) {...}

/* @import Rule */
@import url(styles.css) all and (max-width: 1024px) {...}
</code></pre>

<p>각 미디어 쿼리는 하나 또는 그 이상의 표현이 뒤따르는 미디어 타입을 포함할 수 있다. 일반적인 미디어 타입은 <code>all</code>, <code>screen</code>, <code>print</code>, <code>tv</code>, <code>braille</code>을 포함한다. HTML5 사양(specifition)은 <code>3d-glasses</code>도 포함하는 새로운 미디어 타입을 포함한다. 미디어 타입을 명시하지 않으면 미디어 쿼리는 미디어 타입을 <code>screen</code>으로 기본으로할 것이다.</p>

<p>미디어 쿼리 표현식은 다른 미디어 특성과 값을 포함할 수 있으며 그리고나서 참(true) 혹은 거짓(false)를 할당한다. 미디어 특성과 값이 참으로 할당될 때 해당 스타일이 적용되며, 거짓이면 해당 스타일은 무시된다.</p>

<h3 id="logical-operators-in-media-queries">Logical Operators in Media Queries</h3>

<p>미디어 쿼리에서 논리적 연산자(logical operator)는 강력한 표현식을 만들 수 있게 해준다. <code>and</code>, <code>not</code>, <code>only</code>의 세 개의 연산자를 사용할 수 있다.</p>

<p><code>and</code> 논리 연산자를 사용하여 브라우저나 기기가 a,b,c 등으로 지정하여 추가적인 조건을 추가할 수 있다. 여러 개의 개별 미디어 쿼리는 콤마로 분리될 수 있으며 암묵적인 <code>or</code> 연산자처럼 동작한다. 아래 예는 <code>800</code>과 <code>1024</code> 픽셀 너비의 모든 미디어 타입을 선택한다.</p>

<pre><code>@media all and (min-width: 800px) and (max-width: 1024px) {...}
</code></pre>

<p><code>not</code> 논리 연산자는 명시된 것을 제외한 모든 쿼리를 특정하여 선언된 쿼리를 부정한다. 아래 예에서는 표현식은 컬러 스크린을 갖지 않는 모든 디바이스에 적용된다. 즉, 흑백이나 모노 스크린에 적용된다.</p>

<pre><code>@media not screen and (color) {...}
</code></pre>

<p><code>only</code> 논리 연산자는 새로운 연산자이며 HTML4 알고리즘을 사용하는 유저 에이전트로는 인식되지 않으므로, 미디어 쿼리를 지원하는 않는 기기나 브라우저에선 스타일이 나타나지 않는다. 아래에서 표현식은 세로 편향(portrait orientation)인 스크린만을 선택한다.</p>

<pre><code>@media only screen and (orientation: portrait) {...}
</code></pre>

<blockquote>
  <h4 id="omitting-a-media-type">Omitting a Media Type</h4>

  <p><code>not</code>과 <code>only</code> 논리 연산자를 사용할 땐 미디어 타입을 쓰지 않을 수 있다. 이 경우 미디어 타입은 <code>all</code>로 전제된다.</p>
</blockquote>

<h3 id="media-features-in-media-queries">Media Features in Media Queries</h3>

<p>미디어 쿼리 문법과 논리 연산자의 작동법을 아는 것은 미디어 쿼리에 대한 훌륭한 입문이나, 실제 작업은 미디어 특성과 함께 한다. 미디어 쿼리 표현식 내에서 어떤 속성이 목표될지를 미디어 특성이 지정한다.</p>

<h4 id="height--width-media-features">Height &amp; Width Media Features</h4>

<p>가장 많이 사용되는 미디어 특성 중 하나는 하나의 디바이스나 브라우저 뷰포트에 하나의 높이나 너비를 결정하는 것에 관련된다. <code>height</code>, <code>width</code>, <code>device-height</code>, <code>device-width</code>의 미디어 특성을 사용해서 높이와 너비는 찾을 수 있다. 각 미디어 특성은 <code>min</code> 혹은 <code>max</code> 수식어로 접두될 수 있어 <code>min-width</code> 혹은 <code>max-device-width</code>과 같은 특성을 만들 수 있다.</p>

<p><code>height</code>와 <code>width</code> 특성은 (브라우저 창과 같은) 뷰포트 렌더링 영역의 높이와 너비에 기반하며, 한편 <code>device-height</code>와 <code>device-width</code> 특성은 (실제 렌더링 영역보다 더 클 수 있는) 출력 기기의 높이와 너비에 기반한다. 이 높이와 너비 미디어 특성 값은 (상대적이거나 절대적인) 어떠한 길이 값도 될 수 있다.</p>

<pre><code>@media all and (min-width: 320px) and (max-width: 780px) {...}
</code></pre>

<p>반응형 디자인에서는 <code>min-width</code>과 <code>max-width</code>를 포함하는 특성이 가장 많이 사용된다. 이것들은 기기 특성에 혼동을 피해 데스크탑과 모바일 기기에 동일하게 반응형 웹사이트를 만드도록 해준다.</p>

<blockquote>
  <h4 id="using-minimum--maximum-prefixes">Using Minimum &amp; Maximum Prefixes</h4>

  <p><code>min</code>과 <code>max</code> 접두어는 꽤 많은 미디어 특성에서 사용될 수 있다. <code>min</code> 접두어는 보다 크거나 같은 값을 가리키며, <code>max</code> 접두어는 더 적거나 같은 값을 가리킨다. <code>min</code>과  <code>max</code> 접두어는 일반적인 HTML 문법과 충돌되지 않아 특별히 꺽쇠 심볼을 사용하지 않는다.</p>
</blockquote>

<h4 id="orientation-media-feature">Orientation Media Feature</h4>

<p><code>orientation</code> 미디어 특성은 기기가 <code>landscape</code>나 <code>portrait</code> 편향(orientation)인지를 결정한다. <code>landscape</code> 모드는 화면이 가로 모드일 때, <code>portrait</code> 모드는 화면이 세로 모드일 때이며, 모바일 기기에서 널리 사용된다.</p>

<pre><code>@media all and (orientation: landscape) {...} 
</code></pre>

<h4 id="aspect-ratio-media-features">Aspect Ratio Media Features</h4>

<p><code>aspect-ratio</code>와 <code>device-aspect-ratio</code> 특성은 목표 렌더링 영역 혹은 출력 기기의 <code>width/height</code> 픽셀 비율을 지정한다. <code>min</code>와 <code>max</code> 접두어가 사용될 수 있다.</p>

<p>종횡비(aspect ratio) 값은 /로 분리되는 두 개의 양의 정수로 구성된다. 첫 정수는 픽셀 너비를, 두번째 정수는 픽셀 높이이다.</p>

<pre><code>@media all and (min-device-aspect-ratio: 16/9) {...}
</code></pre>

<blockquote>
  <h4 id="pixel-ratio-media-features">Pixel Ratio Media Features</h4>

  <p>종횡비 특성에 더해 <code>pixel-ratio</code> 미디어 특성도 있다. 이 특성은 <code>device-pixel-ratio</code> 특성을 포함하며, <code>min</code>과 <code>max</code> 접두어도 가진다. 특히 픽셀비 특성은 레티나 디스플레이와 같은 고해상도 기기를 지정할 때 훌륭하며, 다음처럼 보여질 것이다.</p>

  <p>   @media only screen and (-webkit-min-device-pixel-ratio: 1.3), only screen and (min-device-pixel-ratio: 1.3) {…}</p>
</blockquote>

<h4 id="resolution-media-feature">Resolution Media Feature</h4>

<p><code>resolution</code> 미디어 특성은 DPI(dots per inch)로 알려진 픽셀 밀도로 출력 기기의 해상도를 지정한다. <code>min</code>과 <code>max</code>를 접두할 수 있다. 게다가 <code>resolution</code> 미디어 속성은 dots per pixel (<code>1.3dppx</code>), dots per centimeter (<code>118dpcm</code>)와 같은 길이 기반 해상도 값을 가질 수도 있다.</p>

<pre><code>@media print and (min-resolution: 300dpi) {...}
</code></pre>

<h4 id="other-media-features">Other Media Features</h4>

<p><code>color</code>, <code>color-index</code>, <code>monochrome</code> 특성은 출력 색상을, <code>grid</code> 특성은 비트맵 기기를, <code>scan</code> 특성은 텔레비전의 스캐닝 처리를 지정하며, 자주 사용하지는 않지만 필요할 땐 도움이 된다.</p>

<blockquote>
  <h4 id="media-query-browser-support">Media Query Browser Support</h4>

  <p>불행하게도 미디어 쿼리는 인터넷 익스플로러 8 이하와 고전적인 브라우저에서는 작동하지 않는다. 그러나, 자바스크립트로 쓰여진 두 개의 알맞는 땜빵(polyfill)이 있다.</p>

  <p><a href="https://github.com/scottjehl/Respond/">Respond.js</a>는 min/max-witdh 타입만을 위한 가벼운 땜빵이며, 미디어 쿼리 타입만 사용된다면 완벽하다. <a href="http://code.google.com/p/css3-mediaqueries-js/">CSS3-MediaQueries.js</a>는 더 많이 개발되고 더 무겁지만 더 복잡한 미디어 쿼리의 더 큰 배열을 지원하는 땜빵이다. 추가적으로 어떠한 땜빵이라도 성능 문제를 가져올 수 있으며, 잠재적으로 웹사이트를 느리게 할 수 있다는 것을 명심해야한다. 주어진 땜빵이 성능과 맞바꿀만한지 확인해야한다.</p>
</blockquote>

<h3 id="media-queries-demo">Media Queries Demo</h3>

<p>이제 미디어 쿼리를 사용하여 전에 만들었던 가변 레이아웃을 다시 코딩하자. 데모의 현재 문제점 중 하나는 <code>aside</code>가 아주 작은 뷰포트에서 사용할 수 없을 정도로 작아진다는 것이다. <code>420</code> 픽셀 너비 아래의 뷰포트를 위해 미디어 쿼리를 추가하여 <code>float</code>를 꺼버리고 <code>section</code>과 <code>aside</code>의 너비를 변화시키는 레이아웃으로 변경할 수 있다.</p>

<pre><code>@media all and (max-width: 420px) {
  section, aside {
    float: none;
    width: auto;
  }
}
</code></pre>

<p><strong>Fig. 4.02</strong> 미디어 쿼리 없이는 <code>section</code>과 <code>aside</code> 너무 작아 진다. 너무 작아서 어떤 실제 컨텐츠도 담을 수 없다.
<img src="http://learn.shayhowe.com/assets/courses/advanced-html-css-guide/responsive-web-design/without-media-queries.png" alt="Demo without Media Queries" /></p>

<p><strong>Fig. 4.03</strong> 미디어 쿼리를 사용하여 <code>float</code>를 제거하고 너비를 변경하면, <code>section</code>과 <code>aside</code>가 뷰포트 전체 너비를 차지하고 기존의 컨텐츠에 충분한 공간이 생겼다.
<img src="http://learn.shayhowe.com/assets/courses/advanced-html-css-guide/responsive-web-design/with-media-queries.png" alt="Demo with Media Queries" /></p>

<blockquote>
  <h4 id="identifying-breakpoints">Identifying Breakpoints</h4>

  <p>당신의 직관이 각기 다른 기기 해상도로 결정되는 공통적인 뷰포트 사이즈의 미디어 쿼리 분기점(<code>320px</code>, <code>480px</code>, <code>768px</code>, <code>1024px</code>, <code>1224px</code> 등)을 쓸지도 모르겠다. 그러나 이건 <strong>나쁜</strong> 아이디어이다.</p>

  <p>반응형 웹사이트를 만들 때는 기기만아니라 다른 뷰포트 사이즈의 배열에 맞추어 조정되어야 한다. 웹사이트가 깨지거나 이상하게 보이기 시작할 때 혹은 경험이 방해받을 때에만 분기점(breakpoint)이 도입되어야 한다.</p>

  <p>게다가 새로운 기기와 해상도는 항상 출시된다. 이러한 변화를 따라가려는 것은 끝없는 과정일 수 있다.</p>
</blockquote>

<h2 id="mobile-first">Mobile First</h2>

<p>미디어 쿼리와 함께 가장 인기있는 기술은 <em>mobile first</em>로 불리우는 것이다. <a href="http://www.lukew.com/presos/preso.asp?26">mobile first</a> 접근법은 작은 뷰포트의 스타일을 기본 웹사이트 스타일로 한 다음 뷰포트가 커짐에 따른 스타일을 추가하기위해 미디어 쿼리를 사용한다.</p>

<p>모바일 퍼스트 디자인의 배경에서 작동되는 믿음은 일반적으로 더 작은 뷰포트를 사용하는 모바일 기기 유저는 모바일 스타일을 덮어쓰기만을 위해 테스크탑 스타일을 로드할 필요가 없다는 것이다. 그렇게 하는 것은 대역폭(bandwidth)의 낭비이다. 쾌적한 웹사이트를 기대하는 어떤 유저에게도 귀중한 대역폭 말이다.</p>

<p>모바일 퍼스트 접근법은 모바일 유저의 제한을 염두에 두고 디자인하는 것을 지원하기도 한다. 오래 전에 인터넷 소비의 태반이 모바일 기기로 이루어질 것으로 예상되었다. 적절하게 그것을 계획하고 본질적인 모바일 경험을 개발하라.</p>

<p>모바일 퍼스트 미디어 쿼리는 다음과 같을 것이다.</p>

<pre><code>/* Default styles first then media queries */
@media screen and (min-width: 400px)  {...}
@media screen and (min-width: 600px)  {...}
@media screen and (min-width: 1000px) {...}
@media screen and (min-width: 1400px) {...}
</code></pre>

<p>불필요한 미디어를 다운로드하는 것은 미디어 쿼리를 사용하여 중지시킬 수 있다. 일반적으로 모바일 스타일에서 CSS3 그림자, 그라디언트, 변형(transform), 애니메이션 등을 피하는 것은 나쁜 아이디어가 아니다. 지나치게 사용되면 로딩이 무겁게되고, 기기의 배터리를 빨리 닳게할 수도 있다.</p>

<pre><code>/* Default media */
body {
  background: #ddd;
}
/* Media for larger devices */
@media screen and (min-width: 800px) {
  body {
    background-image: url("bg.png") 50% 50% no-repeat;
  }
}
</code></pre>

<h3 id="mobile-first-demo">Mobile First Demo</h3>

<p>이전 예제에 미디어 쿼리를 추가하면 <code>420</code> 픽셀 너비 미만에서 더 나은 레이아웃을 얻기위해 약간의 스타일을 겹쳐쓰자. 모바일 스타일 퍼스트를 기본으로 사용하기 위해 코드를 다시 쓰고 <code>420</code> 픽셀 이상의 뷰포트에 맞추기 위해 미디어 쿼리를 추가하면 다음과 같다.</p>

<p><a href="http://learn.shayhowe.com/courses/advanced-html-css/responsive-web-design/responsive-web-design-demo.html">View this code in action.</a></p>

<pre><code>section, aside {
  margin: 1.51515151%;
}
@media all and (min-width: 420px) {
  .container {
    max-width: 660px;
  }
  section {
    float: left;
    width: 63.63636363%;
  }
  aside {
    float: right;
    width: 30.30303030%;
  }
}
</code></pre>

<p>코드 양이 전과 같음을 주목하라. 여기서 유일한 예외는 모바일 기기는 <strong>하나의</strong> CSS 선언만 렌더링해야만 한다는 것이다. 뒤따르는 나머지 스타일은 더 큰 뷰포트에서만 로드되고 어떤 선행 스타일을 겹쳐쓰지 않는다.</p>

<h2 id="viewport">Viewport</h2>

<p>요사이 모비일 기기는 일반적으로 웹사이트를 꽤 잘 보여주고 있다. 때때로 <a href="http://dev.opera.com/articles/view/an-introduction-to-meta-viewport-and-viewport/">뷰포트</a> 사이즈, 스케일, 웹사이트 해상도 등을 별도로 지정해주어 약간의 지원을 해줄 수 있다. 이것을 개선하기 위해 애플이 <code>viewport</code> 메타 태그를 만들었다.</p>

<p><strong>Fig. 4.04</strong>
이 데모는 미디어 쿼리를 사용했음에도 많은 모바일 기기들이 아직 웹사이트의 최초 너비나 크기를 알 수 없어서 미디어 쿼리가 적용되지 않을지도 모른다.
<img src="http://learn.shayhowe.com/assets/courses/advanced-html-css-guide/responsive-web-design/without-viewport.png" alt="Website without Viewport Meta Tag" /></p>

<h4 id="viewport-height--width">Viewport Height &amp; Width</h4>

<p><code>viewport</code> 메타 태그를 <code>height</code>나 <code>width</code> 값과 함께 사용하면 뷰포트의 높이나 너비를 각각 정의할 것이다. 각각의 값은 양의 정수나 키워드로 받아들인다. <code>height</code> 속성은 키워드 <code>device-height</code> 값을 받아들이고, <code>width</code> 속성은 키워드 <code>device-width</code>를 받아들인다. 이 키워드들을 이용해 기기의 기본 높이와 너비 값을 상속한다.</p>

<p>웹사이트가 가장 최적으로 보이는 결과를 위해 <code>device-height</code>와  <code>device-width</code> 값을 적용하여 기기 디폴트를 사용하는 것을 추천한다.</p>

<pre><code>&lt;meta name="viewport" content="width=device-width"&gt;
</code></pre>

<p><strong>Fig. 4.05</strong>
기기가 웹사이트의 의도된 너비(여기서는 <code>device-width</code>)를 알게하여 웹사이트를 적절한 크기로 나타내고 알맞는 미디어 쿼리를 선태할 수 있다.
<img src="http://learn.shayhowe.com/assets/courses/advanced-html-css-guide/responsive-web-design/with-viewport.png" alt="Website with Viewport Meta Tag" /></p>

<h4 id="viewport-scale">Viewport Scale</h4>

<p>모바일 기기에서 웹사이트의 크기를 조절하고 유저가 웹사이트의 크기를 지속적으로 조절할 수 있게 통제하러면 <code>minimum-scale</code>, <code>maximum-scale</code>, <code>initial-scale</code>, <code>user-scalable</code> 속성을 사용하라.</p>

<p>웹사이트의 <code>initial-scale</code>은 <code>1</code>로 설정해야하고, 이것은 세로 편향일 때의 기기 높이와 뷰포트 크기 간의 비율을 정의한다. 가로 편향에선 기기 너비와 뷰포트 크기간의 비율이 된다. <code>initial-scale</code> 값은 항상 <code>0</code>과 <code>10</code> 사이의 양의 정수이어야 한다.</p>

<pre><code>&lt;meta name="viewport" content="initial-scale=2"&gt; 
</code></pre>

<p><strong>Fig. 4.06</strong> 
<code>1</code>을 넘는 정수를 사용하면 웹사이트는 기본 크기보다 더 크게 확대될 것이다. 이 값을 <code>1</code>로 설정하는 것이 대부분의 공통사항이다.
<img src="http://learn.shayhowe.com/assets/courses/advanced-html-css-guide/responsive-web-design/viewport-scale.png" alt="Viewport Scale Meta Tag" /></p>

<p><code>minimum-scale</code>과 <code>maximum-scale</code> 값은 뷰포트가 얼마나 작고 커질지를 결정한다. <code>minimum-scale</code>을 사용할 경우 그 값은 <code>initial-scale</code>과 같거나 더 작은 양의 정수여야 한다. 같은 이유로 <code>maximum-scale</code> 값은 <code>initial-scale</code>과 같거나 더 큰 양의 정수여야 한다. 이 두 값도 역시 <code>0</code>과 <code>10</code> 사이여야 한다.</p>

<pre><code>&lt;meta name="viewport" content="minimum-scale=0"&gt;
</code></pre>

<p>일반적으로 이 값들은 <code>initial-scale</code>과 같은 값을 설정하지 말아야 한다. 이것은 확대를 못하게 하고 <code>user-scalable</code> 값으로 수행되는 확대 기능을 불가능하게 한다. <code>user-scalable</code> 값을 <code>no</code>로 설정하면 확대하지 못하게 될 것이고, <code>user-scalable</code> 값을 <code>yes</code>로 설정하면 확대 기능(zooming)이 켜진다.</p>

<p>웹사이트의 크기 조절을 가능하게 하는 것은 <strong>나쁜 아이디어</strong>다. 웹사이트를 바라던 대로 보지 못하게 방해하여 접근성과 사용성을 해친다.</p>

<pre><code>&lt;meta name="viewport" content="user-scalable=yes"&gt;
</code></pre>

<h4 id="viewport-resolution">Viewport Resolution</h4>

<p>브라우저가 모든 뷰포트 크기에 맞추어 웹사이트를 크기 조절하는 방법을 결정하게 하려면 일반적으로 트릭을 사용한다. 더 많은 제어가 요구될 때(특히, 기기 해상도 같은)는 <code>target-densitydpi</code>값이 사용될 수 있다. <code>target-densitydpi</code> 뷰포트는 <code>device-dpi</code>, <code>high-dpi</code>, <code>medium-dpi</code>, <code>low-dpi</code> 혹은 실제 DPI 수와 같은 값이 사용된다.</p>

<p><code>target-densitydpi</code> 뷰포트 값은 드물게 사용되지만 픽셀 단위 제어가 필요할 땐 매우 도움이 된다.</p>

<pre><code>&lt;meta name="viewport" content="target-densitydpi=device-dpi"&gt;
</code></pre>

<h4 id="combining-viewport-values">Combining Viewport Values</h4>

<p><code>viewport</code> 메타 태그는 개별 값만이 아니라 멀티 뷰포트 속성을 한번에 설정할 수 있는 멀티 값도 받아들인다. 멀티 값을 설정할 때는 <code>content</code> 속성 값 안에서 <code>,</code>로 분리해야 한다. 추천되는 뷰포트 값은 아래와 같이 <code>width</code>와 <code>initial-scale</code> 속성을 같이 사용하는 것이다.</p>

<pre><code>&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;   
</code></pre>

<p><strong>Fig. 4.07</strong> 
<code>width=device-width</code>와 <code>initial-scale=1</code>의 조합은 일반적으로 요구되는 최초 크기와 줌(zoom)을 제공한다.
<img src="http://learn.shayhowe.com/assets/courses/advanced-html-css-guide/responsive-web-design/with-viewport.png" alt="Website with Viewport Meta Tag" /></p>

<h4 id="css-viewport-rule">CSS Viewport Rule</h4>

<p><code>viewport</code> 메타 태그는 웹사이트가 렌더링되어야 하는 스타일에 강하게 연관되어 있기 때문에 HTML 안의 메타태그보다는 CSS 안에서 <code>@</code> 룰로 옮길 것을 추천한다. 이렇게 하는 것은 컨텐츠에서 스타일을 분리하여 보다 시맨택적으로 접근하는 것을 도와준다.</p>

<p>현재 몇몇 브라우저는 이미 <code>@viewport</code> 룰을 적용했으나 전반적인 지원은 훌륭하지 않다. 위에서 추천된 <code>viewport</code> 메타 태그는 다음 CSS에서의 <code>@viewport</code> 룰과 같이 보여질 것이다.</p>

<pre><code>@viewport {
  width: device-width;
  zoom: 1;
}
</code></pre>

<h2 id="flexible-media">Flexible Media</h2>

<p>마지막 반응형 웹 디자인의 중요한 측면은 가변 미디어와 관련된 것이다. 뷰포트 크기가 변하기 시작하면 미디어가 항상 알맞게 따라오는 것은 아니다. 이미지, 비디오와 같은 미디어 타입은 뷰포트 변화에 맞추어 크기를 변화시킬 필요가 있다.</p>

<p>미디어 크기를 조절할 수 있게 하는 빠른 방법은 <code>max-width</code> 속성을 <code>100%</code> 값으로 주는 것이다. 그렇게 하면 뷰포트가 작아질 때 미디어의 크기가 컨테이너 너비에 맞추어 작아질 것이다.</p>

<pre><code>img, video, canvas {
  max-width: 100%;
}
</code></pre>

<h4 id="flexible-media-demohttplearnshayhowecomadvanced-html-cssresponsive-web-designflexible-media"><a href="http://learn.shayhowe.com/advanced-html-css/responsive-web-design#flexible-media">Flexible Media Demo</a></h4>

<h3 id="flexible-embedded-media">Flexible Embedded Media</h3>

<p>불행히도 <code>max-width</code> 속성이 모든 미디어 실례에서 잘 작동하진 않는다. <code>iframes</code>과 같이 임베딩된 미디어에서 특히 그렇다. 유투브와 같은 서드파티 웹사이트와 함께 할 때 아이프레임을 사용하여 미디어를 임베딩하면 엄청나게 실망하게 된다. 다행히 <a href="http://alistapart.com/article/creating-intrinsic-ratios-for-video">우회 방법</a>이 있다.</p>

<p>반응형을 완벽히 지원하는 임베딩된 미디어를 얻으려면 임베딩된 엘리먼트는 부모 엘리먼트 안에서 절대적으로 배치될(be absolutely positioned) 필요가 있다. 뷰포트의 너비에 기반하여 크기 조절될 수 있도록 부모 엘리먼트의 <code>width</code>가 <code>100%</code>로 요구된다. 또한, 인터넷 익스플로러에서는 <code>hasLayout</code> 매커니즘을 작동시키기 위해서 부모 엘리먼트의 <code>height</code>가 <code>0</code>로 요구된다.</p>

<p>그런 후 부모 엘리먼트의 <code>padding-bottom</code>을 주고, 그 값을 비디오의 종횡비와 같게 설정한다. 이렇게 하면 부모 엘리먼트의 높이가 너비에 비례하게 된다. 이전의 반응형 디자인 공식을 기억하는가? 비디오의 종횡비가 16:9라면 <code>9</code>를 <code>16</code>으로 나누면 <code>.5625</code>가 되며, <code>padding-bottom</code>은 <code>56.25%</code>가 요구된다. <code>padding-bottom</code>이 사용되고 부모 엘리먼트는 절대적으로 배치된 엘리먼트로 다룬다. <code>padding-top</code>은 인터넷 익스플로어 5.5에서 깨지는 방지하기 위해 특별히 사용된다.</p>

<p><em>원문 : Padding on the bottom and not the top is specifically used to prevent Internet Explorer 5.5 from breaking, and treating the parent element as an absolutely positioned element. - 이 부분은 무척 쉬운 듯하면서 몇번을 읽어봐도 정확하게 번역하기 힘들어 내맘대로 말그대로 막번역해버렸다. 마지막 문장이라 노력했지만 역부족이다. 고수님들이 도와주시면 좋겠는데.. ㅠㅠ</em></p>

<h6 id="html-2">HTML</h6>

<pre><code>&lt;div class='bogus-wrapper'&gt;&lt;notextile&gt;&lt;figure&gt;
  &lt;iframe src="https://www.youtube.com/embed/4Fqg43ozz7A"&gt;&lt;/iframe&gt;
&lt;/figure&gt;&lt;/notextile&gt;&lt;/div&gt;
</code></pre>

<h6 id="css-2">CSS</h6>

<pre><code>figure {
  height: 0;
  padding-bottom: 56.25%; /* 16:9 */
  position: relative;
  width: 100%;
}
iframe {
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
} 
</code></pre>

<h4 id="flexible-embedded-media-demohttplearnshayhowecomadvanced-html-cssresponsive-web-designflexible-embed"><a href="http://learn.shayhowe.com/advanced-html-css/responsive-web-design#flexible-embed">Flexible Embedded Media Demo</a></h4>

<h2 id="resources--links">Resources &amp; Links</h2>

<ul>
  <li><a href="http://www.alistapart.com/articles/responsive-web-design/">Responsive Web Design</a> via A List Apart</li>
  <li><a href="http://dev.w3.org/csswg/css3-values/#viewport-relative-lengths">Viewport Percentage Lengths</a> via W3C</li>
  <li><a href="http://css-tricks.com/css-media-queries/">CSS Media Queries</a> via CSS-Tricks</li>
  <li><a href="http://www.lukew.com/presos/preso.asp?26">Mobile First Presentation</a> via Luke Wroblewski</li>
  <li><a href="http://dev.opera.com/articles/view/an-introduction-to-meta-viewport-and-viewport/">An Introduction to Meta Viewport and @viewport</a> via Dev.Opera</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML & CSS 초보자 가이드 - 5강 : 백그라운드와 그라디언트]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/beginners-guide-to-html-and-css-5-slash-10/"/>
    <updated>2013-07-22T21:08:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/beginners-guide-to-html-and-css-5-slash-10</id>
    <content type="html"><![CDATA[<p>원본 : <a href="http://learn.shayhowe.com/html-css/backgrounds-gradients">A Beginner’s Guide to HTML &amp; CSS - LESSON 5 : Backgrounds &amp; Gradients</a></p>

<p>백그라운드(배경)은 작게 쓰이거나 크게 쓰이거나 웹사이트 전체 디자인에 중요한 시각적 효과를 준다.</p>

<p>CSS3에서는 그라디언트 백그라운드, 하나의 엘리먼트에 여러 백그라운드 이미지 적용 등의 새로운 <a href="http://learn.shayhowe.com/html-css/backgrounds-gradients">백그라운드 특성</a>이 도입되었다.
<!-- more --></p>

<h2 id="adding-a-background-color">Adding a Background Color</h2>

<p>엘리먼트에 백그라운드 적용하는 가장 빠른 방법은 <code>background</code>나 <code>background-color</code> 속성으로 한 가지 색의 백그라운드를 적용하는 것이다. <code>background</code> 속성은 색상과 이미지를, <code>background-color</code>는 백그라운드 색상만을 위해 사용된다.</p>

<pre><code>div {
  background: #f60;
  background-color: #f60;
}
</code></pre>

<p>백그라운드 속성을 선언할 때 16진값, RGB, RGBa, HSL, HSLa의 키워드를 사용한다. 보통 16진수를 사용하며, 알파 채널을 통한 불투명도를 주는 경우는 RGBa와 HSLa를 사용한다. 만약 30% 불투명한 검정을 기대한다면 <code>rgba(0, 0, 0, 0.3)</code>를 사용하면 된다. RGBa와 HSLa는 모든 브라우저에서 지원되는 것은 아니기 때문에 다음과 같이 불투명값을 사용하는 선언 바로 위에 대체 CSS를 선언해야 한다.</p>

<pre><code>div { 
    background: #b2b2b2;
    background: rgba(0,0,0,0.3);
}
</code></pre>

<h2 id="adding-a-background-image">Adding a Background Image</h2>

<p>백그라운드 색상처럼 <code>background</code> 속성이나 <code>background-image</code> 속성을 사용하여 백그라운드 이미지를 추가할 수 있다. 어떤 속성을 사용하던지 간에 백그라운 이미지의 경로 즉, 이미지 소스를 정의하는 <code>url</code> 값을 사용해야 한다.</p>

<pre><code>div {
  background: url('alert.png');
  background-image: url('alert.png');
}
</code></pre>

<p><code>url</code> 값만 사용하면 컨테이너 엘리먼트의 좌상에서부터 수평과 수직 방향으로 반복될 것이다. 다행히 <code>background-repeat</code> 와 <code>background-position</code> 속성을 사용해서 이를 해결할 수 있다.</p>

<h3 id="background-repeat">Background Repeat</h3>

<p>기본적으로 백그라운 이미지는 수평과 수직 방향으로 무한 반복된다. <code>background</code> 속성의 <code>url</code> 값 뒤에 반복 값을 추가하거나 <code>background-repeat</code> 속성으로 반복 값을 지정할 수 있다.</p>

<pre><code>div {
  background: url('alert.png') no-repeat;
  background-image: url('alert.png');
  background-repeat: no-repeat;
}
</code></pre>

<p>백그라운드 반복(repeat)은 <code>repeat</code>, <code>repeat-x</code>, <code>repeat-y</code>, <code>no-repeat</code>의 네 가지 값을 갖는다. <code>repeat</code> 값이 디폴트이며, 수직과 수평 방향으로 이미지를 반복한다. <code>repeat-x</code>는 수평방향으로 이미지를 반복하며, <code>repeat-y</code>는 수직방향으로 반복한다. <code>no-repeat</code>는 백그라운드 이미지를 한번만 표시하며, 반복하지 않는다.</p>

<h3 id="background-position">Background Position</h3>

<p><code>background-position</code> 속성을 사용하면 백그라운드 이미지가 어디에 위치할지와 어디서부터 반복할지를 조정할 수 있다. 다른 백그라운드 속성과 마찬가지로 <code>background</code> 속성의 <code>url</code> 값 뒤에서 지정하거나 <code>background-position</code> 속성으로 별도로 지정할 수 있다.</p>

<pre><code>div {
  background: url('alert.png') 10px 10px no-repeat;
  background-image: url('alert.png');
  background-position: 10px 10px;
  background-repeat: no-repeat;
}
</code></pre>

<p>백그라운드 포지션은 수평 오프셋(첫번째)과 수직 오프셋(마지막)의 두 가지 값이 필요하다. <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 키워드 값을 사용할 수 있다. 이 키워드 값은 퍼센트와 매유 유사하게 작동한다. <code>top left</code> 키워드는 <code>0 0</code> 퍼센트와 동일하고, <code>right bottom</code>은 <code>100% 100%</code> 퍼센트와 동일하다.</p>

<p><code>50%</code> 값을 이용하면 백그라운드 이미지를 중앙에 정렬할 수 있다.엘리먼트의 상단에 백그라운드 이미지를 중양 정렬하려면 <code>50% 0</code> 값을 사용하면 된다. 정확한 조정을 위해 픽셀을 사용하는 것도 인기있는 방법이다.</p>

<p><img src="http://learn.shayhowe.com/assets/courses/html-css-guide/backgrounds-gradients/background-percentages.png" alt="Background Percentages" />
<strong>Fig. 5.01</strong> 백그라운드 이미지의 위치를 조정하기 위해 퍼센트와 키워드를 사용</p>

<h3 id="alert-message-background-example">Alert Message Background Example</h3>

<h6 id="html">HTML</h6>

<pre><code>&lt;p&gt;&lt;strong&gt;Warning!&lt;/strong&gt; You are walking on thin ice.&lt;/p&gt;
</code></pre>

<h6 id="css">CSS</h6>

<pre><code>p {
  background: #fff6cc url('warning.png') 15px 50% no-repeat;
  border-radius: 6px;
  border: 1px solid #ffd100;
  color: #000;
  padding: 10px 10px 10px 38px;
}
</code></pre>

<h4 id="demo">Demo</h4>
<ul>
  <li><a href="http://jsfiddle.net/nolboo/gWUuR/">jsfiddle 링크</a></li>
</ul>

<h2 id="gradient-backgrounds-with-css3">Gradient Backgrounds with CSS3</h2>

<p>그라디언트 백그라운드는 CSS3와 함께 도입되었으며, 모든 브라우저에서 지원되지는 않지만 최신 브라우저에서는 전부 지원된다.</p>

<p>그라디언트 백그라운드는 백그라운드 이미지처럼 다뤄지며, <code>background</code>나 <code>background-image</code> 속성을 이용하여 linear, radial 두 가지 형태로 만들 수 있다.</p>

<blockquote>
  <h4 id="browser-specific-property-values">Browser Specific Property Values</h4>
  <p><br />
브라우저들이 CSS3를 다른 특성들을 서서히 지원하였기 때문에 각 브라우저 제작사는 약간씩 다른 방법으로 새로운 속성을 적용하였다. 새로운 속성이 정확하게 작동하게 하기 위해 vendor prefix를 사용했다. 대부분의 브라우저가 그라디언트 백그라운드를 표준으로 정했지만 아직은 대체 지원을 할 필요가 있다.
<br /><br />
vendor prefixe가 점점 상관없어지고 있지만 오래된 브라우저 때문에 그것들을 사용하는 것이 더 안전한다.<br /><br /></p>

  <ul>
    <li>Mozilla Firefox: <code>-moz-</code> </li>
    <li>Microsoft Internet Explorer: <code>-ms-</code></li>
    <li>Opera: <code>-o-</code></li>
    <li>Webkit (Chrome &amp; Safari): <code>-webkit-</code></li>
  </ul>
</blockquote>

<h3 id="linear-gradient-background">Linear Gradient Background</h3>

<p>수년간 디자이너와 개발자들은 이미지 화일을 잘라내 선형(linear) 그라디언트 백그라운드로 사용해왔다. 잘 작동하기는 했지만 적용하는 시간이 걸렸고, 변경하기가 어려웠다. 다행히 그런 시절은 가버렸고 이젠 CSS안에서 <a href="http://dev.opera.com/articles/view/css3-linear-gradients/">linear gradient</a>를 지정할 수 있다. 색상을 변경하려고 이미지를 다시 자르고 서버에 업로드할 필요가 없으며, CSS 안에서 빠르게 변경할 수 있다.</p>

<pre><code>div {
  background: #70bf32;
  background: url('linear-gradient.png') 0 0 repeat-x;
  background: -webkit-linear-gradient(#a1e048, #6a942f);
  background:    -moz-linear-gradient(#a1e048, #6a942f);
  background:     -ms-linear-gradient(#a1e048, #6a942f);
  background:      -o-linear-gradient(#a1e048, #6a942f);
  background:         linear-gradient(#a1e048, #6a942f);
}
</code></pre>

<p>기본적으로 리니어 백그라운드는 엘리먼트의 위에서부터 아래로 전이된다. 그 방향은 색상 값 앞에 키워드나 각도(degree) 값을 사용하여 변경할 수 있다. 예를 들어 왼쪽에서 오른쪽으로 전이시키려면 <code>to right</code> 키워드 값을 사용하며, 좌상에서 우하로 전이시키려면 <code>to bottom right</code> 키워드 값을 사용한다.</p>

<pre><code>div {
  background: linear-gradient(to bottom right, #a1e048, #6a942f);
}
</code></pre>

<p>대각선 그라디언트를 사용할 때 엘리먼트가 정확하게 사각형이 아니라면 그라디언트는 한 구석에서 다른 쪽으로 직접 진행되지 않을 것이다. 대신에 그라디언트는 엘리먼트의 정중앙을 확인할 것이고 진행되야 할 곳으로부터 수식 코너에 닻을 내릴 것이다. 그리고 그 값 안에서 윤곽된 구성으로 움직일 것이다. 그라이디언트가 향하는 구석을 “magic corners”라 부르지만 절대적인 것은 아니다. 에릭 마이어가 <a href="http://meyerweb.com/eric/thoughts/2012/04/26/lineargradient-keywords/">outlining this syntax</a>란 훌륭한 작업을 했다.</p>

<p>키워드에 더해 degree 값을 사용할 수도 있으며, <code>left top</code>에서 부터 그라디언트가 시작하길 원하면 <code>315deg</code> 값을 사용할 수 있다.</p>

<blockquote>
  <h4 id="old-linear-gradient-keyword-syntax">Old Linear Gradient Keyword Syntax</h4>

  <p>예전엔 리니어 그라디언트의 키워드 문법은 <code>to</code> 키워드를 사용하지 않았다. 키워드(들)를 선언하는 대신 그라디언트의 시작점을 선언하였고 그 반대방향으로 진행되었다. 위의 대각선 리니어 그라디언트 예제에서 예전 문법은 <code>to bottom right</code>가 아닌 <code>top left</code>가 될 것이다.
<br /><br />
새로운 키워드 문법으로 다른 브라우저들 사이에서 지원될 수 있게 되었다. 새로운 문법이 작동되지 않으면 예전 문법이 작동되는지 확인해볼 필요가 있다. 그러나, 곧 업데이트되야 할 것이라는 것을 염두에 두어라.</p>
</blockquote>

<h3 id="radial-gradient-background">Radial Gradient Background</h3>

<p>리니어 그라디언트는 한 방향으로 퍼지는 그라디언트를 만들기엔 완벽하지만 종종 radial 그라디언트에 대한 요구도 있다. 리니어 백그라운드와 유사하지만 위치, 크기, 반경 값 등으로 좀 더 복잡할 수 있다. 여기선 기본적인 것만 다루고 <a href="http://dev.opera.com/articles/view/css3-radial-gradients/">여기서</a> 좀 더 깊게 살펴 볼 수 있다.</p>

<pre><code>div {
  background: #70bf32;
  background: url('radial-gradient.png') 50% 50% no-repeat;
  background: radial-gradient(circle, #a1e048, #6a942f);
}
</code></pre>

<blockquote>
  <h4 id="css3-gradient-background-generator">CSS3 Gradient Background Generator</h4>

  <p>CSS3 그라디언트를 직접 프로그래밍하는 것은 숙달하지 않으면 꽤 힘든 작업이다. 다행히 <a href="http://ie.microsoft.com/testdrive/graphics/cssgradientbackgroundmaker/default.html">CSS3 그라디언트 제너레이터</a>와 같은 것들이 나타났다. 제너레이터들마다 약간 다르게 동작하지만 어떤 것은 프리셋과 예제가 있고, 어떤 것은 확장할 수 있는 옵션 목록을 가지고 있다. 관심이 있다면 필요에 맞는 적절한 제너레이터를 조사해볼 것을 추천한다.</p>
</blockquote>

<h3 id="gradient-background-stops">Gradient Background Stops</h3>

<p>지금까지 하나의 색상에서 다른 색으로 전이되는 그라디언트에 관해 논의했으나, 두 가지 이상의 색상에서 전이되길 원하면 “color stop”을 사용할 수 있다. 두 개의 색상값을 선언하는 대신에 여러 개의 값을 선언할 수 있으며, 차례대로 하나에서 다음 색으로 전이할 것이다. 컬러 스톱에 길이 값을 추가하면 전이의 위치와 길이가 결정된다. 길이값이 선언되지 않으면 그라디언트는 선언된 모든 색상 사이에 평등하게 전이될 것이다.</p>

<pre><code>div {
  background: #6c9730;
  background: url('linear-gradient-stops.png') 0 0 repeat-y;
  background: linear-gradient(left, #8dc63f, #d8ad45, #3b4b94);
}
</code></pre>

<h3 id="navigation-background-example">Navigation Background Example</h3>

<h6 id="html-1">HTML</h6>

<pre><code>&lt;ul&gt;
  &lt;li class="play"&gt;&lt;a href="#"&gt;Play&lt;/a&gt;&lt;/li&gt;
  &lt;li class="back"&gt;&lt;a href="#"&gt;Skip Backward&lt;/a&gt;&lt;/li&gt;
  &lt;li class="stop"&gt;&lt;a href="#"&gt;Pause/Stop&lt;/a&gt;&lt;/li&gt;
  &lt;li class="forward"&gt;&lt;a href="#"&gt;Skip Forward&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<h6 id="css-1">CSS</h6>

<pre><code>ul {
  background: #f4f4f4;
  background: linear-gradient(#fff, #eee);
  border: 1px solid #ccc;
  border-radius: 6px;
  display: inline-block;
  height: 22px;
  list-style: none;
  margin: 0 0 20px 0;
  padding: 0 4px 0 0;
}
li {
  height: 16px;
  float: left;
  padding: 3px;
  text-indent: -9999px;
  width: 16px;
}
.play {
  background: #f4f4f4;
  background: linear-gradient(#fff, #eee);
  border: 1px solid #ccc;
  border-radius: 30px;
  left: -4px;
  padding: 7px;
  position: relative;
  top: -5px;
}
li a {
  background: url('controls.png') 0 0 no-repeat;
  display: block;
  height: 16px;
  width: 16px;
}
.play a:hover {
  background-position: 0 -16px;
}
.back a {
  background-position: -16px 0;
}
.back a:hover {
  background-position: -16px -16px;
}
.stop a {
  background-position: -32px 0;
}
.stop a:hover {
  background-position: -32px -16px;
}
.forward a {
  background-position: -48px 0;
}
.forward a:hover {
  background-position: -48px -16px;
}
</code></pre>

<h4 id="demo-1">Demo</h4>
<ul>
  <li><a href="http://jsfiddle.net/nolboo/yTM63/">jsfiddle 링크</a></li>
</ul>

<h2 id="multiple-background-images-with-css3">Multiple Background Images with CSS3</h2>

<p>예전엔 하나의 엘리먼트에 한 개 이상의 백그라운드를 원한다면 또다른 엘리먼트로 감싸고 그 엘리먼트에 백그라운드를 할당해야 했다. 이것 때문에 백그라운드를 추가하는 단순한 사용으로도 코드가 비대해지곤 했다. CSS3에선 백그라운드 값들을 연달아(chain) 선언하여 하나의 엘리먼트에 여러 개의 백그라운드 이미지를 사용할 수 있다.</p>

<pre><code>div {
  background:
    url('foreground.png') no-repeat 0 0,
    url('middle-ground.png') no-repeat 0 0,
    url('background.png') no-repeat 0 0;
}
</code></pre>

<p><code>background</code> 속성 값을 연달어 선언할 수 있을 뿐아니라, <code>background-repeat</code>, <code>background-position</code>와 같은 다른 백그라운드 관련 속성들도 연달아 선언할 수 있다.</p>

<h3 id="multiple-background-images-example">Multiple Background Images Example</h3>

<h6 id="html-2">HTML</h6>

<pre><code>&lt;div&gt;Dinosaur with Grass and Clouds&lt;/div&gt;
</code></pre>

<h6 id="css-2">CSS</h6>

<pre><code>div {
  background: 
    url('dyno.png') no-repeat 380px 18px, 
    url('grass.png') no-repeat 0 100%, 
    url('sky.jpg') no-repeat 0 0;
  border-radius: 6px;
  height: 200px;
}
</code></pre>

<h4 id="demo-2">Demo</h4>
<p><a href="http://jsfiddle.net/nolboo/vtgqy/">Dinosaur with Grass and Clouds</a></p>

<h2 id="new-css3-background-properties">New CSS3 Background Properties</h2>

<p>그라디언트 백그라운드와 여러 개의 백그라운드 이미지와 함께 <code>background-size</code>, <code>background-clip</code>, <code>background-origin</code>의 세 가지 새로운 CSS 속성이 추가되었다.</p>

<h3 id="css3-background-size">CSS3 Background Size</h3>

<p><code>background-size</code> 속성은 백그라운드 이미지에 특정한 크기를 줄 수 있다. 선언되는 첫번째 값은 이미지의 너비이며, 두번째 값은 높이이며, 어떠한 길이 값이나 키워드도 사용할 수 있다. 만약 하나의 값만 선언된다면 적절한 이미지 비율을 유지해주는 <code>auto</code> 키워드가 사용된다.</p>

<pre><code>div {
  background: url('shay.jpg') 0 0 no-repeat;
  background-size: 85% auto;
  border: 1px dashed #8c9198;
  height: 240px;
  width: 200px;
}
</code></pre>

<blockquote>
  <h4 id="cover--contain-values">Cover &amp; Contain Values</h4>

  <p><code>cover</code> 키워드 값은 (백그라운드가) 엘리먼트 전체를 완전히 덮는 비율적 크기로 재조정되어야 한다. 백그라운드를 얼마나 재조정하느냐는 백그라운드와 엘리먼트의 차원(dimension)에 달려있다. 백그라운드는 비율적으로 차원을 가지지만 이미지 퀄리티(질)는 다소간 왜곡되게 재조정될 수 있다. 항상 작업을 체크하라.<br /><br /></p>

  <p><code>contain</code> 키워드 값은 엘리먼트의 경계 범위 안에 백그라운드 이미지를 비율적 크기로 재조정할 것이다. 이것은 엘리먼트의 일부분이 백그라운드가 없는 것을 의미하지만, 전체 백그라운드 이미지는 보여진다. <code>cover</code> 키워드 값처럼 백그라운드 이미지의 크기 재조정은 이미지의 차원에 비율적일 것이나 이미지는 왜곡될 수 있다.</p>
</blockquote>

<p>역자참조링크 : </p>

<ul>
  <li><a href="http://dolly77.tistory.com/entry/CSS3-backgroundsize-%EC%86%8D%EC%84%B1%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0">background-size 속성 알아보기</a></li>
  <li><a href="http://blog.naver.com/PostView.nhn?blogId=poppymanye&amp;logNo=60161713731">background-size 속성 사용법</a></li>
</ul>

<h3 id="css3-background-clip--background-origin">CSS3 Background Clip &amp; Background Origin</h3>

<p><code>background-clip</code> 속성은 백그라운 이미지가 적용되는 영역을 지정하며, <code>background-origin</code> 속성은 <code>background-position</code>이 어디서부터 시작되는지 지정한다. 이 두 속성이 도입되면서 <code>border-box</code>, <code>padding-box</code>, <code>content-box</code>의 세 값이 포함되었으며, 각각 <code>background-clip</code>과 <code>background-origin</code> 속성값으로 사용될 수 있다.</p>

<pre><code>div {
  background: url('shay.jpg') 0 0 no-repeat;
  background-clip: padding-box;
  background-origin: border-box;
}
</code></pre>

<p><strong>Fig. 5.03</strong> The <code>border-box</code> 값은 엘리먼트의 경계선안까지 확장된다.
<img src="http://learn.shayhowe.com/assets/courses/html-css-guide/backgrounds-gradients/border-box.png" alt="Border Box Value" /></p>

<p><strong>Fig. 5.04</strong> <code>padding-box</code> 값은 엘리먼트의 패딩 안까지 확장되지만, 경계선 안까지만 포함된다.
<img src="http://learn.shayhowe.com/assets/courses/html-css-guide/backgrounds-gradients/padding-box.png" alt="Padding Box Value" /></p>

<p><strong>Fig. 5.05</strong> <code>content-box</code> 값은 엘리먼트의 경계선과 패딩 안까지 포함된다.
<img src="http://learn.shayhowe.com/assets/courses/html-css-guide/backgrounds-gradients/content-box.png" alt="Content Box Value" /></p>

<h2 id="resources--links">Resources &amp; Links</h2>

<ul>
  <li><a href="http://www.slideshare.net/maxdesign/css3-backgrounds">CSS3 Background</a> via Russ Weakley</li>
  <li><a href="http://dev.opera.com/articles/view/css3-linear-gradients/">CSS3 Linear Gradients</a> via Dev.Opera</li>
  <li><a href="http://dev.opera.com/articles/view/css3-radial-gradients/">CSS3 Radial Gradients</a> via Dev.Opera</li>
  <li><a href="http://ie.microsoft.com/testdrive/graphics/cssgradientbackgroundmaker/default.html">CSS Gradient Background Maker</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML & CSS 초보자 가이드 - 4강 : Typography]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/beginners-guide-to-html-and-css-4-slash-10/"/>
    <updated>2013-07-22T21:08:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/beginners-guide-to-html-and-css-4-slash-10</id>
    <content type="html"><![CDATA[<p>원본 : <a href="http://learn.shayhowe.com/html-css/typography">A Beginner’s Guide to HTML &amp; CSS - LESSON 4 : Typography”</a></p>

<p>웹 타이포그래피는 최근 몇년 동안 지속적으로 성장해왔다. 이러한 대중적 성장은 몇 가지 이유가 있지만, 웹 사이트에 자신의 웹 폰트를 (얼마나 쉽게) 적용(emded)할 수 있는가가 가장 큰 이유이다.</p>

<p>역자참조링크 : </p>

<ul>
  <li><a href="http://ko.wikipedia.org/wiki/%ED%83%80%EC%9D%B4%ED%8F%AC%EA%B7%B8%EB%9E%98%ED%94%BC">타이포그래피</a></li>
  <li><a href="http://ko.wikipedia.org/wiki/%EC%BA%98%EB%A6%AC%EA%B7%B8%EB%9E%98%ED%94%BC">캘리그래피</a></li>
  <li><a href="http://ko.wikipedia.org/wiki/%EB%82%99%EC%84%9C">그라피티</a></li>
</ul>

<p>과거엔 웹사이트에 사용할 수 있는 타입페이스(글꼴)의 수가 작고 한정되어 있었다. 이러한 글꼴들은 컴퓨터에 공통적으로 설치되어 화면에 적절하게 표현된다. 최근에는 임베딩 폰트를 사용할 수 있어 디자이너들이 휠씬 많은 글꼴을 선택할 수 있다.
<!-- more -->
폰트 임베딩의 문이 새로운 글꼴들에 활짝 열리면서 디자이너들에게 타이포그래피의 기본적인 원칙을 아는 것이 필요하게 되었다. 이러한 기본 원칙을 HTML과 CSS로 변환하는 것은 온라인 타이포그래피와 <a href="http://dev.opera.com/articles/view/29-text-styling-with-css/">텍스트 스타일링</a>의 핵심에 기여한다.</p>

<blockquote>
  <h4 id="typeface-vs-font">Typeface vs. Font</h4>
  <p><br /></p>

  <p>타입페이스와 폰트는 자주 혼용해서 사용되기 때문에 혼선을 준다. 아래에 각 용어가 무엇을 뜻하는지와 두 용어가 어떻게 사용되어 컨텍스트를 더하는지 적었다.<br /><br /></p>

  <p><strong>typeface</strong> 는 보이는 것이다. 문자가 어떻게 보이고, 느끼고, 읽히는지에 대한 예술적 인상이다.<br /><br /></p>

  <p><strong>font</strong> 는 타입페이스를 포함하는 화일이다. 컴퓨터에서 하나의 폰트를 사용하는 것은 컴퓨터가 그 타입페이스에 접근할 수 있는 것이다.<br /><br /></p>

  <p>타입페이스와 폰트의 차이는 <a href="http://fontfeed.com/archives/font-or-typeface/" title="Font or Typeface?">노래와 MP3</a>의 차이와 같다. 타입페이스는 예술 작품이라는 측면에서 노래와 매우 유사하다. 한 명의 아티스트나 아티스트들에 의해 만들어지고 해석은 열려있다. 반면에 폰트는 예술적 감상이 아닌 예술적 가치를 전달하는 방법이라는 측면에서 MP3와 매우 유사하다.</p>
</blockquote>

<h2 id="formatting-content">Formatting Content</h2>

<h3 id="headings">Headings</h3>

<p><code>h1</code>은 가장 중요한 헤딩이며 나머지 <code>h2</code>~<code>h6</code>는 <code>h1</code>을 지원하고 필요에 따라 여러 번 사용할 수 있다.</p>

<h3 id="paragraphs">Paragraphs</h3>

<p>단락마다 <code>p</code> 태그로 둘러싸인 컨텐츠</p>

<h3 id="bolding-text">Bolding Text</h3>

<p><code>strong</code> 엘리먼트는 텍스트를 굵은체로 만들 뿐아니라 문맥적으로도 중요한 텍스트임을 알린다.</p>

<h3 id="italicizing-text">Italicizing Text</h3>

<p><code>em</code> 엘리먼트는 텍스트를 기울임체로 만들어 주고 문맥적으로 강조된 중요성을 의미한다.</p>

<h2 id="text-color">Text Color</h2>

<p>디자이너나 개발자가 웹사이트를 만들 때 일반적으로 제일 먼저 하는 것이 텍스트 색상과 글꼴을 고르는 것이다. 페이지의 외관이란 측면에서 이 두 가지는 가장 적은 시간에 가장 큰 효과를 줄 수 있다. 브라우저의 디폴트 값을 제거하고 자신만의 텍스트 색상과 글꼴을 사용하여 즉시 페이지의 기조를 정하게 된다.</p>

<p>텍스트 색상을 지정할 때 필요한 유일한 것은 <code>color</code> 속성이다. <code>color</code> 속성은 하나의 값만 허용된다. 그러나, 형식은 여러가지가 사용되며, 키워드, 16진값, RGB, RGBa, HSL, HSLa 등이 있다. 가장 많이 볼 수 있는 것은 최소의 노력으로 가장 큰 조작을 할 수 있는 16진값(<a href="http://www.quackit.com/css/css_color_codes.cfm">hexadecimal</a>)이다.</p>

<p>RGBa값은 투명 색상을 제공하기 때문에 CSS3와 함께 부상하고 있으나, 모든 브라우저에서 지원되지 않기 때문에 16진값 대체(fallback)과 적절하게 사용되어야 한다.</p>

<pre><code>body {
  color: #555;
}
</code></pre>

<blockquote>
  <h4 id="shorthand-hexadecimal-color-values">Shorthand Hexadecimal Color Values</h4>

  <p>16진 색상 값은 숏핸드 값을 사용할 수 있다. 16진 색상은 파운드 기호(#)와 뒤따르는 6개의 문자로 선언된다. 이 문자들은 첫 두 글자, 중간 두 글자, 마지막 두 글자로 두개의 문자씩 짝을 이루는 패턴을 가지고 사용되면서 각각 하나의 특정한 색상을 지정한다. 이러한 패턴은 6개에서 3개로 축약될 수 있다. 예를 들면 <code>#555555</code>는 <code>#555</code>로 축약될 수 있으며, <code>#ff6600</code>은 <code>#f60</code>으로, <code>#ffff00</code>은 <code>#ff0</code> 등으로 축약될 수 있다.</p>
</blockquote>

<h2 id="font-properties">Font Properties</h2>

<p>CSS는 텍스트의 룩앤픽을 편집할 수 있는 수많은 속성을 제공하며, 크게 <code>font</code> 기반 속성과 <code>text</code> 기반 속성의 두 가지 범주로 나뉜다. 이 범주의 대부분의 속성은 <code>font-*</code> 나 <code>text-*</code>로 접두될 것이다.</p>

<h3 id="font-family">Font Family</h3>

<p><code>font-family</code> 속성은 텍스트가 디스플레이될 때 사용되는 폰트와 대체 폰트를 선언한다. <code>font-family</code> 값은 <code>,</code>로 구분되는 여러 개의 폰트 이름을 포함한다. 가장 왼쪽에 선언된 첫번째 폰트는 가장 우선적인 폰트이다. 첫번째 폰트를 사용할 수 없다면 왼쪽에서 오른쪽 순으로 선언된 대체 폰트가 사용된다. 두 개이상의 단어로 된 폰트 이름은 인용부호로 감싸져야 한다. 가장 마지막 폰트는 특정 형식의 시스템 디폴트 폰트를 지칭하는 키워드 값이어야 한다.</p>

<pre><code>p {
  font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif;
}
</code></pre>

<h3 id="font-size">Font Size</h3>

<p><code>font-size</code> 속성은 픽셀, em, 퍼센트, 포인트, <code>font-size</code>  키워드 등의 <a href="http://css-tricks.com/css-font-size/">길이값</a>을 사용하여 텍스트의 크기를 지정할 수 있다. 픽셀 값이 점점 더 자주 사용되고 있다. 전에는 사용자가 브라우저 안의 페이지를 확대할 때 상대적으로 확장되는 em과 퍼센트 값이 꽤 인기가 있었다. 최근엔 대부분의 브라우저가 픽셀을 확장할 수 있기 때문에 em과 퍼센트 값을 사용할 필요가 없어졌다.</p>

<pre><code>p {
  font-size: 13px;
}
</code></pre>

<h3 id="font-style">Font Style</h3>

<p>텍스트를 기울이거나 그 반대로 하기위해 <code>font-style</code> 속성이 사용된다. <code>font-style</code> 속성은 <code>normal</code>, <code>italic</code>, <code>oblique</code>, <code>inherit</code> 4가지 키워드 값을 받아들이며, <code>normal</code>, <code>italic</code>이 가장 대중적으로 사용된다. <code>italic</code>은 텍스트를 이탤릭으로 지정할 때 <code>normal</code>은 보통으로 되돌릴 때 사용된다.</p>

<pre><code>p {
  font-style: italic;
}
</code></pre>

<h3 id="font-variant">Font Variant</h3>

<p>자주는 아니지만 때때로 텍스트를 작은 대문자로 지정할 필요가 있을 때 <code>font-variant</code> 속성을 사용한다. <code>font-variant</code> 속성은 <code>normal</code>, <code>small-caps</code>, <code>inherit</code>의 3가지 값을 허용한다. 타입페이스가 작은 대문자를 지원하지 않으면 아무런 변화가 없을 것이다. 이 속성을 이용하기 전에 타입페이스 지원여부를 체크해야한다.</p>

<pre><code>p {
  font-variant: small-caps;
}
</code></pre>

<h3 id="font-weight">Font Weight</h3>

<p>텍스트를 굵게하거나 굵은 정도를 지정할 때 <code>font-weight</code> 속성을 사용한다. 일반적으로 말하면 <code>font-weight</code> 속성은 <code>normal</code>, <code>bold</code>, <code>bolder</code>, <code>lighter</code>, <code>inherit</code>의 키워드 속성 값과 사용된다. 이 중 <code>bold</code>와 <code>normal</code>이 굵게 바꾸거나 보통으로 되돌릴 때 우선적으로 추천된다.</p>

<p>위의 키워드에 추가하여 <code>100</code>, <code>200</code>, <code>300</code>, <code>400</code>, <code>500</code>, <code>600</code>, <code>700</code>, <code>800</code>, <code>900</code>의 숫자 값이 있다. 굵은 정도를 나타내는 weight의 순서는 가장 가는 <code>100</code>에서 가장 두꺼운 <code>900</code>으로 확장된다. 이 값들은 normal (<code>400</code>)과 bold(<code>700</code>) 이상의 여러 weight를 값는 타입페이스와 특별히 관련되므로, 숫자 값을 사용하기 전에 타입페이스가 지원하는 것을 정확히 체크하라. 그렇지 않으면 작동하지 않을 수 있다.</p>

<pre><code>p {
  font-weight: bold;
}
</code></pre>

<h3 id="line-height">Line Height</h3>

<p>줄간격(leading)으로 알려진 두 텍스트 줄 사이의 거리는 <code>line-height</code> 속성으로 선언한다. 갸장 읽기 쉬운 <code>line-height</code>는 <code>font-size</code>의 1.5배이며 <code>line-height</code>를 150%로 설정하면 된다. 그러나, 그리드와 작업할 때는 <code>line-height</code>를 픽셀로 사용하는 것을 선호할 수 있다.</p>

<p><code>line-height</code>를 엘리먼트의 <code>height</code>와 같게 설정하면 텍스트가 수직적 중앙에 위치한다. 버튼, 알림 메시지, 한 줄 텍스트 블럭 등에서 흔히 볼 수 있다.</p>

<pre><code>p {
  line-height: 20px;
}
</code></pre>

<h3 id="shorthand-font-properties">Shorthand Font Properties</h3>

<p>위의 모든 폰트 기반 속성은 하나의 <code>font</code> 속성과 <a href="http://www.impressivewebs.com/css-font-shorthand-property-cheat-sheet/">숏핸드 값</a>으로 합칠 수 있다. 속성의 순서는 왼쪽부터 <code>font-style</code>, <code>font-variant</code>, <code>font-weight</code>, <code>font-size</code>, <code>line-height</code>, <code>font-family</code> 순이며, 컴마없이 나열한다.(폰트 이름들은 예외이며 컴마로 나열된다.) <code>font-size</code>와 <code>line-height</code> 속성값은 값 사이는 /로 나눈다.</p>

<p><code>font-size</code>와 <code>font-family</code> 속성값을 제외한 나머지 속성값은 선택적이기 때문에 <code>font-size</code>와 <code>font-family</code> 값만을 가진 <code>font</code> 속성을 종종 볼 수 있다.</p>

<pre><code>p {
  font: italic small-caps bold 13px/20px 'Helvetica Neue',
  Arial, Helvetica, sans-serif;
}
</code></pre>

<h3 id="font-properties-example">Font Properties Example</h3>

<h6 id="html">HTML</h6>

<pre><code>&lt;h2&gt;&lt;a href="#" title="Sample Blog Post Title"&gt;Sample Blog Post Title&lt;/a&gt;&lt;/h2&gt;

&lt;p class="byline"&gt;Posted by Shay Howe on February 5th, 2012&lt;/p&gt;

&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla fringilla vehicula nisi vitae rutrum. Donec laoreet, arcu in elementum, dui mi auctor tortor, et lorem massa orci… &lt;a href="#" title="Sample Blog Post Title"&gt;Continue reading →&lt;/a&gt;&lt;/p&gt;
</code></pre>

<h6 id="css">CSS</h6>

<pre><code>h2, p {
  color: #555;
  font: 13px/20px Arial, 'Helvetica Neue', 'Lucida Grande', sans-serif;
}
a {
  color: #8ec63f;
}
a:hover {
  color: #f7941d;
}
h2 {
  font-size: 22px;
  font-weight: bold;
  margin-bottom: 6px;
}
.byline {
  color: #8c8c8c;
  font-family: Georgia, Times, 'Times New Roman', serif;
  font-style: italic;
}
</code></pre>

<h2 id="text-properties">Text Properties</h2>

<p>이제 반 왔다.</p>

<h3 id="text-align">Text Align</h3>

<p>텍스트 정렬은 페이지의 리듬과 흐름을 만드는 중요한 부분이며, <code>text-align</code> 속성으로 지정한다. <code>left</code>, <code>right</code>, <code>center</code>, <code>justify</code>, <code>inherit</code>의 5가지 값을 갖는다. <code>text-align</code> 속성은 <code>float</code> 속성과 혼동하지 말아야 한다. <code>text-align</code>의 <code>left</code>와 <code>right</code> 값은 엘리먼트 안의 텍스트를 정렬하는 반면 <code>float</code>의 <code>left</code>와 <code>right</code> 값은 엘리먼트 전체를 이동시킨다.</p>

<pre><code>p {
  text-align: center;
}
</code></pre>

<h3 id="text-decoration">Text Decoration</h3>

<p><code>text-decoration</code> 속성은 텍스트를 치장해주며, <code>none</code>, <code>underline</code>, <code>overline</code>, <code>line-through</code>, <code>blink</code>, <code>inherit</code> 키워드 값을 갖는다. 가장 인기있는 사용법은 링크에 밑줄을 치는 것이다. <code>blink</code> 값은 극도로 어지럽히므로 추천하지 않는다. 시맨틱적으로 <code>line-though</code> 값은 문서에서 제거된 텍스트를 나타내는 <code>del</code> 엘리먼트와 정확하지않거나 상관없는 텍스트를 나타내는 <code>s</code> 엘리먼트 대신 사용될 수 있다.</p>

<pre><code>p {
  text-decoration: underline;
}
</code></pre>

<h3 id="text-indent">Text Indent</h3>

<p><code>text-indent</code> 속성은 텍스트를 안과 밖으로 들여쓸 수 있게 한다.</p>

<pre><code>p {
  text-indent: 20px;
}
</code></pre>

<h3 id="text-shadow">Text Shadow</h3>

<p><code>text-shadow</code> 속성은 텍스트에 하나 또는 여러 개의 그림자를 추가할 수 있게 한다. 4개의 값들이 왼쪽에서 오른쪽 순으로 나열되어야 한다. 처음 3개 값은 길이이며 마지막 값은 색상이다. 3개의 길이 값 중 첫번째는 그림자의 horizontal offset, 두번째는 vertical offset, 세번째는 blur radius를 결정한다. 네번째 즉, 마지막 값은 그림자의 색상이며, <code>color</code> 속성에서 사용되는 모든 컬러 값을 사용할 수 있다.</p>

<p>여러 개의 텍스트 그림자들은 컴마로 구분된다.</p>

<pre><code>p {
  text-shadow: 0 1px 0 rgba(0, 0, 0, 0.3);
}
</code></pre>

<h3 id="text-transform">Text Transform</h3>

<p><code>text-transform</code>은 <code>font-variant</code> 속성과 유사하다. <code>font-variant</code>는 타입페이스의 작은 대문자를 가져오지만 <code>text-transform</code> 속성은 인라인으로 텍스트를 변경한다. <code>none</code>, <code>capitalize</code>, <code>uppercase</code>, <code>lowercase</code>, <code>inherit</code> 값을 갖는다.</p>

<p><code>capitalize</code> 값은 각 단어의 첫번째 글자를 대문자로 만들고, <code>uppercase</code> 값은 모든 글자를 대문자로 만들며, <code>lowercase</code>는 모든 문자를 소문자로 만든다. <code>none</code>은 상속되는 값을 없애고 디폴트 값으로 되돌린다.</p>

<pre><code>p {
  text-transform: uppercase;
}
</code></pre>

<h3 id="letter-spacing">Letter Spacing</h3>

<p><code>letter-spacing</code> 속성으로 페이지의 글자 간격을 조정할 수 있다. <code>none</code> 속성은 자간을 보통 거리로 되돌린다.</p>

<pre><code>p {
  letter-spacing: -.5em;
}
</code></pre>

<p>역자참조링크 : </p>

<ul>
  <li><a href="http://j.mp/17oGhiK">1em은 현재 사용되는 글꼴의 16포인트 크기의 대문자 “M”의 넓이</a></li>
</ul>

<h3 id="word-spacing">Word Spacing</h3>

<p>단어들의 간격을 조정할 수 있다.</p>

<pre><code>p {
  word-spacing: .25em;
}
</code></pre>

<h3 id="text-properties-example">Text Properties Example</h3>

<h6 id="html-1">HTML</h6>

<pre><code>&lt;h2&gt;&lt;a href="#" title="Sample Blog Post Title"&gt;Sample Blog Post Title&lt;/a&gt;&lt;/h2&gt;

&lt;p class="byline"&gt;Posted by Shay Howe on February 5th, 2012&lt;/p&gt;

&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla fringilla vehicula nisi vitae rutrum. Donec laoreet, arcu in elementum, dui mi auctor tortor, et lorem massa orci… &lt;a href="#" title="Sample Blog Post Title"&gt;Continue reading →&lt;/a&gt;&lt;/p&gt;
</code></pre>

<h6 id="css-1">CSS</h6>

<pre><code>h2, p {
  color: #555;
  font: 13px/20px Arial, 'Helvetica Neue', 'Lucida Grande', sans-serif;
}
a {
  color: #8ec63f;
}
a:hover {
  color: #f7941d;
}
h2 {
  font-size: 22px;
  font-weight: bold;
  letter-spacing: -.9px;
  margin-bottom: 6px;
}
h2 a {
  text-shadow: 1px 1px 0 #75a334;
}
h2 a:hover {
  text-shadow: 1px 1px 0 #d48019;
}
p {
  text-indent: 15px;
}
.byline {
  color: #8c8c8c;
  font-family: Georgia, Times, 'Times New Roman', serif;
  font-style: italic;
  text-indent: 0;
}
p a {
  font-size: 11px;
  font-weight: bold;
  text-decoration: underline;
  text-transform: uppercase;
}
</code></pre>

<h2 id="web-safe-fonts">Web Safe Fonts</h2>

<p>모든 컴퓨터, 태블릿, 폰 혹은 브라우징이 가능한 기기에는 디폴트로 미리 설치된 몇 개의 특정 폰트들이 있다. 모든 기기에 설치되면 폰트들은 온라인에서 무료로 사용될 수 있으며 브라우저 기기와 상관없이 적절하게 보여질 것이다. 이러한 폰트들이 “web safe fonts.”이다. 그 목록은 아래와 같다.</p>

<ul>
  <li>Arial</li>
  <li>Courier New, Courier</li>
  <li>Garamond</li>
  <li>Georgia</li>
  <li>Lucida Sans, Lucida Grande, Lucida</li>
  <li>Palatino Linotype</li>
  <li>Tahoma</li>
  <li>Times New Roman ,Times</li>
  <li>Trebuchet</li>
  <li>Verdana</li>
</ul>

<h2 id="embedding-web-fonts">Embedding Web Fonts</h2>

<p>최근에 web safe fonts에 대한 대안이 뜨고있다. 이제는 폰트를 서버에 업로드하여 CSS <code>@font-face</code> 속성을 통해 웹사이트에 포함시킬 수 있다. 이것은 온라인 타이포그래피에 경이로운 일이며, 이제 활자가 온라인으로 올라왔다.</p>

<pre><code>@font-face {
  font-family: 'Bryant Normal';
  src: url('bryant-normal.eot');
  src: url('bryant-normal.eot') format('embedded-opentype'),
       url('bryant-normal.woff') format('woff'),
       url('bryant-normal.ttf') format('truetype'),
       url('bryant-normal.svg') format('svg');
}
body {
  font-family: 'Bryant Normal', 'Helvetica Neue', Arial, Helvetica, sans-serif;
}
</code></pre>

<p>그러나 몇 가지 작은 함정이 있다. 웹사이트에 모든 타입페이스를 사용할 수 있다는 것이 합법적인 권리를 승인받았다는 것을 의미하지는 않는다. 타입페이스는 예술 작품이므로 그것을 라이센스 없이 서버에 올릴 수 없다.</p>

<p>다행히 새로운 타입페이스의 가치가 인식되고 회사들이 웹사이트에 새로운 폰트들을 라이센스하여 포함할 수 있도록 하고 있다. <a href="https://typekit.com/">Typekit</a>과 <a href="http://fontdeck.com/">Fontdeck</a>과 같은 회사들은 폰트 라이센싱을 서브스크립션 모델로 팔고있고, <a href="http://www.google.com/webfonts">Google Fonts</a>는 무료로 폰트를 라이센싱하고 있다.</p>

<p>또 다른 함정은 브라우저 지원이다. <code>@font-face</code> 속성은 오래된 브라우저에서 지원되지 않을 수 있다. 다행히 폰트를 사용할 때 <code>font-family</code> 속성에서 대체 폰트를 지정할 수 있다.</p>

<h2 id="citations-amp-quotes">Citations &amp; Quotes</h2>

<p><code>cite</code>, <code>q</code>, <code>blockquote</code> 엘리먼트를 사용한다.</p>

<p><code>cite</code> 엘리먼트는 a title of work를 참조할 때 사용되고, <code>q</code> 엘리먼트는 짧은 인라인 인용에, <code>blockquote</code>는 더 길고 외부 인용에 사용된다.</p>

<h3 id="citing-a-title-of-work">Citing a Title of Work</h3>

<p><code>cite</code> 엘리먼트는 <code>cite</code> 속성과 혼동하지 말아야 한다. <strong>element</strong>는 시맨틱 문맥을 제공하고 <strong>attribute</strong>는 참조 소스로서 URI 값을 가진다. <code>cite</code> 엘리먼트는 특별히 a title of work을 위해 예약되어 있으며 소스와 관련된 다른 컨텍스트를 포함하지 말아야 한다. A title of work는 하나의 책, 영화, 노래 등이다. 관련된 원본 소스의 하이퍼링크를 포함할 수 있다.</p>

<pre><code>&lt;p&gt;&lt;cite&gt;&lt;a href="http://www.amazon.com/Steve-Jobs-Walter-Isaacson/dp/1451648537" title="Steve Jobs"&gt;Steve Jobs&lt;/a&gt;&lt;/cite&gt; by Walter Isaacson is truly inspirational.&lt;/p&gt;
</code></pre>

<blockquote>
  <h4 id="citing-a-title-of-work-demo">Citing a Title of Work Demo</h4>

  <p><a href="http://www.amazon.com/Steve-Jobs-Walter-Isaacson/dp/1451648537">Steve Jobs</a> by Walter Isaacson is truly inspirational.</p>
</blockquote>

<h3 id="dialog-amp-prose-quotation">Dialog &amp; Prose Quotation</h3>

<p><code>q</code> 엘리먼트는 대화나 문장을 시맨틱하게 지정할 때 사용되며 다른 인용 목적으로 사용되지 말아야 한다.</p>

<pre><code>&lt;p&gt;Steve Jobs once said, &lt;q&gt;“One home run is much better than two doubles.”&lt;/q&gt;&lt;/p&gt;
</code></pre>

<h3 id="dialog-amp-prose-citation">Dialog &amp; Prose Citation</h3>

<p><code>q</code> 엘리먼트에서 선택적으로 사용하는 속성은 <code>cite</code> 속성이다. <code>cite</code> 속성은 URI를 인용부호로 감싸는 형태이다. 이 속성은 엘리먼트의 외양을 변화시키지 않으며, 단순히 스크린 리더와 같은 기기에 가치를 제공한다. 속성은 브라우저 내에서 볼 수 없기 때문에 가능하다면 소스를 포함한 하이퍼링크를 제공하는 것이 추천된다.</p>

<pre><code>&lt;p&gt;&lt;a href="http://www.businessweek.com/magazine/content/06_06/b3970001.htm" title="Steve Jobs' Magic Kingdom"&gt;Steve Jobs&lt;/a&gt; once said, &lt;q cite="http://www.businessweek.com/magazine/content/06_06/b3970001.htm"&gt;“One home run is much better than two doubles.”&lt;/q&gt;&lt;/p&gt;
</code></pre>

<h3 id="external-quotation">External Quotation</h3>

<p>커다란 텍스트 블럭을 인용하기 위해, 외부 소스와 여러 줄을 차지하는 <code>blockquote</code> 엘리먼트가 사용된다. <code>blockquote</code>는 헤딩과 단락 등의 다른 블럭 레벨 엘리먼트를 포함할 수 있는 블럭 레벨 엘리먼트이다.</p>

<pre><code>&lt;blockquote&gt;
  &lt;p&gt;“In most people’s vocabularies, design is a veneer. It’s interior decorating. It’s the fabric of the curtains, of the sofa. But to me, nothing could be further from the meaning of design. Design is the fundamental soul of a human-made creation that ends up expressing itself in successive outer layers of the product.”&lt;/p&gt;
  &lt;p&gt;— Steve Jobs in Fortune Magazine&lt;/p&gt;
&lt;/blockquote&gt;
</code></pre>

<h3 id="external-citation">External Citation</h3>

<p><code>blockquote</code> 엘리먼트 안에서 사용된 긴 인용들은 항상 인용처를 포함해야 한다. 이 인용처는 저자와 소스처럼 지극히 단순할 수 있으나 여러 개의 인용처와 추가 적인 레퍼런스를 위한 링크를 포함하는 훨씬 많은 정보일 수 있다.</p>

<p><code>cite</code> 속성은 <code>blockquote</code> 엘리먼트 안에 포함될 수 있으며, <code>cite</code> 엘리먼트는 인용문 다음에 위치하여 관련된 title of work을 지정하는 것을 도울 수 있다.</p>

<p><code>cite</code> 속성과 <code>cite</code> 엘리먼트는 순수하게 시맨틱하고 유저에게 어떠한 시각적인 참조를 추가하지 않기에 하이퍼링크가 선호된다. These hyperlinks should highlight both the origin of the quote (author, artist, etcetera) and the title of work in which it first appeared.</p>

<pre><code>&lt;blockquote cite="http://money.cnn.com/magazines/fortune/
fortune_archive/2000/01/24/272277/index.htm"&gt;
  &lt;p&gt;“In most people’s vocabularies, design is a veneer. It’s interior decorating. It’s the fabric of the curtains, of the sofa. But to me, nothing could be further from the meaning of design. Design is the fundamental soul of a human-made creation that ends up expressing itself in successive outer layers of the product.”&lt;/p&gt;
  &lt;p&gt;— &lt;a href="http://en.wikipedia.org/wiki/Steve_Jobs" title="Steve Jobs"&gt;Steve Jobs&lt;/a&gt; in &lt;cite&gt;&lt;a href="http://money.cnn.com/magazines/fortune/fortune_archive/2000/01/24/272277/index.htm" title="Apple's One-Dollar-a-Year Man"&gt;Fortune Magazine&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</code></pre>

<h4 id="automating-quotation-marks-with-css">Automating Quotation Marks with CSS</h4>

<p>HTML에 인용부호를 추가하기 보다는 CSS에서 자동으로 추가하는 방법이 있다. 예전에는 브라우저의 언어 지원 때문에 CSS에서 적절하게 표현되지 못했지만 최근 브라우저의 언어 지원이 더 좋아졌다.</p>

<p>아래는 <code>q</code> 엘리먼트에 <code>before</code>, <code>after</code> 가상엘리먼트와 속성을 이용하여 인용부호를 추가하는 방법이다. 좀 더 자세한 것은 <a href="http://css-tricks.com/pseudo-element-roundup/">가상 엘리먼트</a> 와 <a href="http://html5doctor.com/blockquote-q-cite/">인용부호 사용하는 방법</a>.</p>

<pre><code>q {
  quotes: '“' '”' '‘' '’';
}
q:before {
  content: '“';
  content: open-quote;
}
q:after {
  content: '”';
  content: close-quote;
}
</code></pre>

<h2 id="resources-amp-links">Resources &amp; Links</h2>

<ul>
  <li><a href="http://dev.opera.com/articles/view/29-text-styling-with-css/">Text styling with CSS</a> via Dev.Opera</li>
  <li><a href="http://html5doctor.com/blockquote-q-cite/">Quoting and citing with blockquote, q, cite, and the cite attribute</a> via HTML5 Doctor</li>
  <li><a href="http://www.impressivewebs.com/css-font-shorthand-property-cheat-sheet/">CSS Font Shorthand Property Cheat Sheet</a> via Impressive Webs</li>
  <li><a href="http://www.amazon.com/Elements-Typographic-Style-Robert-Bringhurst/dp/0881791326">The Elements of Typographic Style</a> by Robert Bringhurst</li>
</ul>

<h3 id="section">역자참조링크</h3>

<ul>
  <li><a href="http://www.creativebloq.com/typography/what-is-typography-123652">What is typography? Learn the basic rules and terms of type!</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML & CSS 초보자 가이드 - 3강 : Box Model & Positioning]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/beginners-guide-to-html-and-css-3-slash-10/"/>
    <updated>2013-07-22T21:08:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/beginners-guide-to-html-and-css-3-slash-10</id>
    <content type="html"><![CDATA[<p>원본 : <a href="http://learn.shayhowe.com/html-css/box-model">A Beginner’s Guide to HTML &amp; CSS - LESSON 3 : Box Model &amp; Positioning</a></p>

<p>HTML과 CSS를 완전히 이해하는데 필요한 하나의 원칙은 박스모델이다. </p>

<p><strong>“페이지의 모든 엘리먼트는 사각형 박스이다.”</strong></p>

<p>박스 모델을 이해하는 것은 어렵고 까다로울 수 있으나 일반적인 웹사이트를 만들기 위해서는 필요하다. 더불어 레이아웃을 만들기 위해, 페이지에 엘리먼트를 배치하는 방법을 아는 것도 똑같이 중요하다.
<!-- more --></p>

<h2 id="box-sizing">Box Sizing</h2>

<p>이전의 강의를 통해 페이지에 모든 엘리먼트는, 블럭이나 인라인 레벨이건, 모두 사각형 박스라는 것을 알았을 것이다. 박스는 다른 크기를 가질 수 있으며, 마진, 패딩, 경계선 등이 크기를 변경할 수도 있다. 이것들을 통틀어 <em>the box model</em> 이라 한다. 박스 모델의 한 예를 보자.</p>

<p>Fig. 3.01
<img src="http://learn.shayhowe.com/assets/courses/html-css-guide/box-model/square-elements.jpg" alt="" /></p>

<h2 id="the-box-model">The Box Model</h2>

<p>알다시피 모든 엘리먼트는 높이(height)와 너비(width)를 가지는 사각형 박스이며, 다른 마진(margin), 패딩(padding), 보더(boarder)로 구성되어 있다. 이 모든 값들이 합쳐져 <a href="http://css-tricks.com/the-css-box-model/">박스모델</a>을 만든다.</p>

<p>박스는 엘리먼트의 <code>height</code>와 <code>width</code>의 속성값을 주는 것으로 시작된다. <code>padding</code>과 <code>border</code>가 차례로 <code>height</code> 와 <code>width</code>를 둘러싼다. 그런 다음 <code>margin</code>이 <code>border</code>를 둘러싼다. 그러나, 마진은 박스의 실제 크기에는 포함되지 않으며, 박스모델을 정의하는 것에는 도움을 준다.</p>

<pre><code>div {
  background: #fff;
  border: 6px solid #ccc;
  height: 100px;
  margin: 20px;
  padding: 20px;
  width: 400px;
}
</code></pre>

<p>박스모델에서 엘리먼트의 전체 너비는 다음 공식을 사용한다:</p>

<p><code>margin-right</code> + <code>border-right</code> + <code>padding-right</code> + <code>width</code> + <code>padding-left</code> + <code>border-left</code> + <code>margin-left</code></p>

<p>엘리먼트의 전체 높이 공식은</p>

<p><code>margin-top</code> + <code>border-top</code> + <code>padding-top</code> + <code>height</code> + <code>padding-bottom</code> + <code>border-bottom</code> + <code>margin-bottom</code></p>

<p>Fig. 3.02 박스모델
<img src="http://learn.shayhowe.com/assets/courses/html-css-guide/box-model/box-model.png" alt="" /></p>

<p>공식을 사용하여 위 그림의 전체 높이와 너비를 계산하면</p>

<p><strong>Width</strong>: <code>492px</code> = <code>20px</code> + <code>6px</code> + <code>20px</code> + <code>400px</code> + <code>20px</code> + <code>6px</code> + <code>20px</code><br />
<strong>Height</strong>: <code>192px</code> = <code>20px</code> + <code>6px</code> + <code>20px</code> + <code>100px</code> + <code>20px</code> + <code>6px</code> + <code>20px</code></p>

<h2 id="height--width">Height &amp; Width</h2>

<p>모든 엘리먼트는 상속된 <code>height</code>와 <code>width</code>를 갖는다. 어떤 엘리먼트가 페이지의 레이아웃과 디자인에 핵심요소(key)가 된다면 특정한 <code>height</code>와 <code>width</code>가 필요할 것이고 이때 블럭 레벨 엘리먼트의 디폴트 값은 (새로 지정된 값으로) 덮어씌워질 것이다.(overrided)</p>

<p>역자참조링크 : <a href="http://www.clearboth.org/28_inheritance_and_cascade/">상속과 캐스케이딩</a></p>

<h3 id="css-height-property">CSS Height Property</h3>

<p>엘리먼트의 <code>height</code>의 디폴트 값은 컨텐츠에 의해 결정된다. 컨텐츠를 수용하기 위해 필요한 만큼 수직으로 늘어나거나 줄어들 것이다. 블럭 엘리먼트의 높이를 지정하기 위해는 <code>height</code> 속성이 사용된다.</p>

<pre><code>div {
  height: 100px;
}
</code></pre>

<h3 id="css-width-property">CSS Width Property</h3>

<p>엘리먼트의 <code>width</code>의 디폴트값은 보여지는 방식에 달려있다.
블럭 레벨 엘리먼트는 width = 100% 가 디폴트이며, 가능한 모든 너비를 차지한다. inline 엘리먼트는 컨텐츠가 차지하는 만큼 수평적으로 늘어나고 줄어든다. 인라인 레벨 엘리먼트는 정해진 값을 가질 수 없으므로,  <code>height</code> 속성처럼 <code>width</code> 속성은 블럭 레벨 엘리먼트와만 관계가 있다.</p>

<pre><code>div {
  width: 400px;
}
</code></pre>

<h2 id="margin--padding">Margin &amp; Padding</h2>

<p><code>margin</code> 과 <code>padding</code>은 브라우저마다 엘리먼트마다 가독성을 이유로 다른 디폴트 값을 가진다. 이러한 디폴트값을 모두 0로 맞추기 위해 제1강에서 <a href="http://learn.shayhowe.com/html-css/terminology-syntax-intro#reset">CSS reset</a>을 사용하는 것을 논의했다. </p>

<h3 id="css-margin-property">CSS Margin Property</h3>

<p><code>margin</code> 속성으로 엘리먼트를 둘러싼 여백의 크기를 정할 수 있다. 마진은 경계선(border)의 바깥에 위치하며 완전히 투명하다. 마진으로 페이지의 특정 위치에 엘리먼트가 배치되는 것을 돕거나 다른 엘리먼트가 충분한 거리를 두도록 여백만을 줄 수도 있다.</p>

<pre><code>div {
  margin: 20px;
}
</code></pre>

<h3 id="css-padding-property">CSS Padding Property</h3>

<p><code>padding</code> 속성은 <code>margin</code> 속성과 매우 유사하나 엘리먼트의 경계선(<code>border</code>)안에 위치한다. 패딩은 엘리먼트의 백그라운드를 상속한다. <code>margin</code> 속성은 엘리먼트를 배치하기 위한 것이지만 패딩은 엘리먼트 안의 여백을 제공한다.</p>

<pre><code>div {
  padding: 20px;
}
</code></pre>

<p>Fig. 3.03
<img src="http://learn.shayhowe.com/assets/courses/html-css-guide/box-model/margin-padding.png" alt="" /></p>

<h3 id="margin--padding-declarations">Margin &amp; Padding Declarations(선언)</h3>

<p><code>margin</code> 과 <code>padding</code> 값은 롱핸드와 숏핸드 형식으로 줄 수 있다. </p>

<p>엘리먼트의 네 변을 하나의 값으로 설정하거나 상하, 좌우, 상우하좌로 한번에 설정할 수 있다.(숏핸드)</p>

<pre><code>margin: 20px; 상하좌우 모두 20px
margin: 10px 20px; 상하 10px, 좌우 20px
margin: 10px 20px 0 15px; 상부터 시계 방향으로 상우하좌 순
</code></pre>

<p>한 개의 속성을 사용해서 한 번에 한 변의 값을 설정할 수 있다. 각 속성은 <code>margin</code> 혹은 <code>padding</code>으로 시작하며 -와 적용할 <code>top</code>, <code>right</code>, <code>bottom</code>, or <code>left</code> 으로 적용할 변을 뒤따라 지정한다. 예를 들어 <code>padding-left</code>는 엘리먼트의 왼쪽 패딩에 값을 적용한다.(롱핸드)</p>

<pre><code>div {
  margin-top: 10px;
  padding-left: 6px;
}
</code></pre>

<h2 id="borders">Borders(경계선)</h2>

<p>경계선은 <code>padding</code>과 <code>margin</code>사이에 위치하며, 엘리먼트 주위의 아웃라인을 제공한다. 모든 경계선은 너비, 스타일, 색상의 세가지 값이 필요하다. 숏핸드 값은 너비, 스타일, 색상 순으로 주어진다. 롱핸드의 경우 <code>border-width</code>, <code>border-style</code>, <code>border-color</code> 값으로 나뉘어진다.</p>

<p>대부분 단순한 사이즈, 실선, 한가지 색의 경계를 볼 수 있을 것이다. 그러나 <a href="http://www.quackit.com/html/codes/html_borders.cfm">수많은</a> 사이즈와 모양과 색상이 가능하다.</p>

<pre><code>div {
  border: 6px solid #ccc;
}
</code></pre>

<blockquote>
  <h4 id="length-value">Length Value</h4>

  <p>마진, 패딩, 경계선과 쓸 수 있는 <a href="https://developer.mozilla.org/en/CSS/length">길이 값</a>은 상대적인, 절대적인 값으로 여러 가지가 있다.
<br />
<br />
<strong>상대 값</strong>은 값이 적용되는 엘리먼트와 상관관계가 있다. <code>em</code>과 퍼센티지 등이 있다.
<br />
<br />
<strong>절대 값</strong>은 엘리먼트와 상관없이 측정 단위로 고정된다. 픽셀, 포인트, 인치, 센티미터 등이 있다.</p>
</blockquote>

<h2 id="floating-elements">Floating Elements</h2>

<p>박스모델로 엘리먼트의 모양새를 다듬는 것은 페이지 레이아웃을 코딩하는 전체에서 반을 차지한다. 나머지 반은 페이지의 다른 엘리먼트들을 적절하게 정렬하는 방법을 아는 것이다. 다른 엘리먼트 옆에 엘리먼트를 배치하는 방법 중 하나는 <code>float</code> 속성을 이용하는 것이다. <code>float</code> 속성은 엘리먼트들을 왼쪽과 오른쪽으로 연속으로 배치하게 한다.</p>

<p><strong>역자 링크</strong> : 역자는 <code>float</code> 개념이 처음에 많이 헷갈렸다. 그래서 도움을 얻을만한 글들을 몇 개 링크한다.^^</p>

<ul>
  <li><a href="http://celestarry.egloos.com/3595449">float 속성의 이해와 웹 페이지 레이아웃 잡기</a></li>
  <li><a href="http://tranbot.net/ALA/css-floats-101/">CSS 플로트 기초</a></li>
  <li><a href="http://techbug.tistory.com/181">CSS Float 속성의 모든것 (All About Floats)</a></li>
  <li><a href="http://naradesign.net/wp/2008/05/27/144/">float을 clear하는 4가지 방법</a></li>
  <li><a href="http://blog.wystan.net/2009/01/12/relationships-between-position-float-display">position, float, display 속성간의 관계</a></li>
</ul>

<p>블럭 엘리먼트인 <code>section</code>과 <code>aside</code>로 일반적인 페이지 레이아웃을 잡을 때 기본적으로는 수직적으로 쌓여버릴 것이다. 나란히 옆으로 배치하고 싶다면 각각 특정 <code>width</code>를 준 후에 하나는 왼쪽으로 다른 하나는 오른쪽으로 플로트하면 된다.</p>

<p>Fig. 3.04
<img src="http://learn.shayhowe.com/assets/courses/html-css-guide/box-model/floats.png" alt="" /></p>

<p><a href="http://coding.smashingmagazine.com/2007/05/01/css-float-theory-things-you-should-know/">엘리먼트를 플로팅</a>할 때 주목해야 할 몇가지 것들이 있다. 첫번째는 플로팅 엘리먼트가 부모 컨테이너의 가장자리에 붙어버린다는 것이다. 만약 부모 엘리먼트가 없다면 페이지의 가장자리에 붙어버릴 것이다. 추가적으로 하나의 엘리먼트를 폴로트하면 다른 엘리먼트는 페이지 흐름 안에서 자연스럽게 이어붙을 것이다.</p>

<pre><code>section {
  float: left;
  margin: 10px;
  width: 600px;
}
aside {
  float: right;
  margin: 10px;
  width: 320px;
}
</code></pre>

<h3 id="clearing-floated-elements">Clearing Floated Elements</h3>

<p>엘리먼트가 플로트될 때마다 페이지의 보통 흐름이 깨지고 다른 엘리먼트는 필요한대로 플로팅된 것 주위로 랩핑된다. 켄텐츠 옆에 이미지를 플로팅한 것과 같이 좋을 때도 있지만 때론 좋지 않다.</p>

<p>하나나 여러 개의 엘리먼트를 플로팅한 후 <code>clear</code> 속성을 이용하여 도큐먼트를 보통 흐름으로 되돌린다.</p>

<p>위의 예젱에서는 <code>section</code>과 <code>aside</code>를 플로트한 후 두 플로트된 엘리먼트 밑에 위치하는 <code>footer</code>에 클리어를 적용했다.</p>

<pre><code>footer {
  clear: both;
}
</code></pre>

<h2 id="positioning-elements">Positioning Elements</h2>

<p>플로팅하는 것 외에 엘리먼트를 정렬할 때 <code>position</code> 속성을 사용할 수도 있다. <code>position</code> 속성은 <a href="http://www.alistapart.com/articles/css-positioning-101/">다른 기능</a>을 하는 여러 값을 가진다.</p>

<p>디폴트 <code>position</code> 값은 <code>static</code>이다. <code>realtive</code> 값은 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code>과 같은 오프셋 값을 사용할 수 있다. <code>absolute</code>와 <code>fixed</code>는 <code>relative</code> 값을 가진 부모 엘리먼트와 함께 사용된다.</p>

<p>Fig. 3.05</p>

<p><img src="http://learn.shayhowe.com/assets/courses/html-css-guide/box-model/position.png" alt="" /></p>

<p>위의 예에서, <code>header</code> 엘리먼트는 고정된 엘리먼트로 동작하기 위해 <code>relative</code>로 배치되고, 그 안에 <code>absolute</code>로 배치되는 엘리먼트의 주된 컨테이너 역할을 한다. <code>ul</code> 엘리먼트는 <code>header</code> 엘리먼트의 위쪽과 오른쪽에서 <code>10px</code> 떨어진 절대 위치에 배치된다.</p>

<p>코드는 다음과 같을 것이다.</p>

<h6 id="html">HTML</h6>
<pre><code>&lt;header&gt;
  &lt;ul&gt;...&lt;/ul&gt;
&lt;/header&gt;
</code></pre>

<h6 id="css">CSS</h6>
<pre><code>header {
  position: relative;
}
ul {
  position: absolute;
  right: 10px;
  top: 10px;
}
</code></pre>

<h3 id="box-offset-properties">Box Offset Properties</h3>

<p>엘리먼트의 <code>position</code>이 <code>static</code>으로 설정되지 않는 한, 박스 오프셋 속성이 사용될 수 있다. 오프셋 값은 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 등이 있다.</p>

<p>예를 들면, <code>bottom: 32px;</code>은 <code>realtive</code> 배치 속성값을 가진 부모 엘리먼트의 바닥에서 32 픽셀에 위치될 것이다. 반대로 <code>bottom: -32px;</code>은 <code>realtive</code> 배치 속성값을 가진 부모 엘리먼트의 아래 32 픽셀에 위치될 것이다</p>

<blockquote>
  <h4 id="grids--frameworks">Grids &amp; Frameworks</h4>
  <p><br />
사이트의 레이아웃을 만들 때 고려하는 툴과 실제예는 셀 수없이 많다. 그 중 그리드와 프레임워크가 가장 선두에 있다.
<br />
<br />
<strong>Grid</strong>는 - vertical과 baseline 모두 - 웹사이트에 일련의 흐름을 더해주고 모든 것을 정렬하는 훌륭한 방법을 제공한다. 수년동안 인기있는 수십 개의 서로 다른 <a href="http://vandelaydesign.com/blog/design/resources-grid-based-design/">추천 그리드</a>가 있으며, 자신의 프로젝트에 가장 알맞는 것을 선택할 수 있다.
<br />
<br />
<strong>Framework</strong>는 미리 선정된 표준 세트를 바탕으로 웹사이트를 빠르게 만들 수 있는 방법을 제공한다. 프로젝트에 따라 프레임워크는 훌륭한 시작점을 제공하거나 완벽한 솔루션을 제공하기도 한다.</p>
</blockquote>

<h2 id="resources--links">Resources &amp; Links</h2>

<ul>
  <li><a href="https://developer.mozilla.org/en/CSS/length">CSS Length Values</a> via Mozilla Developer Network</li>
  <li><a href="http://www.quackit.com/html/codes/html_borders.cfm">HTML Borders</a> via Quackit.com</li>
  <li><a href="http://css-tricks.com/the-css-box-model/">The CSS Box Model</a> via CSS-Tricks</li>
  <li><a href="http://coding.smashingmagazine.com/2007/05/01/css-float-theory-things-you-should-know/">CSS Float Theory</a> via Smashing Magazine</li>
  <li><a href="http://www.alistapart.com/articles/css-positioning-101/">CSS Positioning 101</a> via A List Apart</li>
  <li><a href="http://vandelaydesign.com/blog/design/resources-grid-based-design/">Resources for Grid-Based Design</a> via Vandelay Design</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML & CSS 초보자 가이드 - 2강 : Elements & Semantics]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/beginners-guide-to-html-and-css-2-slash-10/"/>
    <updated>2013-07-22T21:07:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/beginners-guide-to-html-and-css-2-slash-10</id>
    <content type="html"><![CDATA[<p>원본 : <a href="http://learn.shayhowe.com/html-css/elements-semantics">A Beginner’s Guide to HTML &amp; CSS - LESSON 2 : Elements &amp; Semantics</a></p>

<p><br /><br />일단 코딩을 시작하게 되면 semantic 코딩을 반드시 원하게 될 것이다. semantic 코딩을 한다는 것은 코드를 잘 정리하고 풍부한 정보를 갖춘 결정도 할 수 있다는 것이다.</p>

<h2 id="semantics-overview-">Semantics Overview(시맨틱 개요)</h2>
<p><br /></p>

<p>HTML에서 <a href="http://boagworld.com/dev/semantic-code-what-why-how/">Semantics</a>는 페이지의 의미와 구조 위에 컨텐츠를 올려놓는 것이다. 페이지에서 컨텐츠의 <strong>가치</strong>를 표현하며, 스타일링 목적으로<strong>만 사용되진 않는다</strong>. semantic 코딩은 웹 페이지를 적절히 읽고 이해하는 능력을 컴퓨터, 스크린 리더, 검색엔진이나 다른 기기들에게 제공하는 등의 이점을 제공한다. 게다가 semnatic 코드는 각 컨텐츠의 특성을 명확하게 알  수 있어 관리하거나 일하는 것이 더 쉽다.
<!-- more -->
역자참고</p>

<ul>
  <li><a href="http://m.mkexdev.net/77">HTML5 : 의미있는 문서, 시맨틱(SEMANTIC) 요소</a></li>
  <li><a href="http://ko.wikipedia.org/wiki/%EC%8B%9C%EB%A7%A8%ED%8B%B1_%EC%9B%B9">시맨틱 웹</a></li>
</ul>

<h2 id="divisions--spans">Divisions &amp; Spans</h2>
<p><br /></p>

<p>div(division)와 span은 켄텐츠의 컨테이너로 작동되는 HTML 엘리먼트다. p(paragraph)는 단락을 나타내는 시멘틱 엘리먼트이지만 div와 span은 그런 의미를 가지지않는 단순한 컨테이너다. 그러나, CSS 스타일링을 세부적으로 지정할 수 있기 때문에 는 웹사이트 제작 시 매우 쓸모있는 것이다.</p>

<p>div는 웹 사이트의 큰 섹션을 정의하는 데에 주로 사용되는 블럭 엘리먼트이며, 레이아웃과 디자인을 만드는 것을 도와준다. 한편, span은 문단(p)과 같은 블럭 엘리먼트 안의 일부 텍스트 부분을 정의하는 데에 주로 사용되는 inline 엘리먼트다.</p>

<blockquote>
  <h4>Block vs. Inline Elements</h4>

  <p>모든 엘리먼트는 블럭 또는 inline 엘리먼트다. 그 차이점은?<br /><br /></p>

  <p><strong>블럭 엘리먼트</strong>는 페이지의 새로운 줄에 시작되며, 가능한 최대의 너비를 갖는다. inline 레벨 엘리먼트 뿐만 아니라 다른 블럭 엘리먼트도 포함할 수 있다.<br /><br /></p>

  <p><strong>inline 엘리먼트</strong>는 새로운 줄에서 시작되지 않으며, 문서의 흐름을 따르고 필요한 너비만을 가진다. 블럭 엘리먼트를 포함할 수 없으나 다른 inline 엘리먼트를 포함할 수는 있다.</p>
</blockquote>

<p>div와 span은 class나 id를 주어 값을 더해줄 수 있다. class와 id는 대체로 스타일링 목적으로 사용되거나 다른 div, span과의 차이를 나타낼 수 있다. 그러므로 클래스나 id 이름은 semantic하게 선택하는 것이 중요하다.</p>

<p>예를 들면, 오렌지 배경색를 가진 소셜미디어 링크를 “orange” 클래스로 이름을 주게되면, 나중에 배경색이 파란색으로 바뀌면 “orange” 클래스는 더 이상 의미가 없어진다. 좀 더 낫게 시멘틱한 클래스 이름은 <code>div</code> 스타일이 아닌 컨텐츠에 적합한 “social”이 될 것이다.</p>

<pre><code>&lt;!-- div --&gt;
&lt;div class="social"&gt;
  &lt;p&gt;Lorem ipsum dolor sit amet...&lt;/p&gt;
  &lt;p&gt;Lorem ipsum dolor sit amet...&lt;/p&gt;
&lt;/div&gt;

&lt;!-- span --&gt;
&lt;p&gt;Lorem ipsum dolor sit amet, &lt;span class="tooltip"&gt;consectetur&lt;/span&gt; elit.&lt;/p&gt;
</code></pre>

<h2 id="typography">Typography</h2>
<p><br /></p>

<p>온라인 컨텐츠의 아주 많은 부분은 문자 위주다.</p>

<h3 id="headings">Headings</h3>

<p>블럭 엘리먼트이며 <code>h1</code>~<code>h6</code>까지 6개이다. <code>h1</code>은 페이지나 섹션의 주 헤딩으로 쓰여야 하며, 보조적 헤딩으로 <code>h2</code>가 필요할 때 쓰여져야 한다. 텍스트를 굵게하거나 크게하기 위해 쓰여져서는 안된다.</p>

<pre><code>&lt;h1&gt;This is a Level 1 Heading&lt;/h1&gt;
&lt;h2&gt;This is a Level 2 Heading&lt;/h2&gt;
&lt;h3&gt;This is a Level 3 Heading&lt;/h3&gt;
</code></pre>

<blockquote>
  <p>#### Headings Demo</p>

  <h1 id="this-is-a-level-1-heading">This is a Level 1 Heading</h1>
  <p>## This is a Level 2 Heading
### This is a Level 3 Heading</p>
</blockquote>

<h3 id="paragraphs">Paragraphs</h3>

<p><code>p</code> 블럭 엘리먼트로 정의한다</p>

<h3 id="bold-text-with-strong">Bold Text with Strong</h3>

<p><code>strong</code>과 <code>b</code>는 모두 텍스트를 굵은체로 표시한다. 둘의 <a href="http://html5doctor.com/i-b-em-strong-element/">semantic 차이</a>를 이해하는 것이 중요하다. <code>strong</code>은 중요하여 강조하는 굵은 체이며, <code>b</code>는 스타일 상 굵은 체이나 항상 주목받는 텍스트는 아니다.</p>

<h3 id="italicize-text-with-emphasis">Italicize Text with Emphasis</h3>

<p><code>em</code>과 <code>i</code>의 차이도 거의 ditto다.</p>

<h2 id="hyperlinks">Hyperlinks(하이퍼링크)</h2>
<p><br /></p>

<p><code>a</code>(nchor) inline 엘리먼트로 정의되며 <code>href</code>(hyperlink reference)로 링크의 목적지를 정한다.</p>

<p>HTML5에서는 <code>a</code> inline 엘리먼트가 블럭 또는 inline 레벨 엘리먼트를 포함할 수 있게 되어, 페이지의 컨텐츠 블럭 전체를 링크할 수 있다.</p>

<h3 id="relative--absolute-paths-">Relative &amp; Absolute Paths(상대주소와 절대주소)</h3>

<p>링크의 일반적인 두가지 형태는 한 웹사이트 안에서 <em>다른 페이지</em>로의 링크와 <em>다른 웹사이트</em>로의 링크다.</p>

<p>같은 웹사이트 안의 다른 페이지로 링크를 <strong>상대주소</strong>라고 하며, <code>href</code> 속성값에 <code>/about.html</code>과 같이 도메인이 없다. 서브디렉토리를 지정하려면 <code>/page/about.html</code>과 같이 한다.</p>

<p>다른 웹사이트로 링크하려면 <strong>절대주소</strong>가 필요하며, <code>href</code> 속성값에 <code>http</code>와 <code>.com</code> 등의 전체 도메인이 포함되어야 한다.</p>

<pre><code>&lt;!-- Relative Path --&gt;
&lt;a href="http://nolboo.github.io/about.html"&gt;About&lt;/a&gt;

&lt;!-- Absolute Path --&gt;
&lt;a href="http://www.google.com/"&gt;Google&lt;/a&gt;
</code></pre>

<h3 id="linking-to-an-email-address-">Linking to an Email Address(이메일 링크)</h3>

<p>이메일 링크를 만들려면 <code>href</code> 속성값에 <code>mailto:</code>로 시작되는 이메일 주소를 준다.</p>

<p>추가적으로 이메일의 제목과 본문도 줄 수 있다. 제목은 추가하려면 이메일 주소 바로 뒤 패러미터(<code>?</code> 바로 뒤에 위치)로 <code>subject=</code>로 지정하며 여러 단어를 사용할 경우에는 빈칸으로 해석되는 <code>%20</code>을 사용하여 나열할 수 있다. 본문을 추가하려면 <code>body=</code> 패터미터를 사용한다. 마찬가지로 빈칸은 <code>%20</code>을 사용하고 줄바꿈은 <code>%0A</code>를 사용한다.</p>

<p>여러 개의 이메일 주소, cc, bcc 패러미터 등을 추가하는 방법은 <a href="http://yoast.com/guide-mailto-links/">The Full mailto Link Syntax</a>를 참조.</p>

<pre><code>&lt;a href="mailto:shay@awesome.com?subject=Still%20Awesome&amp;body=This%20is%20awesome"&gt;Email Me&lt;/a&gt;
</code></pre>

<h3 id="opening-links-in-a-new-window---">Opening Links in a New Window(새 창으로 링크 열기)</h3>

<p>아래와 같이 <code>target</code> 속성에 <code>_blank</code>값을 준다.</p>

<pre><code>&lt;a href="http://shayhowe.com/" target="_blank"&gt;Shay Howe&lt;/a&gt;
</code></pre>

<h3 id="linking-to-elements-within-the-same-page----">Linking to Elements within the Same Page(같은 페이지 내의 엘리먼트 링크)</h3>

<p>아래와 같이 링크하기를 원하는 엘리먼트에 ID를 지정하고 <code>href</code>의 속성값을로 그 ID를 사용한다.</p>

<pre><code>&lt;a href="#awesome"&gt;Awesome&lt;/a&gt;
&lt;div id="awesome"&gt;Awesome Section&lt;/div&gt;
</code></pre>

<h2 id="html5-structural-elementshtml5--">HTML5 Structural Elements(HTML5 구조 엘리먼트)</h2>
<p><br /></p>

<p>HTML5에서는 좀 더 시맨틱한 코드를 허용하는 몇 개의 새로운 블럭 엘리먼트가 제공된다.</p>

<p><img src="http://learn.shayhowe.com/assets/courses/html-css-guide/elements-semantics/html5.png" alt="HTML5 Document Structure" /><strong>Fig. 2.01</strong> The new HTML5 structural elements outline.</p>

<h3 id="header">Header</h3>

<p><code>header</code>는 페이지, article, section 혹은 페이지의 세그먼트의 머리 부분을 정의한다. 일반적으로 헤딩, 도입 구문, 네비게이션을 포함하기도 한다. 한 페이지에 한 개 이상의 <code>header</code>를 사용할 수 있다. 페이지의 시작에 <code>header</code>를 포함하는 것이 이상적이나 구자거으로 article의 헤더나 섹션에 필요한 만큼 사용할 수 있다.</p>

<blockquote>
  <h4 id="clarification-on-the-header-element">Clarification on the header Element</h4>

  <p><code>header</code> 엘리먼트는 <code>head</code> 또는 <code>h1</code> ~ <code>h6</code>의 heading과 혼동하면 안된다.<br /><br /></p>

  <p><code>header</code> 엘리먼트는 <code>body</code> 엘리먼트에 포함되는 페이지 헤딩을 잡아주는 구조적 엘리먼트다. <code>head</code> 엘리먼트는 페이지에 표시되지 않으며 메타데이터, 도큐먼트 제목, 외부 화일 링크 등의 정보를 지정하기 위해 사용된다.<br /><br /></p>

  <p><code>h1</code> ~ <code>h6</code>의 heading은 페이지에 걸친 텍스트 헤딩의 여러 단계를 표현하기 위해 사용된다.</p>
</blockquote>

<h3 id="navigation">Navigation</h3>

<p><code>nav</code>는 웹사이트의 주요 항해 링크들을 하나로 모은 블럭 엘리먼트다. </p>

<pre><code>&lt;nav&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href="#"&gt;...&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="#"&gt;...&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
</code></pre>

<h3 id="article">Article</h3>

<p><code>article</code>은 <code>div</code>나 <code>section</code>과 매우 유사한 블럭 엘리먼트이나 독립적으로 분배되거나 재사용할 수 있는 컨텐츠를 특별히 지정한다. 대부분의 경우 <code>article</code>은 블로그나 퍼블리싱 웹사이트 내의 공개된 컨텐츠를 정의한다. <code>article</code> 안의 컨텐츠는 RSS 피드 컨텐츠와 같이 다른 곳에 배포될 수 있어야 한다.</p>

<h3 id="section">Section</h3>

<p><code>section</code>은 <code>article</code>보다는 <code>div</code>와 좀 더 혼동될 수 있다. <code>section</code>은 일반 도큐멘트 혹은 앱의 섹션을 정의한다. <code>section</code>은 스타일링이나 스크립팅의 편의를 위해 사용되지 않는 것이 <code>div</code>와의 차이점이다.</p>

<p><code>section</code>에 스타일을 적용할 수 있으나, 스타일 적용만을 목적으로 사용되지 않는다.</p>

<blockquote>
  <h4 id="deciding-when-to-use-a-section-or-div">Deciding When to Use a section or div</h4>

  <p><code>div</code>와 대비하여 <code>section</code>을 사용하기를 결정하는 가장 좋은 방법은 실제 컨텐츠를 보는 것이다. 만약 컨텐츠 블럭이 데이타베이스 안의 레코드로 존재하고 CSS 스타일링 훅이 명백히 필요하지 않다면 <code>section</code> 엘리먼트가 가장 좋을 것이다. 섹션은 페이지를 나누기 위해 사용되어져야 하며, 자연스런 계층을 제공하고 대부분 적절한 헤딩이 가지고 있다.<br /><br /></p>

  <p>반면 <code>div</code>는 컨텐츠 블럭에 스타일을 적용할 때 사용될 수 있다. 예를 들면 한 쌍의 문단이 페이지의 나머지 컨텐츠보다 두드러질 필요가 있다면 그것들을 <code>div</code>로 감싸고 백그라운드, 보더와 같은 적절한 스타일을 주어야 한다.</p>
</blockquote>

<h3 id="aside">Aside</h3>

<p><code>aside</code>는 도큐멘트나 섹션과 관련된 컨텐츠를 정의하는 블럭 엘리먼트이며, 필요하다면 한 페이지에서 여러번 사용될 수 있다.</p>

<p>좌우로 위치시키려면 <code>aside</code> 엘리먼트를 <code>float</code>하는 것이 필요하고 이는 나중에 <a href="http://learn.shayhowe.com/html-css/box-model">floating and positioning</a> 에서 배울 것이다.</p>

<h3 id="footer">Footer</h3>

<p><code>footer</code>는 <code>header</code>와 동일하나 페이지, article, section이나 다른 페이지 세그먼트의 아래 부분을 위한 것이다.</p>

<h2 id="dry--dont-repeat-yourself">D.R.Y. – Don’t Repeat Yourself</h2>
<p><br /></p>

<p>개발의 원칙 중 하나는 코드를 여러번 되풀이하지 말라는 D.R.Y.이다. CSS에서는 계속해서 같은 스타일을 지속적으로 코딩하기 쉽기 때문에 이 원칙은 많은 걸 말해준다. 절대 하지 마라. CSS는 스타일을 적용하고 상속하기 쉽게 하도록 cascade와 class를 허락하게 디자인되어 있다. 최종 목표는 깨끗하고 가벼운 코드를 쓰고 시맨틱하고 쉽게 관리되는 것이다.</p>

<h2 id="resources--links">Resources &amp; Links</h2>
<p><br /></p>

<ul>
  <li><a href="http://boagworld.com/dev/semantic-code-what-why-how/">Semantic code: What? Why? How?</a> via Boagworld</li>
  <li><a href="http://html5doctor.com/">HTML5 Doctor</a></li>
  <li><a href="http://html5doctor.com/i-b-em-strong-element/">The i, b, em, &amp; strong Elements</a> via HTML5 Doctor</li>
  <li><a href="http://yoast.com/guide-mailto-links/">The Full mailto Link Syntax</a> via Joost de Valk</li>
  <li><a href="http://dev.opera.com/articles/view/new-structural-elements-in-html5/">New Structural Elements in HTML5</a> via Dev.Opera</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML & CSS 초보자 가이드 - 1강 : 용어, 문법, 소개]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/beginners-guide-to-html-and-css-1-slash-10/"/>
    <updated>2013-07-22T21:06:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/beginners-guide-to-html-and-css-1-slash-10</id>
    <content type="html"><![CDATA[<p>원본 : <a href="http://learn.shayhowe.com/html-css/terminology-syntax-intro">A Beginner’s Guide to HTML &amp; CSS - LESSON 1 : Terminology, Syntax, &amp; Introduction</a></p>

<p>HTML은 콘텐츠에 구조와 의미를 주기 위한 하이퍼 텍스트 마크업 언어이고, CSS(<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets)는 콘텐츠에 스타일과 모양을 주기위한 프리젠테이션 언어이다. 두 언어는 서로에 독립적이며, CSS가 HTML 문서 안에 있을 필요는 없고, 그 반대도 마찬가지다.</p>

<h2 id="common-html-terms">Common HTML Terms</h2>

<p>오늘은 tags, elements, and attributes 세 가지 용어에 대해 익숙해지자.</p>

<h3 id="elements">Elements</h3>

<p>페이지 안에서 구조와 컨텐츠를 포함하는 객체를 정의하기 위한 지명자.
<!-- more --></p>

<h3 id="tags">Tags</h3>

<p>시작 태그 &lt;&gt; 와 끝 태그 &lt;/&gt;
엘리먼트는 하나 또는 여러 개의 태그로 만들어진다.</p>

<h3 id="attributes">Attributes</h3>
<p>엘리먼트에 추가적으로 주어지는 속성.</p>

<h2 id="html-document-structure--syntax">HTML Document Structure &amp; Syntax</h2>

<p>모든 HTML 문서는 <code>doctype, html, head, body</code>의 선언과 태그를 포함하는 구조로 만들어진다.</p>

<p><code>doctype</code> 선언은 사용된 HTML 버전을 웹 브라우저에게 알려주며, HTML 문서의 최상위에 위치한다. <code>doctype</code> 선언에 이어, 문서의 처음과 끝을 뜻하는 <code>html</code> 태그가 위치한다.</p>

<p><code>head</code>는 메타 데이타, 문서 <code>title</code>, 외부 화일 링크로 구성된다. 실제 웹 페이지에서는 보여지지 않는다. 웹 페이지에 보여줄 모든 콘텐츠는 <code>body 태그 안</code>에 넣는다.</p>

<p>일반적인 HTML 문서 구조</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
      &lt;head&gt;
            &lt;meta charset="utf-8"&gt;
            &lt;title&gt;Hello World&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
            &lt;h1&gt;Hello World&lt;/h1&gt;
            &lt;p&gt;This is a website.&lt;/p&gt;
      &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h2 id="common-css-terms">Common CSS Terms</h2>

<h3 id="selectors">Selectors</h3>

<p>스타일을 적용할 엘리먼트(들).
ID, class, type, 속성들의 조합이 하나의 실렉터가 될 수도 있다.</p>

<h3 id="properties">Properties</h3>

<p>엘리먼트에 적용될 스타일을 결정한다.</p>

<pre><code>p {
      color: #ff0;
      font-size: 16px;
}
</code></pre>

<h3 id="values">Values</h3>

<p>property 의 값이며, :와 ;사이에 위치한다.</p>

<h2 id="css-structure--syntax">CSS Structure &amp; Syntax</h2>

<p>CSS는 실렉터를 사용하여 HTML 엘리먼트에 스타일을 적용하며, 모든 CSS 스타일은 여러 엘리먼트에 상속될 수 있다. </p>

<p>예를 들어 한 페이지 안의 모든 텍스트에 특정 컬러와 크기와 wieght를 하나의 스타일로 지정할 수 있으며, 좀 더 세분화된 실렉터를 사용하여 특정 엘리먼트에 유일한 스타일을 덮어씌울 수 있다.</p>

<p>Fig. 1.01 CSS syntax outline.<br />
<img src="http://learn.shayhowe.com/assets/courses/html-css-guide/terminology-syntax-intro/selector.png" alt="" /></p>

<h3 id="long-vs-short-hand">Long vs. Short Hand</h3>

<p>CSS에서 속성값을 선언하는 방법 중 하나의 속성과 하나의 값을 여러번 선언하는 것은 long hand, 하나의 속성에 여러 값을 나열하는 것이 short hand이다. short hand를 사용하는 것이 코드가 적기 때문에 좋다. 모든 속성이 shot hand를 지원하는 것이 아니기 때문에 확인해야 한다.</p>

<pre><code>/* Long Hand */
p {
  padding-top: 10px;
  padding-right: 20px;
  padding-bottom: 10px;
  padding-left: 20px;
}

/* Short Hand */
p {
  padding: 10px 20px;
}

/* Short Hand */
p {
  padding: 10px;
}
</code></pre>

<h4 id="comments-within-html--css">Comments within HTML &amp; CSS</h4>

<p>주석(comments)은 특히 여러 사람들이 공동작업할 때 매우 유용하다.</p>

<p>HTML comments : <code>&lt;!--</code> 로 시작하고 <code>--&gt;</code> 로 끝난다.
CSS comments : <code>/*</code> 로 시작하고 <code>*/</code> 로 끝난다.</p>

<h2 id="selectors-1">Selectors</h2>

<p>elements, IDs, and classes 또는 세 가지의 조합</p>

<h3 id="type-selectors">Type Selectors</h3>

<p>가장 기본적인 실렉터이다. 관리하기 쉽고 코드량이 적고 관리하기 쉽기 때문에 선호된다.</p>

<h3 id="class-selectors">Class Selectors</h3>

<p>HTML에선 class=”classname”, CSS에선 .classname
페이지 내 여러 엘리먼트에 적용될 수 있다.</p>

<h3 id="id-selectors">ID Selectors</h3>

<p>클래스 실렉터와 유사하지만 한번에 하나의 엘리먼트 만을 대상으로 한다. 한 페이지 당 하나만 허용되므로, 중요한 엘리먼트에만 사용되야 한다.</p>

<p>HTML에선 id=”idname”, CSS에서 #idname</p>

<h3 id="combining-selectors">Combining Selectors</h3>
<p>CSS의 아름다움은 seelector 와 inherit 스타일을 조합하는 능력이다. 일반적인 실렉터로부터 시작하고 원하는 만큼 특정 실렉터를 조합해 나간다.</p>

<pre><code>ul#social li {
  padding: 0 3px;
}
ul#social li a {
  height: 17px;
  width: 16px;
}
ul#social li.tumblr a {
  background: url('tumblr.png') 0 0 no-repeat;
}
</code></pre>

<h3 id="additional-selectors">Additional Selectors</h3>

<p>그 외 많은 진보된 실렉터가 존재한다. 그러나, <a href="http://coding.smashingmagazine.com/2009/08/17/taming-advanced-css-selectors/">진보된 실렉터</a>가 모든 브라우저에서 작동되는 것은 아니니 제대로 동작하지 않으면 브라우저 지원을 확인해야 한다.</p>

<h2 id="referencing-css">Referencing CSS</h2>

<p>가장 좋은 방법은 웹페이지의 head 안에 하나의 외부 화일로 링크하도록 한다. 하나의 외부 스타일시트을 사용하면 전체 웹 사이트에 걸쳐 같은 스타일을 사용할 수 있고, 사이트를 빠르게 변경할 수 있다.</p>

<p>인터널과 인라인 스타일은 일반적으로 웹 사이트를 업데이트하고 유지하는 것을 짜증나게 한다.</p>

<pre><code>&lt;!-- External CSS File --&gt;
&lt;link rel="stylesheet" href="file.css"&gt;

&lt;!-- Internal CSS --&gt;
&lt;style type="text/css"&gt;
p {
  color: #f60;
  font-size: 16px;
}
&lt;/style&gt;

&lt;!-- Inline CSS --&gt;
&lt;p style="color: #f60; font-size: 16px;"&gt;Lorem ipsum dolor sit amet...&lt;/p&gt;
</code></pre>

<h3 id="using-external-css-stylesheets">Using External CSS Stylesheets</h3>

<p>전체 웹사이트에 걸쳐 하나의 스타일로 편하게 관리할 수 있으며, 스타일 렌더링을 위한 트래픽도 적어진다.</p>

<p>다음 예는 서브 디렉토리인 styles의 file.css를 불러오게 된다.</p>

<pre><code>&lt;head&gt;
    &lt;link rel="stylesheet" href="styles/file.css"&gt;
&lt;/head&gt;
</code></pre>

<h2 id="reset">Reset</h2>

<p>기본적으로 모든 웹브라우저는 자신 만의 방법으로 엘리먼트의 스타일을 해석한다. 이러한 문제와 전투를 벌이기 위해서 CSS reset이 널리 사용왼다.</p>

<pre><code>#### Cross Browser Compatibility &amp; Testing
각 브라우저가 다른 방식으로 페이지를 렌더링한다. 웹사이트가 모든 브라우저에서 동일하게 보일 필요는 없지만 유사하게는 보여야 한다. 
</code></pre>

<p>CSS reset은 모든 일반적인 HTML 엘리먼트를 하나의 통일된 스타일로 만들어버리는 몇 개의 룰셋이다. 페이지의 뼈대에 적용되는 모든 스타일이 확실히 렌더링되기 위해 CSS 스타일의 가장 앞에서 위치한다.</p>

<p>엄청 많은 reset이 있으면 각장의 장점을 가지고 있다. 저자가 가장 좋은 하는 것은 <a href="http://meyerweb.com/eric/tools/css/reset/">Eric Meyers reset</a></p>

<pre><code>#### Code Validation

코드 검증은 브라우저에 걸처 적절하게 렌더링하는 것도 도와주며, 코드 작성을 위한 베스트 프랙티스도 가르쳐 준다.
[W3C HTML validator](http://validator.w3.org/)
[W3C CSS validator](http://jigsaw.w3.org/css-validator/)
</code></pre>

<h2 id="resources--links">Resources &amp; Links</h2>

<ul>
  <li><a href="http://www.scriptingmaster.com/html/HTML-terms-glossary.asp">Common HTML Terms</a> via Scripting Master  </li>
  <li><a href="http://www.codestyle.org/css/Glossary.shtml">CSS Glossary</a> via Code Style</li>
  <li><a href="http://coding.smashingmagazine.com/2009/08/17/taming-advanced-css-selectors/">Taming Advanced CSS Selectors</a> via Smashing Magazine </li>
  <li><a href="http://meyerweb.com/eric/tools/css/reset/">CSS Tools: Reset CSS</a> via Eric Meyer </li>
  <li><a href="http://www.shayhowe.com/web-design/intro-to-html-css/">An Intro to HTML &amp; CSS via Shay Howe</a></li>
</ul>
]]></content>
  </entry>
  
</feed>
