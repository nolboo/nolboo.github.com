<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: HTML | Nolboo's Blog]]></title>
  <link href="http://nolboo.github.io/blog/categories/html/atom.xml" rel="self"/>
  <link href="http://nolboo.github.io/"/>
  <updated>2013-08-31T17:44:46+09:00</updated>
  <id>http://nolboo.github.io/</id>
  <author>
    <name><![CDATA[Nolboo Kim]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[HTML & CSS 중급자 가이드 - 6강 : jQuery]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/advanced-guide-to-html-and-css-6-slash-10/"/>
    <updated>2013-07-22T21:20:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/advanced-guide-to-html-and-css-6-slash-10</id>
    <content type="html"><![CDATA[<p>원본 : <a href="http://learn.shayhowe.com/advanced-html-css/jquery">An Advanced Guide to HTML &amp; CSS - LESSON 6 : jQuery</a></p>

<p>웹 디자이너나 프론트 엔드 개발자가 되려면 일반적으로 어느 정도는 (종종 JS라고 불리우는) 자바스크립트와 jQuery에 부딪칠 것이다. 상위 10,000 웹사이트에서 자바스크립트는 <a href="http://trends.builtwith.com/docinfo/Javascript">92%가 넘게</a> 사용되고, jQuery는 <a href="http://trends.builtwith.com/javascript/jQuery">63%를 넘게</a> 사용되고 있다. 말할 필요도 없이 매우 인기가 있다. 미래의 어떤 시기에 자신의 행동을 구축하기위해 자바스크립트나 jQuery를 <a href="http://jsforcats.com/">코딩하길</a> 열망할 수도 있다.</p>

<p>자바스크립트와 jQuery가 정확히 무엇인지 묻고 있다면, 두려워말라. 이 단원에서 자바스크립트의 간략한 개요를 보여줄 것이고 jQuery도 살펴볼 것이다.</p>

<h2 id="javascript-intro">JavaScript Intro</h2>

<p><a href="https://developer.mozilla.org/en-US/docs/JavaScript/A_re-introduction_to_JavaScript">자바스크립트</a>는 웹사이트에 상호작용성을 추가할 수 있게 해주고 유저 경험을 풍부하게 하는 것을 돕는다. HTML은 페이지에 <strong>구조</strong>를 제공하고 CSS는 <strong>외모</strong>를 제공하고 자바스크립트는 <strong>행동</strong>을 제공한다.
<!-- more -->
CSS처럼, 자바스크립트는 <code>.js</code> 화일 확장자로 외부 화일에 저장해야하며, <code>script</code> 엘리먼트를 사용하여 HTML 문서 안에서 참조(reference)된다. HTML 안의 자바스크립트 참조가 어디에 있느냐는 그것이 언제 실행되야하는가에 따라 다르다. 일반적으로 말하면 자바스크립트 화일이 연급되는 가장 좋은 위치는 - 모든 HTML이 파싱되고난 후에 자바스크립트가 로드되도록 - <code>&lt;/body&gt;</code>태그가 끝나기 바로 전이다. 그러나, 때론 HTML을 렌더링하거나 그것의 행동을 결정하는 것을 도와야하기 때문에 문서의 <code>head</code> 안에서 참조될 수 있다.</p>

<pre><code>&lt;script src="script.js"&gt;&lt;/script&gt;
</code></pre>

<h3 id="values--variables">Values &amp; Variables</h3>

<p>값(value)과 변수(variable)는 자바스크립트 기초의 일부다. 일반적으로  값은 자바스크립트가 인식할 다양한 종류의 값이고, 변수는 이 값들을 저장하고 공유하기 위해 사용된다.</p>

<p>값은 문자열, 참/거짓 불린(Boolean), 숫자, <code>undefined</code>, <code>null</code>, 혹은 함수와 객체 같은 값들도 포함할 수 있다.</p>

<p>변수가 정의되는 인기있는 방법 중 하나는 <code>var</code> 키워드와 뒤따르는 변수명, 등호 기호 (<code>=</code>), 그리고 값과 세미콜론 (<code>;</code>)으로 마친다. 변수 이름은 문자, 밑줄 (<code>_</code>)이나 달러 기호 (<code>$</code>)로 시작되어야 한다. 변수는 숫자로 시작될 수 없으나 시작 이후에는 사용될 수 있다. 어떤 경우에도 하이픈은 사용할 수 없다. 더불어 자바스크립트는 대소문자를 구분하기 때문에 문자는 <code>a</code>에서 <code>z</code>까지의 대/소문자 모두가 포함된다.</p>

<p>역자 참조 : MDN <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Values,_variables,_and_literals#Variables">Values, variables, and literals</a></p>

<p>변수를 명하는 일반적인 규칙은 대쉬나 밑줄을 젼혀 사용하지 않고 캐멀케이스(<a href="http://en.wikipedia.org/wiki/CamelCase">camelCase</a>)를 사용하는 것이다. 캐멀케이스는 빈칸을 없애고 첫 단어를 제외한 각 단어를 대문자로 시작하여 단어들을 조합한다. 예를 들면 <code>shay_is_awesome</code>은 <code>shayIsAwesome</code>으로 이름짓는 것이 더 일반적이다.</p>

<pre><code>var theStarterLeague = 125;
var food_truck = 'Coffee';
var mixtape01 = true;
var vinyl = ['Miles Davis', 'Frank Sinatra', 'Ray Charles'];
</code></pre>

<h3 id="statements">Statements</h3>

<p>전반적으로 자바스크립트는 쓰여진 순서대로 브라우저에 의해 실행되는 문장(statement)의 집합이다. 이 문장들은 수행될 댜양한 행동들을 결정하는 명령을 제공한다. 문장들은 다양한 형태와 크기가 되고, 여러 문장은 세미콜론 <code>;</code>으로 나뉜다. 새로운 문장은 새로운 줄에서 시작되어야하며 들여쓰기는 문장들을 더 읽기쉽게 하기위해 사용해야하지만, 반드시 요구되는 것은 아니다.</p>

<pre><code>log(polaroid);
return('bicycle lane');
alert('Congratulations, you ' + outcome);
</code></pre>

<h3 id="functions">Functions</h3>

<p>자바스크립트 기초에 더해, 함수(function)을 살펴보는 것은 중요하다. 함수는 지금, 또는 나중을 위해 저장된, 다른 인수(argument)를 받아들이기도 하는 함수에 의존하는, 기술된 일련의 행동을 수행하는 방법을 제공한다.</p>

<p>함수는 <code>function</code> 키워드와 뒤따르는 함수명, 필요할 경우, 쉼표로 분리된 인수 목록(전체가 소괄호로 감싸진다)과 함수를 정의하는 자바스크립트 문장 또는 문장들(전체가 중괄호 <code>{}</code>로 둘러싸여진다)을 사용해 정의된다.</p>

<pre><code>function sayHello(name) {
  return('Hello ' + name);
}
</code></pre>

<h3 id="arrays">Arrays</h3>

<p>인정하듯이 몇몇 값은 배열로 반환될 수 있다. 배열은 항목이나 값의 목록을 저장하는 방법을 포함한다. 여러 가지 이유로 배열은 다양한 매서드와 연산자로 팀색할 수 있어 도움이 된다. 게다가 상황에 따라 배열은 다양한 값을 저장하고 반환하는 데 사용될 수 있다.</p>

<p>일반적으로 말하면 배열은 대괄호 <code>[]</code>와 쉼표로 분리된 항목들로 식별된다. 항목은 <code>0</code>에서 시작되어 증가한다. 한 목록에서 세번째 아이템을 식별할 때는 실제 <code>[2]</code>로서 식별된다.</p>

<h3 id="objects">Objects</h3>

<p>자바스크립트는 키/값의 한 쌍인 객체의 기초 위에 만들어진 것이기도 하다. 예를 들어 <code>school</code>로 이름지어진 객체가 있고, 이 객체가 <code>name</code>, <code>location</code>, <code>students</code>, <code>teachers</code> 키들(프로퍼티/속성으로도 알려짐)과 그들의 값을 포함하고 있다고 하자.</p>

<p>아래 예제에서 변수 <code>school</code>은 여러 속성을 보유하는 객체로 설정된다. 각 속성은 하나의 키와 값을 가진다. 전체 객체는 중괄호 <code>{}</code>로 감싸졌고, 속성은 쉽표로 분리되며, 각 속성은 콜론과 값이 뒤따르는 하나의 키를 갖는다.</p>

<p>OBJECTS</p>

<pre><code>var school = {
  name: 'The Starter League',
  location: 'Merchandise Mart',
  students: 120,
  teachers: ['Jeff', 'Raghu', 'Carolyn', 'Shay']
};
</code></pre>

<p>ARRAY</p>

<pre><code>var school = ["Austin", "Chicago", "Portland"];
</code></pre>

<p><img src="http://learn.shayhowe.com/assets/courses/advanced-html-css-guide/jquery/console.png" alt="Web Inspector Console" /></p>

<p><strong>Fig. 6.01</strong></p>

<p>크롬 웹브라우저 안에 내장된 개발자 도구를 사용하면 자바스크립트를 콘솔 안에서 실행시킬 수 있다.</p>

<h2 id="jquery-intro">jQuery Intro</h2>

<p>자바스크립트와 그 기초의 일부에 대한 기본적인 이해와 함께 jQuery를 살펴볼 차례다. jQuery는 HTML, CSS와 자바스크립트 간의 상호 작용을 단순화시키기 위해 존 레식이 작성한 오픈소스 자바스크립트 라이브러리다. jQuery가 출시된 2006년 이후 급성장하였고 크고 작은 웹사이트와 기업에서 사용되고 있다.</p>

<p>jQuery를 그렇게 인기있게 만든 것은 CSS를 닯은 실렉션과 동작의 알기쉬운 분리와 같은 <a href="https://tutsplus.com/course/30-days-to-learn-jquery/">손쉬운 사용</a>이었다. jQuery의 이점은 막대하지만 우리 목적은 엘리먼트를 찾고 그것들과 작업을 수행하는 능력에 대해서만 고려해볼 것이다.</p>

<h3 id="getting-started-with-jquery">Getting Started with jQuery</h3>

<p>jQuery 사용의 첫걸음은 HTML 문서 안에 그것을 참조하는 것이다. 자바스크립트에서 이전에 말했듯이 <code>&lt;/body&gt;</code> 태그의 바로 앞에 <code>script</code> 엘리먼트를 사용함으로 행해진다. jQuery는 자신이 라이브러리이기 때문에 다른 자바스트립트가 쓰여진 것과는 전부 분리시키는 것이 가장 좋다.</p>

<p>jQuery를 참조하는 것은 몇 가지 옵션이 있다. 특히, 축소되거나 압축되지 않은 버전을 사용할지 여부, 그리고 <a href="https://developers.google.com/speed/libraries/devguide">구글 호스팅 라이브러리</a>와 같은 컨텐츠 전송 네트워크(CDN)을 사용할지 여부와 같은 옵션이 있다. 라이브 프로덕션 환경에서 코드가 쓰여지는 경우에는 더 나은 로딩 시간을 위해 축소된 버전을 사용하는 것이 권장된다. 게다가 구글과 같은 CDN은 로딩 시간과 잠재적인 캐싱 이득에 도움이 된다.</p>

<pre><code>&lt;script src="http://nolboo.github.io//ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"&gt;&lt;/script&gt;
&lt;script src="script.js"&gt;&lt;/script&gt;    
</code></pre>

<p>위의 코드 예제에서 두번째 <code>script</code> 엘리먼트는 또 하나의 자바스크립트 화일을 참조하고 있는 것을 주목하라. 모든 커스텀, 직접 쓴 자바스크립트과 JQuery는 이 화일에서 쓰여져야한다. 더불어 이 화일은 이미 정의된 JQuery 함수를 참조할 수 있도록 jQuery 화일 뒤에 명확하게 위치하여야 한다.</p>

<blockquote>
  <h4 id="where-is-the-leading-http">Where is the leading http?</h4>

  <p>위 예제에서 구글 CDN 참조 안에 선행하는(leading) <code>http</code>가 없는 것을 발견할 수 있다. <code>http</code>와 <code>https</code> 연결을 모두 허용하기위해, <code>http</code>를 의도적으로 생략한 것이다. 웹 서버의 이점없이 로컬에서 동작할 때는 시스템의 로컬 디스크 드라이브의 화일을 찾는 것을 방지하려면 선행하는 <code>http</code>가 필요할 것이다.</p>
</blockquote>

<h3 id="jquery-object">jQuery Object</h3>

<p>jQuery는 자신의 객체 - 달러 기호 <code>$</code>, <code>jQuery</code>라고도 알려진 - 와 함께 제공된다. <code>$</code> 객체는 엘리먼트를 선택하고 작업을 수행하려하는 엘리먼트 노드를 반환하기위해 특별히 만들어졌다. 이 선택과 행동은 실제 jQuery 라이브러리의 바깥에서 참조되는 새로운 화일에 작성되어야 한다.</p>

<pre><code>$();
jQuery();
</code></pre>

<h3 id="document-ready">Document Ready</h3>

<p>페이지를 탐색하고 조작하기위해 jQuery를 시동하기(역자주 : trigging은 triggering의 오타인듯) 전에 DOM의 로딩이 끝날 때까지 기다리는 것이 가장 좋다. 다행히 jQuery는 <code>.ready()</code> 이벤트를 가지고 있다.
우리가 손수 쓴 jQuery 코드를 이 함수 안에 모두 배치하여 페이지가 로드되어 DOM이 준비될 때 까지 그것이 실행되지 않을 것을 보장할 수 있다.</p>

<pre><code>$(document).ready(function(event){ 
  // jQuery code 
});
</code></pre>

<h2 id="selectors">Selectors</h2>

<p>앞에서 언급하였듯이 jQuery의 핵심 개념 중 하나는 <a href="http://api.jquery.com/category/selectors/">엘리먼트를 선택</a>하는 것과 작업을 수행하는 것이다. jQuery는, CSS를 모방함으로써 극도로 쉽게, 선택 작업과 엘리먼트나 엘리먼트들의 작업을 훌륭하게 해왔다. 일반적인 CSS 실렉터에 뛰어넘어 jQuery는 사용 브라우저에 상관없이 작동하는 고유 CSS3 실렉터를 모두 지원한다.</p>

<p>jQuery 객체 <code>$()</code>를 호출할 때 실렉터를 포함하면 그것을 조작할 수 있는 DOM 노드를 반환할 것이다. 실렉터는 소괄호 <code>('...')</code> 안에 넣고 CSS의 실렉터와 똑같은 엘리먼트를 선택할 수 있다.</p>

<pre><code>$('.feature');              // Class selector
$('li strong');             // Descendant selector
$('em, i');                 // Multiple selector
$('a[target="_blank"]');    // Attribute selector
$('p:nth-child(2)');        // Pseudo-class selector
</code></pre>

<h3 id="this-selection-keyword">This Selection Keyword</h3>

<p>jQuery 함수 안에서 작업할 때 원래의 실렉터 안에서 참조되었던 엘리먼트를 선택하고 싶을 것이다. 이 경우에는 <code>this</code> 키워드가 현재 핸들러에서 선택된 엘리먼트를 참조하는 데 사용될 수 있다.</p>

<pre><code>$('div').click(function(event){ 
  $(this);
});
</code></pre>

<blockquote>
  <h4 id="jquery-selection-filters">jQuery Selection Filters</h4>

  <p>CSS 실렉터가 충분치 못하다면 JQuery에 내장된 커스텀 <a href="http://api.jquery.com/category/selectors/jquery-selector-extensions/">필터들</a>이 도움이 될 것이다. 이 필터들은 CSS의 확장이고 엘리먼트나 관련자를 선택할 때 더 많은 제어할 수 있다.</p>

  <pre><code>  $('div:has(strong)');
</code></pre>

  <p>있는 그대로 이 필터들은 실렉터 안에서 사용될 수 있지만, DOM에 순수하지(native) 않기 때문에 약간 느려진다. 필터를 사용할 때 최고의 결과는 jQuery 탐색 기능 중 <code>:filter()</code> 매서드를 이용하여 얻어진다.</p>
</blockquote>

<h2 id="traversing">Traversing</h2>

<p>종종 일반적인 CSS 실렉터만으로는 잘라내듯 선택되지 않아 좀 더 세세한 제어가 요구된다. 다행히 jQuery는 DOM 트리를 위아래로 탐색(traverse)하여 필요한 대로 엘리먼트를 걸러내고 선택하는 몇 가지 매서드를 제공한다.</p>

<p>DOM 내부의 엘리먼트를 걸러내기 시작하려면 상대적으로 탐색하는 것이 필요하다. 아래 예에서 애초의 선택은 DOM의 모든 <code>div</code> 엘리먼트를 찾고 난 후, <code>.not()</code> 매서드를 사용하여 필터링한다. 이 구체적인 매서드로 <code>type</code>나 <code>collection</code> 클래스를 갖지 않는 <code>div</code> 엘리먼트가 선택될 것이다.</p>

<pre><code>$('div').not('.type, .collection');
</code></pre>

<h3 id="chaining-methods">Chaining Methods</h3>

<p>선택된 엘리먼트를 훨씬 더 많이 제어하기 위해, 다양한 탐색 매서드들을 단순히 점을 사용하여 서로 연결할 수 있다.</p>

<p>아래 코드 예제는  <code>.not()</code> 매서드와 <code>.parent()</code>를 모두 사용한다. 함께 결합해서 <code>type</code> 혹은 <code>collection</code> 클래스를 갖지않는 <code>div</code> 엘리먼트의 부모 엘리먼트만을 선택할 것이다.</p>

<pre><code>$('div').not('.type, .collection').parent();
</code></pre>

<h3 id="traversing-methods">Traversing Methods</h3>

<p>JQuery는 상당수의 <a href="http://api.jquery.com/category/traversing/">탐색</a> 매서드를 사용할 수 있다. 그것들은 일반적으로 필터링(filtering), 기타 탐색(miscellaneous traversing), DOM 트리 탐색(DOM tree traversing)의 세가지 범주에 속한다. 각 범주의 구체적인 메서드는 아래와 같다.</p>

<h4 id="filtering">Filtering</h4>

<ul>
  <li><code>.eq()</code></li>
  <li><code>.filter()</code></li>
  <li><code>.first()</code></li>
  <li><code>.has()</code></li>
  <li><code>.is()</code></li>
  <li><code>.last()</code></li>
  <li><code>.map()</code></li>
  <li><code>.not()</code></li>
  <li><code>.slice()</code></li>
</ul>

<h4 id="miscellaneous-traversing">Miscellaneous Traversing</h4>

<ul>
  <li><code>.add()</code></li>
  <li><code>.andSelf()</code></li>
  <li><code>.contents()</code></li>
  <li><code>.end()</code></li>
</ul>

<h4 id="dom-tree-traversal">DOM Tree Traversal</h4>

<ul>
  <li><code>.children()</code></li>
  <li><code>.closest()</code></li>
  <li><code>.find()</code></li>
  <li><code>.next()</code></li>
  <li><code>.nextAll()</code></li>
  <li><code>.nextUntil()</code></li>
  <li><code>.offsetParent()</code></li>
  <li><code>.parent()</code></li>
  <li><code>.parents()</code></li>
  <li><code>.parentsUntil()</code></li>
  <li><code>.prev()</code></li>
  <li><code>.prevAll()</code></li>
  <li><code>.prevUntil()</code></li>
  <li><code>.siblings()</code></li>
</ul>

<h2 id="manipulation">Manipulation</h2>

<p>DOM에서 엘리먼트를 선택하고 탐색하는 것은 jQuery가 제공하는 것의 부분일 뿐이고, 또 다른 주요 부분은 일단 찾아낸 엘리먼트와 뭘 할 수있는 것인가이다. 가능한 것 중 하나는 이 엘리먼트들을 읽거나 추가하고, 속성이나 스타일을 변경하여 <a href="http://api.jquery.com/category/manipulation">조작</a>하는 것이다. 추가적으로 엘리먼트는 DOM 안에서 변경되고, 위치를 바꾸고, 제거하고, 새 엘리먼트를 추가하는 것 등을 할 수 있다. 전반적으로 엘리먼트를 조작하는 옵션은 매우 광대하다.</p>

<h3 id="getting--setting">Getting &amp; Setting</h3>

<p>주목해야힐 조작 매서드는 정보를 얻거나(<em>getting</em>) 혹은 설정하는(<em>setting</em>) 두 개의 지시자 중 하나로 사용된다는 것이 매우 일반적이다. 정보를 얻는다는 것은 가져올 정보 조각이 무엇인지를 결정하기 위해 매서드와 함께 실렉터를 사용하게 되는 것이다. 더불어 똑같은 실렉터와 매서드를 정보 조각을 설정하는 데에도 사용할 수 있다.</p>

<pre><code>// Gets the value of the alt attribute
$('img').attr('alt');

// Sets the value of the alt attribute
$('img').attr('alt', 'Wild kangaroo');
</code></pre>

<p>뒤따르는 예제와 스니핏에서, 매서드는 주로 설정 모드에서 사용되지만, getting 모드에서도 사용될 수 있다.</p>

<h3 id="attribute-manipulation">Attribute Manipulation</h3>

<p>검사되고 조작될 수 있는 엘리먼트의 한 부분은 속성이다. 몇 가지 선택사항은 속성이나 값을 추가, 제거, 변경할 수 있는 것이다. 아래 예제에서 <code>.addClass()</code> 매서드는 모든 짝수번 째의 <code>li</code> 항목에 클래스를 추가한다. <code>.removeClass()</code> 매서드는 모든 단락에서 클래스를 모두 제거하고 마지막으로 <code>.attr()</code> 매서드는 <code>abbr</code> 엘리먼트의 <code>title</code> 속성을 찾아서 그것을 <code>Hello World</code>로 설정한다.</p>

<pre><code>$('li:even').addClass('even-item');
$('p').removeClass();
$('abbr').attr('title', 'Hello World');
</code></pre>

<h4 id="attribute-manipulation-methods">Attribute Manipulation Methods</h4>

<ul>
  <li><code>.addClass()</code></li>
  <li><code>.attr()</code></li>
  <li><code>.hasClass()</code></li>
  <li><code>.prop()</code></li>
  <li><code>.removeAttr()</code></li>
  <li><code>.removeClass()</code></li>
  <li><code>.removeProp()</code></li>
  <li><code>.toggleClass()</code></li>
  <li><code>.val()</code></li>
</ul>

<h3 id="style-manipulation">Style Manipulation</h3>

<p>속성을 조작하는 것에 더해, 엘리먼트의 스타일도 다양한 매서드로 조작될 수 있다. 엘리먼트의 높이, 너비, 위치를 읽거나 설정할 때 몇몇 특정 매서드를 사용할 수 있고, <code>.css()</code> 매서드를 사용하면 어떤 CSS 스타일 변경도 다룰 수 있다.</p>

<p>특별히 <code>.css()</code> 매서드는 하나 또는 여러 개의 속성을 설정하거나, 각 변화에 대한 문법을 설정할 수 있다. 하나의 속성을 설정하려면 속성 이름과 값은 각각 따옴표와 쉼표로 분리되어야 한다. 여러 속성을 설정하려면 속성은 중괄호 안에 포함되어야 한다. 속성명은 캐멀케이스되어야 하고, 필요한 경우 하이픈은 제거된다. 그 뒤에 콜론과 인용부호로 감싼 값이 따른다. 속성과 값으로 짝지워진 각 쌍은 쉼표로 분리된다.</p>

<p>높이, 너비, 위치 매서드는 모두 픽셀값을 기본으로 하나, 다른 측정 단위도 사용될 수 있다. 아래에서 보여지듯이, 측정 단위를 변경하면 값 다음에 더하기 부호와 뒤따르는 인용부호된 측정단위를 사용하여 식별한다.</p>

<pre><code>$('h1 span').css('font-size', 'normal');
$('div').css({
  fontSize: '13px', 
  background: '#f60'
});
$('header').height(200);
$('.extend').height(30 + 'em');
</code></pre>

<h4 id="style-manipulation-methods">Style Manipulation Methods</h4>

<ul>
  <li><code>.css()</code></li>
  <li><code>.height()</code></li>
  <li><code>.innerHeight()</code></li>
  <li><code>.innerWidth()</code></li>
  <li><code>.offset()</code></li>
  <li><code>.outerHeight()</code></li>
  <li><code>.outerWidth()</code></li>
  <li><code>.position()</code></li>
  <li><code>.scrollLeft()</code></li>
  <li><code>.scrollTop()</code></li>
  <li><code>.width()</code></li>
</ul>

<h3 id="dom-manipulation">DOM Manipulation</h3>

<p>마지막으로, 엘리먼트의 위치를 변경하거나 추가하고 제거하고, 노골적으로 엘리먼트를 변경하여 DOM을 검사하고 조작할 수 있다. 여기서의 선택사항은 DOM 안에서 어떤 잠재적인 변화도 허용할 정도로 깊고 다양하다.</p>

<p>각 개개의 DOM 조작 매서드는 자신의 문법을 가지고 있지만, 아래 예에서 그 중 일부를 대강 설명해본다. <code>.prepend()</code> 매서드는 모든 <code>section</code>에 <code>h3</code> 엘리먼트를 새로 추가하고, <code>.after()</code> 매서드는 링크 바로 뒤에 <code>em</code> 엘리먼트를 새로 추가하며, <code>.text()</code> 매서드는 모든 <code>h1</code> 엘리먼트의 문자를 <code>Hello World</code>로 바꾼다.</p>

<pre><code>$('section').prepend('&lt;h3&gt;Featured&lt;/h3&gt;');
$('a[target="_blank"]').after('&lt;em&gt;New window.&lt;/em&gt;');
$('h1').text('Hello World');
</code></pre>

<h4 id="dom-manipulation-methods">DOM Manipulation Methods</h4>

<ul>
  <li><code>.after()</code></li>
  <li><code>.append()</code></li>
  <li><code>.appendTo()</code></li>
  <li><code>.before()</code></li>
  <li><code>.clone()</code></li>
  <li><code>.detach()</code></li>
  <li><code>.empty()</code></li>
  <li><code>.html()</code></li>
  <li><code>.insertAfter()</code></li>
  <li><code>.insertBefore()</code></li>
  <li><code>.prepend()</code></li>
  <li><code>.prependTo()</code></li>
  <li><code>.remove()</code></li>
  <li><code>.replaceAll()</code></li>
  <li><code>.replaceWith()</code></li>
  <li><code>.text()</code></li>
  <li><code>.unwrap()</code></li>
  <li><code>.wrap()</code></li>
  <li><code>.wrapAll()</code></li>
  <li><code>.wrapInner()</code></li>
</ul>

<h2 id="events">Events</h2>

<p>jQuery의 아름다움 중 하나는 벌어지는 특정 이벤트나 액션에서만 호출되는 매서드인 <a href="http://api.jquery.com/category/events/">이벤트 핸들러</a>를 쉽게 추가하는 수 있는 것이다. 예를 들어, 엘리먼트에 클래스를 추가하는 매서드를 클릭된 엘리먼트에서 발생되도록 설정될 수 있다.</p>

<p>아래에서 모든 <code>li</code> 항목을 잡아채는 표준 실렉터가 있다. <code>.click()</code> 이벤트 매서드는 <code>li</code> 아이템 실렉터에 구속되어 있으며(binding), <code>li</code> 아이템을 클릭할 때 발생되는 액션을 설정한다. <code>.click()</code> 이벤트 매서드 안에 실행될 액션을 보장하는 함수가 있다. 함수 바로 다음의 소괄호는 함수를 위한 패러미터(속성)를 전달할 수있으며, 이 예제에서는 <code>event</code> 객체가 사용되었다.</p>

<p>함수 안에 <code>.addClass()</code> 매서드가 구속된 또하나의 실렉터가 있다. 이제 <code>li</code> 항목이 클릭되면 <code>this</code> 키워드를 통해 <code>li</code> 항목은 <code>saved-item</code> 클래스를 받을 수 있다.</p>

<pre><code>$('li').click(function(event){
  $(this).addClass('saved-item');
});
</code></pre>

<h3 id="event-flexibility">Event Flexibility</h3>

<p><code>.click()</code> 이벤트 매서드는, 소수의 다른 이벤트 매서드와 함께, jQuery 1.7부터 도입된 <code>.on()</code> 매서드를 사용하는 숏핸드 매서드이다. <code>.on()</code> 매서드는, 페이지에 동적으로 추가되는 엘리먼트를 위한 자동 위임을 사용하여, 상당한 유연성을 제공한다. </p>

<p><code>.on()</code> 매서드를 이용하여 첫번째 인수는 네이티브 이벤트 이름이어야 하는 반면 두번째 인수는 이벤트 핸들러 함수이어야 한다. 이전의 예제를 살펴보면 <code>.on()</code> 매서드가 <code>.click()</code> 매서드의 자리에서 호출되고 있다. 이제 <code>click</code> 이벤트 이름은 전과 똑같이 자리잡은 이벤트 핸들러 함수와 함께 <code>.on()</code> 매서드 안에서 첫번째 인수로서 전달된다.</p>

<pre><code>$('li').on('click', function(event){
  $(this).addClass('saved-item');
});
</code></pre>

<h3 id="nesting-events">Nesting Events</h3>

<p>또 다른 하나 안에 하나를 품게함으로써 여러 개의 이벤트 핸들러와 트리거를 가질 수 있다. 예재로 <code>.on()</code> 이벤트 매서드 밑으로 <code>hover</code>  인수를 전달하여 <code>pagination</code> 클래스를 가진 엘리먼트 위를 호버할 때 호출될 수 있다. <code>.on()</code> 이벤트를 호출하면 <code>.click()</code> 아벤트 <code>up</code> ID를 가진 앵커를 호출된다.</p>

<pre><code>$('.pagination').on('hover', function(event){
  $('a#up').click();
});
</code></pre>

<h3 id="event-demo">Event Demo</h3>

<p>데모로서 경고 메시지를 사용하여 다음 코드 스니핏은 경고 메시지를 만들고나서 닫기 아이콘을 클릭하면 메시지를 제거하는 방법을 보여준다. </p>

<blockquote>
  <h6 id="html">HTML</h6>

  <pre><code>&lt;div class="alert-warning"&gt;
  &lt;strong&gt;Warning!&lt;/strong&gt; I’m about to lose my cool.
  &lt;div class="alert-close"&gt;×&lt;/div&gt;
&lt;/div&gt;
</code></pre>

  <h6 id="javascript">JavaScript</h6>

  <pre><code>$('.alert-close').on('click', function(event){
  $('.alert-warning').remove();
});
</code></pre>

  <h4 id="demohttpjmp19lrgr1"><a href="http://j.mp/19Lrgr1">Demo</a></h4>
</blockquote>

<h3 id="event-methods">Event Methods</h3>

<p>jQuery는 브라우저와 상호작용할 때 유저 행동을 등록하는 데에 기반을 둔 모든 매서드를 아주 많이 제공한다. 이런 매서드들은 아주 인기가 많지만 브라우저, 폼, 키보드, 마우스 등의 이벤트에 제한적이지 않은 꽤 많은 이벤트를 등록한다. 가장 인기있는 매서드들은 다음과 같다:</p>

<h4 id="browser-events">Browser Events</h4>

<ul>
  <li><code>.resize()</code></li>
  <li><code>.scroll()</code></li>
</ul>

<h4 id="document-loading">Document Loading</h4>

<ul>
  <li><code>.ready()</code></li>
</ul>

<h4 id="event-handler-attachment">Event Handler Attachment</h4>

<ul>
  <li><code>.off()</code></li>
  <li><code>.on()</code></li>
  <li><code>.one()</code></li>
  <li><code>jQuery.proxy()</code></li>
  <li><code>.trigger()</code></li>
  <li><code>.triggerHandler()</code></li>
  <li><code>.unbind()</code></li>
  <li><code>.undelegate()</code></li>
</ul>

<h4 id="event-object">Event Object</h4>

<ul>
  <li><code>event.currentTarget</code></li>
  <li><code>event.preventDefault()</code></li>
  <li><code>event.stopPropagation()</code></li>
  <li><code>event.target</code></li>
  <li><code>event.type</code></li>
</ul>

<h4 id="form-events">Form Events</h4>

<ul>
  <li><code>.blur()</code></li>
  <li><code>.change()</code></li>
  <li><code>.focus()</code></li>
  <li><code>.select()</code></li>
  <li><code>.submit()</code></li>
</ul>

<h4 id="keyboard-events">Keyboard Events</h4>

<ul>
  <li><code>.focusin()</code></li>
  <li><code>.focusout()</code></li>
  <li><code>.keydown()</code></li>
  <li><code>.keypress()</code></li>
  <li><code>.keyup()</code></li>
</ul>

<h4 id="mouse-events">Mouse Events</h4>

<ul>
  <li><code>.click()</code></li>
  <li><code>.dblclick()</code></li>
  <li><code>.focusin()</code></li>
  <li><code>.focusout()</code></li>
  <li><code>.hover()</code></li>
  <li><code>.mousedown()</code></li>
  <li><code>.mouseenter()</code></li>
  <li><code>.mouseleave()</code></li>
  <li><code>.mousemove()</code></li>
  <li><code>.mouseout()</code></li>
  <li><code>.mouseover()</code></li>
  <li><code>.mouseup()</code></li>
</ul>

<h2 id="effects">Effects</h2>

<p>이벤트와 버금가게, jQuery는 소수의 커스터마이징 가능한 효과도 제공한다. 이 효과들은 다양한 매서드로 행해지며, 컨텐츠를 보여주고 숨기고, 페이드 인/아웃, 슬라이드 업/다운 등을 위한 이벤트 매서드를 포함한다. 이들 모두가 사용될 매서드가 준비되어 있으며 최적으로 보이도록 커스터마이징될 수 있다.</p>

<p>각 이펙트 매서드는 자신만의 구문을 가지고 있어서, 각 매서드의 특정 구문은 jQuery <a href="http://api.jquery.com/category/effects/">효과 문서</a>를 참조하는 것이 가장 좋다. 그렇지만, 일반적으로 효과는 지속기간(duraton), 이징(easing 역자주: 움직일 때의 애니메이션 <a href="http://gsgd.co.uk/sandbox/jquery/easing/">효과</a>), 콜백함수(역자주 : 애니메이션이 끝난 후 실행되는 함수) 지정 등을 허용한다.</p>

<blockquote>
  <h4 id="jquery-css-animations">jQuery CSS Animations</h4>

  <p>CSS 자체가 최근 애니메이션을 다루는 것과는 관계가 좀 떨어지지만, 다양한 CSS 속성의 맞춤형 애니메이션이 jQuery에서 수행될 수 있다. CSS 애니메이션은 브라우저 처리 관점에서 더 나은 성능을 제공하며, 가능한 곳에선 더 선호된다. jQuery 애니메이션 효과는 - Modernizr의 도움을 받아 - CSS 애니메이션을 지원하는 브라우저에 완벽한 백업 솔루션을 만들어준다.</p>
</blockquote>

<h3 id="effect-duration">Effect Duration</h3>

<p>예로서 <code>.show()</code> 매서드를 사용하면, (선택적으로) 대입할 수 있는 첫 패러미터는 지속시간이며, 키워드와 밀리초 값을 사용해 수행될 수 있다. <code>slow</code> 키워드는 <code>600</code> 밀리초를, <code>fast</code> 키워드는 <code>200</code> 밀리초를 기본으로 한다. 키워드 값을 사용하는 건 완벽하지만, 밀리초 값을 직접 대입할 수도 있다. 키워드 값은 인용부호로 감싸지만, 밀리초 값은 그러지 않는다.</p>

<pre><code>$('.error').show();
$('.error').show('slow');
$('.error').show(500);
</code></pre>

<h3 id="effect-easing">Effect Easing</h3>

<p>지속시간을 설정함과 더불어, 애니메이션 안에서 다양한 시간 동안 애니메이션이 처리되는 이징(easing) 혹은 속도 등도 설정될 수 있다. 기본적으로 jQuery는 두 개의 이징 키워드 값이 있다. 기본값은 <code>swing</code>이고 추가적인 값은 <code>linear</code>이다. 기본 <code>swing</code> 값은 느린 속도로 애니메이션을 시작하여 애니메이션 되는 중에 속도를 내지만, 끝나기 전에는 속도를 늦춘다. <code>linear</code> 값은 처움부터 끝까지 하나의 일정한 속도로 애니메이션이 진행된다.</p>

<pre><code>$('.error').show('slow', 'linear');
$('.error').show(500, 'linear');
</code></pre>

<blockquote>
  <h4 id="jquery-ui">jQuery UI</h4>

  <p>jQuery에서 제공되는 두 개의 이징 값은 추가적인 값을 제공할 수 있는 다양한 플러그인을 사용하여 확장될 수 있다. 가장 인기있는 플러그인 중 하나는 <a href="http://jqueryui.com/">jQuery UI</a> 이다.</p>

  <p>새 이징 값에 더해 jQuery UI는 살펴볼만한 소수의 다른 상호작용, 효과, 위젯과 도움되는 리소스를 제공한다.</p>
</blockquote>

<h3 id="effect-callback">Effect Callback</h3>

<p>애니메이션이 끝나면 콜백 함수라 불리는 또 다른 함수를 실행할 수 있다. 콜백 함수는, 존재한다면, 지속시간(duration)이나 이징(easing) 뒤에 배치해야 한다. 이 함수에서 새로운 이벤트나 효과가 배치될 수 있으며, 각각 자신의 필요한 구문을 따른다.</p>

<pre><code>$('.error').show('slow', 'linear', function(event){
  $('.error .status').text('Continue');
});
</code></pre>

<h3 id="effect-syntax">Effect Syntax</h3>

<p>전에 언급되었듯이 각 효과 매서드는 jQuery <a href="http://api.jquery.com/category/effects/">효과 문서</a>에서 찾을 수 있는 자신의 구문을 가진다. 여기서 약술한 지속시간, 이징, 콜백 매개변수는 일반적인 것이고 모든 매서드에서 쓸 수 있는 것은 아니다. 관련해서 의문 사항이 생기면 매서드의 구문을 재검토하는 것이 가장 좋다.</p>

<h3 id="effects-demo">Effects Demo</h3>

<p>위에서와 같은 이벤트 데모를 취하면, 여기서 <code>.remove()</code> 매서드는 <code>.fadeOut()</code> 매서드에서 콜백 함수의 부분으로 사용된다. <code>.fadeOut()</code> 매서드를 사용하면 경고 메시지가 재빨리 사라지기 보단 점차로 페이드 아웃되게 하며, 애니메이션이 완료된 후 DOM에서 제거된다.</p>

<blockquote>
  <h6 id="html-1">HTML</h6>

  <pre><code>&lt;div class="alert-warning"&gt;
  &lt;strong&gt;Warning!&lt;/strong&gt; I’m about to lose my cool.
  &lt;div class="alert-close"&gt;×&lt;/div&gt;
&lt;/div&gt;
</code></pre>

  <h6 id="javascript-1">JavaScript</h6>

  <pre><code>$('.alert-close').on('click', function(event){
  $('.alert-warning').fadeOut('slow', function(event){
    $(this).remove();
  });
});
</code></pre>

  <h4 id="demohttpjmpzexzyb"><a href="http://j.mp/ZExZyB">Demo</a></h4>
</blockquote>

<h4 id="basic-effects">Basic Effects</h4>

<ul>
  <li><code>.hide()</code></li>
  <li><code>.show()</code></li>
  <li><code>.toggle()</code></li>
</ul>

<h4 id="custom-effects">Custom Effects</h4>

<ul>
  <li><code>.animate()</code></li>
  <li><code>.clearQueue()</code></li>
  <li><code>.delay()</code></li>
  <li><code>.dequeue()</code></li>
  <li><code>jQuery.fx.interval</code></li>
  <li><code>jQuery.fx.off</code></li>
  <li><code>.queue()</code></li>
  <li><code>.stop()</code></li>
</ul>

<h4 id="fading-effects">Fading Effects</h4>

<ul>
  <li><code>.fadeIn()</code></li>
  <li><code>.fadeOut()</code></li>
  <li><code>.fadeTo()</code></li>
  <li><code>.fadeToggle()</code></li>
</ul>

<h4 id="sliding-effects">Sliding Effects</h4>

<ul>
  <li><code>.slideDown()</code></li>
  <li><code>.slideToggle()</code></li>
  <li><code>.slideUp()</code></li>
</ul>

<blockquote>
  <h3 id="slide-demo">Slide Demo</h3>

  <h6 id="html-2">HTML</h6>

  <pre><code>&lt;div class="panel"&gt;
  &lt;div class="panel-stage"&gt;&lt;/div&gt;
  &lt;a href="#" class="panel-tab"&gt;Open &lt;span&gt;▼&lt;/span&gt;&lt;/a&gt;
&lt;/div&gt;
</code></pre>

  <h6 id="javascript-2">JavaScript</h6>

  <pre><code>$('.panel-tab').on('click', function(event){
  event.preventDefault();
  $('.panel-stage').slideToggle('slow', function(event){
    if($(this).is(':visible')){
      $('.panel-tab').html('Close ▲');
    } else {
      $('.panel-tab').html('Open ▼');
    }
  });
});
</code></pre>

  <h4 id="demohttpjmp11cl156"><a href="http://j.mp/11Cl156">Demo</a></h4>
</blockquote>

<h3 id="tabs-demo">Tabs Demo</h3>

<blockquote>
  <h6 id="html-3">HTML</h6>

  <pre><code>&lt;ul class="tabs-nav"&gt;
  &lt;li&gt;&lt;a href="#tab-1"&gt;Features&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="#tab-2"&gt;Details&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="tabs-stage"&gt;
  &lt;div id="tab-1"&gt;...&lt;/div&gt;
  &lt;div id="tab-2"&gt;...&lt;/div&gt;
&lt;/div&gt;
</code></pre>

  <h6 id="javascript-3">JavaScript</h6>

  <pre><code>// Show the first tab by default
$('.tabs-stage div').hide();
$('.tabs-stage div:first').show();
$('.tabs-nav li:first').addClass('tab-active');
// Change tab class and display content
$('.tabs-nav a').on('click', function(event){
  event.preventDefault();
  $('.tabs-nav li').removeClass('tab-active');
  $(this).parent().addClass('tab-active');
  $('.tabs-stage div').hide();
  $($(this).attr('href')).show();
});
</code></pre>

  <h4 id="demohttpjmp1052yx1"><a href="http://j.mp/1052YX1">Demo</a></h4>
</blockquote>

<h2 id="resources-amp-links">Resources &amp; Links</h2>

<ul>
  <li><a href="http://jsforcats.com/">JavaScript For Cats</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/JavaScript/A_re-introduction_to_JavaScript">A Re-introduction to JavaScript</a> via Mozilla Developer Network</li>
  <li><a href="https://tutsplus.com/course/30-days-to-learn-jquery/">30 Days to Learn jQuery</a> via Tuts+ Premium</li>
  <li><a href="https://developers.google.com/speed/libraries/devguide">Google Hosted Libraries</a></li>
  <li><a href="http://docs.jquery.com/">jQuery Documentation</a></li>
  <li><a href="http://jqfundamentals.com/">jQuery Fundamentals</a> via Bocoup</li>
  <li><a href="http://jqueryui.com/">jQuery UI</a></li>
</ul>

<h3 id="section">역자참조링크</h3>
<ul>
  <li><a href="http://www.jquerykorea.pe.kr/xe/?mid=document&amp;CT=All">jQuery API 한글 번역</a></li>
  <li><a href="http://direct.co.kr/cs/jQuery.pdf">한글 jQuery 시리즈 강좌 리스트 : PDF와 동영상 링크</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML & CSS 중급자 가이드 - 4강 : 반응형 웹 디자인]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/advanced-guide-to-html-and-css-4-slash-10/"/>
    <updated>2013-07-22T21:20:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/advanced-guide-to-html-and-css-4-slash-10</id>
    <content type="html"><![CDATA[<p>원본 : <a href="http://learn.shayhowe.com/advanced-html-css/responsive-web-design">An Advanced Guide to HTML &amp; CSS - LESSON 4 : Responsive Web Design</a></p>

<p>인터넷은 누구도 예측할 수 없을 정도로 빠르게, 미친듯이 성장했다. 최근 수 년간 모바일 성장이 현장에서 폭발하고 있다. 모바일 인터넷 사용의 성장도 일반 인터넷 사용의 성장을 훨씬 뛰어넘고 있다.</p>

<p>요즘 인터넷에 연결되는 모바일 기기를 하나 이상 갖고 있지 않은 사람을 찾는 것은 힘들다. 영국에선 인구보다 <a href="http://www.gpmd.co.uk/blog/2012-mobile-internet-statistics/">모바일 폰</a>이 더 많고, 모바일 인터넷 사용이 데스크탑 인터넷 사용을 올해 추월하는 <a href="http://www.digitalbuzzblog.com/2011-mobile-statistics-stats-facts-marketing-infographic/">트랜드가 이어지고 있다</a>.</p>

<p>모바일 인터넷 사용이 계속 성장하면서 어떻게 모든 유저에게 적합한 웹사이트를 만들 것인가 하는 질문이 제기되고있다. 업계는 이 질문에 반응형 웹 디자인(responsive web design : RWD로 응답하고 있다.
<!-- more --></p>

<h2 id="responsive-overview">Responsive Overview</h2>

<p>반응형 웹 디자인은 모바일 혹은 데스트탑의 모든 기기와 크고 작은 모든 스크린 사이즈에서 적절하게 작동하는 웹사이트를 만드는 것이다.</p>

<p>반응형 웹 디자인은 모든 사람에게 직관적이고 만족스런 경험을 제공하는 것에 초점을 두며, 데스크탑 유저와 폰 유저 모두에게 같은 이익을 제공한다.</p>

<p>반응형 웹 디자인<a href="http://www.alistapart.com/articles/responsive-web-design/">responsive web design</a> 용어는 Ethan Marcotte가 만들어냈고 주로 키웠다. 이 강의에서 다루는 많은 것은 Ethan 온라인과 그의 책 <a href="http://www.abookapart.com/products/responsive-web-design/">Responsive Web Design</a>에서 먼저 이야기된 것이다.</p>

<p><img src="http://learn.shayhowe.com/assets/courses/advanced-html-css-guide/responsive-web-design/food-sense.png" alt="Food Sense Responsive Layout" /></p>

<p><strong>Fig. 4.01</strong> </p>

<p><a href="http://foodsense.is/">Food Sense</a>는 아름다운 웹사이트이며, 모든 다른 뷰포트 사이즈에 반응한다. 크건 작건 뷰포트에 웹사이트가 조절되어 자연스런 사용자 경험을 만든다.</p>

<p>역자 참조 링크</p>

<ul>
  <li><a href="http://www.w3.org/TR/CSS2/visuren.html#viewport">Viewport</a> : 화면의 창 또는 보이는 영역</li>
</ul>

<h3 id="responsive-vs-adaptive-vs-mobile">Responsive vs. Adaptive vs. Mobile</h3>

<p><em>Responsive</em>(반응형) 와 <em>adaptive</em>(적응형) 웹 디자인은 밀접하게 연관되며, 종종 같은 의미로 사용된다. 반응형은 일반적으로 어떤 변화에도 빠르고 적극적으로 반응하는 것을 의미하는 반면 적응형은 (<em>변화</em>와 같은) 새로운 목적이나 상황에 쉽게 변경되는 것을 의미한다. 반응형 디자인에서는 웹사이트가 뷰포트 너비와 같은 요인에 지속적으고 유동적으로 변하지만, 적응형 웹사이트는 미리 정해진 요인들에 맞추어 만들어진다. 두 가지의 결합이 이상적이며, 기능적 웹사이트를 위한 완벽한 공식을 제공한다. 어떤 용어가 사용되는가가 특별히 커다란 차이를 만들지는 않는다.</p>

<p><em>Mobile</em>은 일반적으로 모바일 유저만을 위한 새 도메인에 별도의 웹사이트를 만드는 것을 의미한다. 모바일 웹사이트는 극도로 가벼울 수 있지만 새 코드 베이스와 브라우저 스니핑에 의존한다. 이는 개발자와 유저 모두에게 장애물이 될 수 있다.</p>

<p>역자 주 - <a href="http://en.wikipedia.org/wiki/Browser_sniffing">Browser sniffing</a> : 유저의 브라우저가 어떤 것인지 판별하는 것</p>

<p>현재 가장 인기있는 기술은 다른 브라우저와 기기 뷰포트에 따라 레이아웃과 컨텐츠가 변하면서 생동적으로 적응하는 디자인을 선호하는 반응형 웹 디자인에 있다. 이러 해법은 반응형, 적응형과 모바일 모두의 이점을 가지고 있다.</p>

<h2 id="flexible-layouts">Flexible Layouts</h2>

<p>반응형 웹 디자인은 가변(flexible) 레이아웃, 미디어 쿼리, 가변(flexible) 미디어의 세 가지 주요 부분으로 나뉜다.  첫번째 부분인 가변 레이아웃은 어떠한 너비에도 생동적으로 재조정할 수 있는 가변 그리드로 웹 사이트의 레이아웃을 만드는 것이다. 가변 그리드는 대부분 퍼센트나 <code>em</code> 등의 상대적인 길이 단위를 사용한다. 이 상대적인 길이들은 <code>width</code>, <code>margin</code>, <code>padding</code>과 같은 일반적인 그리드 속성값으로 사용된다.</p>

<h4 id="relative-viewport-lengths">Relative Viewport Lengths</h4>

<p>CSS3에서는 몇 개의 새로운 상대 길이 단위가 <a href="http://dev.w3.org/csswg/css3-values/#viewport-relative-lengths">도입되었다</a>. 이는 브라우저나 디바이스의 뷰포트 크기와 특히 관련된 것이며, <code>vw</code>, <code>vh</code>, <code>vmin</code>, <code>vmax</code> 등을 포함한다. 이러한 새로운 단위들에 대한 전체적인 지원은 훌륭하진 않으나 확대되고 있고, 조만간 반응형 웹사이트를 만드는 데에 커다란 역할을 하는 것이다.</p>

<ul>
  <li><code>vw</code>        : Viewports width</li>
  <li><code>vh</code>        : Viewports height</li>
  <li><code>vmin</code>  : Minimum of the viewport’s height and width</li>
  <li><code>vmax</code>  : Maximum of the viewport’s height and width</li>
</ul>

<p>가변 레이아웃은 픽셀이나 인치와 같은 고정 측정 단위를 지원하지 않는다. 기기마다 뷰포트 높이와 너비가 지속적으로 변하기 때문이다. 웹사이트 레이아웃은 이런 변화에 적응할 필요가 있으며 고정 값은 너무 많은 제약이 있다. 다행히 Ethan이 상대값을 사용한 가변 레이아웃의 비율을 선언하는 것을 도와주는 쉬운 공식을 밝혀냈다.</p>

<p>그 공식은 엘리먼트의 목표(target) 너비를 부모 엘리먼트의 너비로 나누어 목표 엘리먼트의 상대적인 너비를 구하는 것이다.</p>

<pre><code>반응형 디자인 공식 : target ÷ context = result
</code></pre>

<h3 id="flexible-grid">Flexible Grid</h3>

<p>이 공식이 두 열(column) 레이아웃 안에서 어떻게 동작하는지 보자. 아래에서 <code>container</code> 클래스의 부모 <code>div</code>가 <code>section</code>과 <code>aside</code> 엘리먼트를 감싸고 있다. <code>section</code>을 왼쪽으로 <code>aside</code>를 오른쪽으로 위치하면서 둘 사이에 같은 마진을 갖게하는 것이 목표다. 보통 이러한 레이아웃의 마크업과 스타일은 다음과 유사할 것이다.</p>

<h6 id="html">HTML</h6>

<pre><code>&lt;div class="container"&gt;
  &lt;section&gt;...&lt;/section&gt;
  &lt;aside&gt;...&lt;/aside&gt;
&lt;/div&gt;
</code></pre>

<h6 id="css">CSS</h6>

<pre><code>.container {
  width: 660px;
}
section {
  float: left;
  margin: 10px;
  width: 420px;
}
aside {
  float: right;
  margin: 10px;
  width: 200px;
}
</code></pre>

<h4 id="fixed-grid-demohttplearnshayhowecomadvanced-html-cssresponsive-web-designfixed-grid-demo"><a href="http://learn.shayhowe.com/advanced-html-css/responsive-web-design#fixed-grid-demo">Fixed Grid Demo</a></h4>

<p>가변 그리드 공식을 사용하여 길이의 고정 단위를 상대 단위로 변경할 수 있다. 이 예제에선 퍼센트를 사용하겠지만 <code>em</code> 단위도 동일하게 작동할 것이다. 부모 <code>container</code>의 너비에 상관없이 <code>section</code>과 <code>aside</code>의 마진과 너비는 비율적으로 크기가 변동될 것이다.</p>

<pre><code>.container {
  max-width: 660px;
}
section {
  float: left;
  margin: 1.51515151%;   /*  10px ÷ 660px = .01515151 */
  width: 63.63636363%;   /* 420px ÷ 660px = .63636363 */   
}
aside {
  float: right;
  margin: 1.51515151%;   /*  10px ÷ 660px = .01515151 */
  width: 30.30303030%;   /* 200px ÷ 660px = .30303030 */
}
</code></pre>

<h4 id="flexible-grid-demohttplearnshayhowecomadvanced-html-cssresponsive-web-designflexible-grid-demo"><a href="http://learn.shayhowe.com/advanced-html-css/responsive-web-design#flexible-grid-demo">Flexible Grid Demo</a></h4>

<p>가변 레이아웃 개념과 공식을 갖고 그리드의 모든 부분에 재적용하면 완벽하게 동적인 웹사이트를 만들 수 있다. 위의 부모 <code>container</code>에서 했듯이 <code>min-width</code>, <code>max-width</code>, <code>min-height</code>, <code>max-height</code> 속성을 수단으로 가변 레이아웃에서 훨씬 더 많은 컨트롤을 할 수 있다.</p>

<p>가변 레이아웃 접근법만으론 충분치 않다. 브라우저 뷰포트의 너비가 너무 작을 때는 레이아웃의 크기를 비율적으로 조절하더라도 열의 크기가 너무 작아 컨텐츠를 효과적으로 표시할 수 없다. 레이아웃이 너무 작거나 크면 텍스트는 읽기 어렵게 되고, 레이아웃이 깨지기 시작할 것이다. 이런 경우엔 미디어 쿼리가 더 나은 경험을 만드는데 도움이 될 수 있다.</p>

<h2 id="media-queries">Media Queries</h2>

<p>미디어 쿼리는 개별 브라우저와 디바이스 환경(예를 들면 뷰포트 너비 혹은 기기 오리엔테이션 등)에 각기 다른 스타일을 제공할 수 있는 확장 기능이다. <a href="http://css-tricks.com/css-media-queries/">타겟 스타일</a>을 독자적으로 제공할 수 있다는 것은 반응형 웹 디자인에 기회과 수단의 세계를 활짝 열어준다.</p>

<h3 id="initializing-media-queries">Initializing Media Queries</h3>

<p>미디어 쿼리를 사용하는 방법은 두 가지가 있다. 기존의 스타일 시트에 <code>@media</code> 룰을 사용하고 <code>@import</code> 룰을 사용하여 새로운 스타일 시트를 들여오거나(import), HTML 문서 안에서 별도의 스타일을 링크하는 것이다. 일반적으로 추가적인 HTTP 요청을 피하기 위해 기존 스타일 시트안에 <code>@media</code> 룰을 사용하는 것이 추천된다.</p>

<h6 id="html-1">HTML</h6>

<pre><code>&lt;!-- Separate CSS File --&gt;
&lt;link href="styles.css" rel="stylesheet" 
media="all and (max-width: 1024px)"&gt;
</code></pre>

<h6 id="css-1">CSS</h6>

<pre><code>/* @media Rule */
@media all and (max-width: 1024px) {...}

/* @import Rule */
@import url(styles.css) all and (max-width: 1024px) {...}
</code></pre>

<p>각 미디어 쿼리는 하나 또는 그 이상의 표현이 뒤따르는 미디어 타입을 포함할 수 있다. 일반적인 미디어 타입은 <code>all</code>, <code>screen</code>, <code>print</code>, <code>tv</code>, <code>braille</code>을 포함한다. HTML5 사양(specifition)은 <code>3d-glasses</code>도 포함하는 새로운 미디어 타입을 포함한다. 미디어 타입을 명시하지 않으면 미디어 쿼리는 미디어 타입을 <code>screen</code>으로 기본으로할 것이다.</p>

<p>미디어 쿼리 표현식은 다른 미디어 특성과 값을 포함할 수 있으며 그리고나서 참(true) 혹은 거짓(false)를 할당한다. 미디어 특성과 값이 참으로 할당될 때 해당 스타일이 적용되며, 거짓이면 해당 스타일은 무시된다.</p>

<h3 id="logical-operators-in-media-queries">Logical Operators in Media Queries</h3>

<p>미디어 쿼리에서 논리적 연산자(logical operator)는 강력한 표현식을 만들 수 있게 해준다. <code>and</code>, <code>not</code>, <code>only</code>의 세 개의 연산자를 사용할 수 있다.</p>

<p><code>and</code> 논리 연산자를 사용하여 브라우저나 기기가 a,b,c 등으로 지정하여 추가적인 조건을 추가할 수 있다. 여러 개의 개별 미디어 쿼리는 콤마로 분리될 수 있으며 암묵적인 <code>or</code> 연산자처럼 동작한다. 아래 예는 <code>800</code>과 <code>1024</code> 픽셀 너비의 모든 미디어 타입을 선택한다.</p>

<pre><code>@media all and (min-width: 800px) and (max-width: 1024px) {...}
</code></pre>

<p><code>not</code> 논리 연산자는 명시된 것을 제외한 모든 쿼리를 특정하여 선언된 쿼리를 부정한다. 아래 예에서는 표현식은 컬러 스크린을 갖지 않는 모든 디바이스에 적용된다. 즉, 흑백이나 모노 스크린에 적용된다.</p>

<pre><code>@media not screen and (color) {...}
</code></pre>

<p><code>only</code> 논리 연산자는 새로운 연산자이며 HTML4 알고리즘을 사용하는 유저 에이전트로는 인식되지 않으므로, 미디어 쿼리를 지원하는 않는 기기나 브라우저에선 스타일이 나타나지 않는다. 아래에서 표현식은 세로 편향(portrait orientation)인 스크린만을 선택한다.</p>

<pre><code>@media only screen and (orientation: portrait) {...}
</code></pre>

<blockquote>
  <h4 id="omitting-a-media-type">Omitting a Media Type</h4>

  <p><code>not</code>과 <code>only</code> 논리 연산자를 사용할 땐 미디어 타입을 쓰지 않을 수 있다. 이 경우 미디어 타입은 <code>all</code>로 전제된다.</p>
</blockquote>

<h3 id="media-features-in-media-queries">Media Features in Media Queries</h3>

<p>미디어 쿼리 문법과 논리 연산자의 작동법을 아는 것은 미디어 쿼리에 대한 훌륭한 입문이나, 실제 작업은 미디어 특성과 함께 한다. 미디어 쿼리 표현식 내에서 어떤 속성이 목표될지를 미디어 특성이 지정한다.</p>

<h4 id="height--width-media-features">Height &amp; Width Media Features</h4>

<p>가장 많이 사용되는 미디어 특성 중 하나는 하나의 디바이스나 브라우저 뷰포트에 하나의 높이나 너비를 결정하는 것에 관련된다. <code>height</code>, <code>width</code>, <code>device-height</code>, <code>device-width</code>의 미디어 특성을 사용해서 높이와 너비는 찾을 수 있다. 각 미디어 특성은 <code>min</code> 혹은 <code>max</code> 수식어로 접두될 수 있어 <code>min-width</code> 혹은 <code>max-device-width</code>과 같은 특성을 만들 수 있다.</p>

<p><code>height</code>와 <code>width</code> 특성은 (브라우저 창과 같은) 뷰포트 렌더링 영역의 높이와 너비에 기반하며, 한편 <code>device-height</code>와 <code>device-width</code> 특성은 (실제 렌더링 영역보다 더 클 수 있는) 출력 기기의 높이와 너비에 기반한다. 이 높이와 너비 미디어 특성 값은 (상대적이거나 절대적인) 어떠한 길이 값도 될 수 있다.</p>

<pre><code>@media all and (min-width: 320px) and (max-width: 780px) {...}
</code></pre>

<p>반응형 디자인에서는 <code>min-width</code>과 <code>max-width</code>를 포함하는 특성이 가장 많이 사용된다. 이것들은 기기 특성에 혼동을 피해 데스크탑과 모바일 기기에 동일하게 반응형 웹사이트를 만드도록 해준다.</p>

<blockquote>
  <h4 id="using-minimum--maximum-prefixes">Using Minimum &amp; Maximum Prefixes</h4>

  <p><code>min</code>과 <code>max</code> 접두어는 꽤 많은 미디어 특성에서 사용될 수 있다. <code>min</code> 접두어는 보다 크거나 같은 값을 가리키며, <code>max</code> 접두어는 더 적거나 같은 값을 가리킨다. <code>min</code>과  <code>max</code> 접두어는 일반적인 HTML 문법과 충돌되지 않아 특별히 꺽쇠 심볼을 사용하지 않는다.</p>
</blockquote>

<h4 id="orientation-media-feature">Orientation Media Feature</h4>

<p><code>orientation</code> 미디어 특성은 기기가 <code>landscape</code>나 <code>portrait</code> 편향(orientation)인지를 결정한다. <code>landscape</code> 모드는 화면이 가로 모드일 때, <code>portrait</code> 모드는 화면이 세로 모드일 때이며, 모바일 기기에서 널리 사용된다.</p>

<pre><code>@media all and (orientation: landscape) {...} 
</code></pre>

<h4 id="aspect-ratio-media-features">Aspect Ratio Media Features</h4>

<p><code>aspect-ratio</code>와 <code>device-aspect-ratio</code> 특성은 목표 렌더링 영역 혹은 출력 기기의 <code>width/height</code> 픽셀 비율을 지정한다. <code>min</code>와 <code>max</code> 접두어가 사용될 수 있다.</p>

<p>종횡비(aspect ratio) 값은 /로 분리되는 두 개의 양의 정수로 구성된다. 첫 정수는 픽셀 너비를, 두번째 정수는 픽셀 높이이다.</p>

<pre><code>@media all and (min-device-aspect-ratio: 16/9) {...}
</code></pre>

<blockquote>
  <h4 id="pixel-ratio-media-features">Pixel Ratio Media Features</h4>

  <p>종횡비 특성에 더해 <code>pixel-ratio</code> 미디어 특성도 있다. 이 특성은 <code>device-pixel-ratio</code> 특성을 포함하며, <code>min</code>과 <code>max</code> 접두어도 가진다. 특히 픽셀비 특성은 레티나 디스플레이와 같은 고해상도 기기를 지정할 때 훌륭하며, 다음처럼 보여질 것이다.</p>

  <p>   @media only screen and (-webkit-min-device-pixel-ratio: 1.3), only screen and (min-device-pixel-ratio: 1.3) {…}</p>
</blockquote>

<h4 id="resolution-media-feature">Resolution Media Feature</h4>

<p><code>resolution</code> 미디어 특성은 DPI(dots per inch)로 알려진 픽셀 밀도로 출력 기기의 해상도를 지정한다. <code>min</code>과 <code>max</code>를 접두할 수 있다. 게다가 <code>resolution</code> 미디어 속성은 dots per pixel (<code>1.3dppx</code>), dots per centimeter (<code>118dpcm</code>)와 같은 길이 기반 해상도 값을 가질 수도 있다.</p>

<pre><code>@media print and (min-resolution: 300dpi) {...}
</code></pre>

<h4 id="other-media-features">Other Media Features</h4>

<p><code>color</code>, <code>color-index</code>, <code>monochrome</code> 특성은 출력 색상을, <code>grid</code> 특성은 비트맵 기기를, <code>scan</code> 특성은 텔레비전의 스캐닝 처리를 지정하며, 자주 사용하지는 않지만 필요할 땐 도움이 된다.</p>

<blockquote>
  <h4 id="media-query-browser-support">Media Query Browser Support</h4>

  <p>불행하게도 미디어 쿼리는 인터넷 익스플로러 8 이하와 고전적인 브라우저에서는 작동하지 않는다. 그러나, 자바스크립트로 쓰여진 두 개의 알맞는 땜빵(polyfill)이 있다.</p>

  <p><a href="https://github.com/scottjehl/Respond/">Respond.js</a>는 min/max-witdh 타입만을 위한 가벼운 땜빵이며, 미디어 쿼리 타입만 사용된다면 완벽하다. <a href="http://code.google.com/p/css3-mediaqueries-js/">CSS3-MediaQueries.js</a>는 더 많이 개발되고 더 무겁지만 더 복잡한 미디어 쿼리의 더 큰 배열을 지원하는 땜빵이다. 추가적으로 어떠한 땜빵이라도 성능 문제를 가져올 수 있으며, 잠재적으로 웹사이트를 느리게 할 수 있다는 것을 명심해야한다. 주어진 땜빵이 성능과 맞바꿀만한지 확인해야한다.</p>
</blockquote>

<h3 id="media-queries-demo">Media Queries Demo</h3>

<p>이제 미디어 쿼리를 사용하여 전에 만들었던 가변 레이아웃을 다시 코딩하자. 데모의 현재 문제점 중 하나는 <code>aside</code>가 아주 작은 뷰포트에서 사용할 수 없을 정도로 작아진다는 것이다. <code>420</code> 픽셀 너비 아래의 뷰포트를 위해 미디어 쿼리를 추가하여 <code>float</code>를 꺼버리고 <code>section</code>과 <code>aside</code>의 너비를 변화시키는 레이아웃으로 변경할 수 있다.</p>

<pre><code>@media all and (max-width: 420px) {
  section, aside {
    float: none;
    width: auto;
  }
}
</code></pre>

<p><strong>Fig. 4.02</strong> 미디어 쿼리 없이는 <code>section</code>과 <code>aside</code> 너무 작아 진다. 너무 작아서 어떤 실제 컨텐츠도 담을 수 없다.
<img src="http://learn.shayhowe.com/assets/courses/advanced-html-css-guide/responsive-web-design/without-media-queries.png" alt="Demo without Media Queries" /></p>

<p><strong>Fig. 4.03</strong> 미디어 쿼리를 사용하여 <code>float</code>를 제거하고 너비를 변경하면, <code>section</code>과 <code>aside</code>가 뷰포트 전체 너비를 차지하고 기존의 컨텐츠에 충분한 공간이 생겼다.
<img src="http://learn.shayhowe.com/assets/courses/advanced-html-css-guide/responsive-web-design/with-media-queries.png" alt="Demo with Media Queries" /></p>

<blockquote>
  <h4 id="identifying-breakpoints">Identifying Breakpoints</h4>

  <p>당신의 직관이 각기 다른 기기 해상도로 결정되는 공통적인 뷰포트 사이즈의 미디어 쿼리 분기점(<code>320px</code>, <code>480px</code>, <code>768px</code>, <code>1024px</code>, <code>1224px</code> 등)을 쓸지도 모르겠다. 그러나 이건 <strong>나쁜</strong> 아이디어이다.</p>

  <p>반응형 웹사이트를 만들 때는 기기만아니라 다른 뷰포트 사이즈의 배열에 맞추어 조정되어야 한다. 웹사이트가 깨지거나 이상하게 보이기 시작할 때 혹은 경험이 방해받을 때에만 분기점(breakpoint)이 도입되어야 한다.</p>

  <p>게다가 새로운 기기와 해상도는 항상 출시된다. 이러한 변화를 따라가려는 것은 끝없는 과정일 수 있다.</p>
</blockquote>

<h2 id="mobile-first">Mobile First</h2>

<p>미디어 쿼리와 함께 가장 인기있는 기술은 <em>mobile first</em>로 불리우는 것이다. <a href="http://www.lukew.com/presos/preso.asp?26">mobile first</a> 접근법은 작은 뷰포트의 스타일을 기본 웹사이트 스타일로 한 다음 뷰포트가 커짐에 따른 스타일을 추가하기위해 미디어 쿼리를 사용한다.</p>

<p>모바일 퍼스트 디자인의 배경에서 작동되는 믿음은 일반적으로 더 작은 뷰포트를 사용하는 모바일 기기 유저는 모바일 스타일을 덮어쓰기만을 위해 테스크탑 스타일을 로드할 필요가 없다는 것이다. 그렇게 하는 것은 대역폭(bandwidth)의 낭비이다. 쾌적한 웹사이트를 기대하는 어떤 유저에게도 귀중한 대역폭 말이다.</p>

<p>모바일 퍼스트 접근법은 모바일 유저의 제한을 염두에 두고 디자인하는 것을 지원하기도 한다. 오래 전에 인터넷 소비의 태반이 모바일 기기로 이루어질 것으로 예상되었다. 적절하게 그것을 계획하고 본질적인 모바일 경험을 개발하라.</p>

<p>모바일 퍼스트 미디어 쿼리는 다음과 같을 것이다.</p>

<pre><code>/* Default styles first then media queries */
@media screen and (min-width: 400px)  {...}
@media screen and (min-width: 600px)  {...}
@media screen and (min-width: 1000px) {...}
@media screen and (min-width: 1400px) {...}
</code></pre>

<p>불필요한 미디어를 다운로드하는 것은 미디어 쿼리를 사용하여 중지시킬 수 있다. 일반적으로 모바일 스타일에서 CSS3 그림자, 그라디언트, 변형(transform), 애니메이션 등을 피하는 것은 나쁜 아이디어가 아니다. 지나치게 사용되면 로딩이 무겁게되고, 기기의 배터리를 빨리 닳게할 수도 있다.</p>

<pre><code>/* Default media */
body {
  background: #ddd;
}
/* Media for larger devices */
@media screen and (min-width: 800px) {
  body {
    background-image: url("bg.png") 50% 50% no-repeat;
  }
}
</code></pre>

<h3 id="mobile-first-demo">Mobile First Demo</h3>

<p>이전 예제에 미디어 쿼리를 추가하면 <code>420</code> 픽셀 너비 미만에서 더 나은 레이아웃을 얻기위해 약간의 스타일을 겹쳐쓰자. 모바일 스타일 퍼스트를 기본으로 사용하기 위해 코드를 다시 쓰고 <code>420</code> 픽셀 이상의 뷰포트에 맞추기 위해 미디어 쿼리를 추가하면 다음과 같다.</p>

<p><a href="http://learn.shayhowe.com/courses/advanced-html-css/responsive-web-design/responsive-web-design-demo.html">View this code in action.</a></p>

<pre><code>section, aside {
  margin: 1.51515151%;
}
@media all and (min-width: 420px) {
  .container {
    max-width: 660px;
  }
  section {
    float: left;
    width: 63.63636363%;
  }
  aside {
    float: right;
    width: 30.30303030%;
  }
}
</code></pre>

<p>코드 양이 전과 같음을 주목하라. 여기서 유일한 예외는 모바일 기기는 <strong>하나의</strong> CSS 선언만 렌더링해야만 한다는 것이다. 뒤따르는 나머지 스타일은 더 큰 뷰포트에서만 로드되고 어떤 선행 스타일을 겹쳐쓰지 않는다.</p>

<h2 id="viewport">Viewport</h2>

<p>요사이 모비일 기기는 일반적으로 웹사이트를 꽤 잘 보여주고 있다. 때때로 <a href="http://dev.opera.com/articles/view/an-introduction-to-meta-viewport-and-viewport/">뷰포트</a> 사이즈, 스케일, 웹사이트 해상도 등을 별도로 지정해주어 약간의 지원을 해줄 수 있다. 이것을 개선하기 위해 애플이 <code>viewport</code> 메타 태그를 만들었다.</p>

<p><strong>Fig. 4.04</strong>
이 데모는 미디어 쿼리를 사용했음에도 많은 모바일 기기들이 아직 웹사이트의 최초 너비나 크기를 알 수 없어서 미디어 쿼리가 적용되지 않을지도 모른다.
<img src="http://learn.shayhowe.com/assets/courses/advanced-html-css-guide/responsive-web-design/without-viewport.png" alt="Website without Viewport Meta Tag" /></p>

<h4 id="viewport-height--width">Viewport Height &amp; Width</h4>

<p><code>viewport</code> 메타 태그를 <code>height</code>나 <code>width</code> 값과 함께 사용하면 뷰포트의 높이나 너비를 각각 정의할 것이다. 각각의 값은 양의 정수나 키워드로 받아들인다. <code>height</code> 속성은 키워드 <code>device-height</code> 값을 받아들이고, <code>width</code> 속성은 키워드 <code>device-width</code>를 받아들인다. 이 키워드들을 이용해 기기의 기본 높이와 너비 값을 상속한다.</p>

<p>웹사이트가 가장 최적으로 보이는 결과를 위해 <code>device-height</code>와  <code>device-width</code> 값을 적용하여 기기 디폴트를 사용하는 것을 추천한다.</p>

<pre><code>&lt;meta name="viewport" content="width=device-width"&gt;
</code></pre>

<p><strong>Fig. 4.05</strong>
기기가 웹사이트의 의도된 너비(여기서는 <code>device-width</code>)를 알게하여 웹사이트를 적절한 크기로 나타내고 알맞는 미디어 쿼리를 선태할 수 있다.
<img src="http://learn.shayhowe.com/assets/courses/advanced-html-css-guide/responsive-web-design/with-viewport.png" alt="Website with Viewport Meta Tag" /></p>

<h4 id="viewport-scale">Viewport Scale</h4>

<p>모바일 기기에서 웹사이트의 크기를 조절하고 유저가 웹사이트의 크기를 지속적으로 조절할 수 있게 통제하러면 <code>minimum-scale</code>, <code>maximum-scale</code>, <code>initial-scale</code>, <code>user-scalable</code> 속성을 사용하라.</p>

<p>웹사이트의 <code>initial-scale</code>은 <code>1</code>로 설정해야하고, 이것은 세로 편향일 때의 기기 높이와 뷰포트 크기 간의 비율을 정의한다. 가로 편향에선 기기 너비와 뷰포트 크기간의 비율이 된다. <code>initial-scale</code> 값은 항상 <code>0</code>과 <code>10</code> 사이의 양의 정수이어야 한다.</p>

<pre><code>&lt;meta name="viewport" content="initial-scale=2"&gt; 
</code></pre>

<p><strong>Fig. 4.06</strong> 
<code>1</code>을 넘는 정수를 사용하면 웹사이트는 기본 크기보다 더 크게 확대될 것이다. 이 값을 <code>1</code>로 설정하는 것이 대부분의 공통사항이다.
<img src="http://learn.shayhowe.com/assets/courses/advanced-html-css-guide/responsive-web-design/viewport-scale.png" alt="Viewport Scale Meta Tag" /></p>

<p><code>minimum-scale</code>과 <code>maximum-scale</code> 값은 뷰포트가 얼마나 작고 커질지를 결정한다. <code>minimum-scale</code>을 사용할 경우 그 값은 <code>initial-scale</code>과 같거나 더 작은 양의 정수여야 한다. 같은 이유로 <code>maximum-scale</code> 값은 <code>initial-scale</code>과 같거나 더 큰 양의 정수여야 한다. 이 두 값도 역시 <code>0</code>과 <code>10</code> 사이여야 한다.</p>

<pre><code>&lt;meta name="viewport" content="minimum-scale=0"&gt;
</code></pre>

<p>일반적으로 이 값들은 <code>initial-scale</code>과 같은 값을 설정하지 말아야 한다. 이것은 확대를 못하게 하고 <code>user-scalable</code> 값으로 수행되는 확대 기능을 불가능하게 한다. <code>user-scalable</code> 값을 <code>no</code>로 설정하면 확대하지 못하게 될 것이고, <code>user-scalable</code> 값을 <code>yes</code>로 설정하면 확대 기능(zooming)이 켜진다.</p>

<p>웹사이트의 크기 조절을 가능하게 하는 것은 <strong>나쁜 아이디어</strong>다. 웹사이트를 바라던 대로 보지 못하게 방해하여 접근성과 사용성을 해친다.</p>

<pre><code>&lt;meta name="viewport" content="user-scalable=yes"&gt;
</code></pre>

<h4 id="viewport-resolution">Viewport Resolution</h4>

<p>브라우저가 모든 뷰포트 크기에 맞추어 웹사이트를 크기 조절하는 방법을 결정하게 하려면 일반적으로 트릭을 사용한다. 더 많은 제어가 요구될 때(특히, 기기 해상도 같은)는 <code>target-densitydpi</code>값이 사용될 수 있다. <code>target-densitydpi</code> 뷰포트는 <code>device-dpi</code>, <code>high-dpi</code>, <code>medium-dpi</code>, <code>low-dpi</code> 혹은 실제 DPI 수와 같은 값이 사용된다.</p>

<p><code>target-densitydpi</code> 뷰포트 값은 드물게 사용되지만 픽셀 단위 제어가 필요할 땐 매우 도움이 된다.</p>

<pre><code>&lt;meta name="viewport" content="target-densitydpi=device-dpi"&gt;
</code></pre>

<h4 id="combining-viewport-values">Combining Viewport Values</h4>

<p><code>viewport</code> 메타 태그는 개별 값만이 아니라 멀티 뷰포트 속성을 한번에 설정할 수 있는 멀티 값도 받아들인다. 멀티 값을 설정할 때는 <code>content</code> 속성 값 안에서 <code>,</code>로 분리해야 한다. 추천되는 뷰포트 값은 아래와 같이 <code>width</code>와 <code>initial-scale</code> 속성을 같이 사용하는 것이다.</p>

<pre><code>&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;   
</code></pre>

<p><strong>Fig. 4.07</strong> 
<code>width=device-width</code>와 <code>initial-scale=1</code>의 조합은 일반적으로 요구되는 최초 크기와 줌(zoom)을 제공한다.
<img src="http://learn.shayhowe.com/assets/courses/advanced-html-css-guide/responsive-web-design/with-viewport.png" alt="Website with Viewport Meta Tag" /></p>

<h4 id="css-viewport-rule">CSS Viewport Rule</h4>

<p><code>viewport</code> 메타 태그는 웹사이트가 렌더링되어야 하는 스타일에 강하게 연관되어 있기 때문에 HTML 안의 메타태그보다는 CSS 안에서 <code>@</code> 룰로 옮길 것을 추천한다. 이렇게 하는 것은 컨텐츠에서 스타일을 분리하여 보다 시맨택적으로 접근하는 것을 도와준다.</p>

<p>현재 몇몇 브라우저는 이미 <code>@viewport</code> 룰을 적용했으나 전반적인 지원은 훌륭하지 않다. 위에서 추천된 <code>viewport</code> 메타 태그는 다음 CSS에서의 <code>@viewport</code> 룰과 같이 보여질 것이다.</p>

<pre><code>@viewport {
  width: device-width;
  zoom: 1;
}
</code></pre>

<h2 id="flexible-media">Flexible Media</h2>

<p>마지막 반응형 웹 디자인의 중요한 측면은 가변 미디어와 관련된 것이다. 뷰포트 크기가 변하기 시작하면 미디어가 항상 알맞게 따라오는 것은 아니다. 이미지, 비디오와 같은 미디어 타입은 뷰포트 변화에 맞추어 크기를 변화시킬 필요가 있다.</p>

<p>미디어 크기를 조절할 수 있게 하는 빠른 방법은 <code>max-width</code> 속성을 <code>100%</code> 값으로 주는 것이다. 그렇게 하면 뷰포트가 작아질 때 미디어의 크기가 컨테이너 너비에 맞추어 작아질 것이다.</p>

<pre><code>img, video, canvas {
  max-width: 100%;
}
</code></pre>

<h4 id="flexible-media-demohttplearnshayhowecomadvanced-html-cssresponsive-web-designflexible-media"><a href="http://learn.shayhowe.com/advanced-html-css/responsive-web-design#flexible-media">Flexible Media Demo</a></h4>

<h3 id="flexible-embedded-media">Flexible Embedded Media</h3>

<p>불행히도 <code>max-width</code> 속성이 모든 미디어 실례에서 잘 작동하진 않는다. <code>iframes</code>과 같이 임베딩된 미디어에서 특히 그렇다. 유투브와 같은 서드파티 웹사이트와 함께 할 때 아이프레임을 사용하여 미디어를 임베딩하면 엄청나게 실망하게 된다. 다행히 <a href="http://alistapart.com/article/creating-intrinsic-ratios-for-video">우회 방법</a>이 있다.</p>

<p>반응형을 완벽히 지원하는 임베딩된 미디어를 얻으려면 임베딩된 엘리먼트는 부모 엘리먼트 안에서 절대적으로 배치될(be absolutely positioned) 필요가 있다. 뷰포트의 너비에 기반하여 크기 조절될 수 있도록 부모 엘리먼트의 <code>width</code>가 <code>100%</code>로 요구된다. 또한, 인터넷 익스플로러에서는 <code>hasLayout</code> 매커니즘을 작동시키기 위해서 부모 엘리먼트의 <code>height</code>가 <code>0</code>로 요구된다.</p>

<p>그런 후 부모 엘리먼트의 <code>padding-bottom</code>을 주고, 그 값을 비디오의 종횡비와 같게 설정한다. 이렇게 하면 부모 엘리먼트의 높이가 너비에 비례하게 된다. 이전의 반응형 디자인 공식을 기억하는가? 비디오의 종횡비가 16:9라면 <code>9</code>를 <code>16</code>으로 나누면 <code>.5625</code>가 되며, <code>padding-bottom</code>은 <code>56.25%</code>가 요구된다. <code>padding-bottom</code>이 사용되고 부모 엘리먼트는 절대적으로 배치된 엘리먼트로 다룬다. <code>padding-top</code>은 인터넷 익스플로어 5.5에서 깨지는 방지하기 위해 특별히 사용된다.</p>

<p><em>원문 : Padding on the bottom and not the top is specifically used to prevent Internet Explorer 5.5 from breaking, and treating the parent element as an absolutely positioned element. - 이 부분은 무척 쉬운 듯하면서 몇번을 읽어봐도 정확하게 번역하기 힘들어 내맘대로 말그대로 막번역해버렸다. 마지막 문장이라 노력했지만 역부족이다. 고수님들이 도와주시면 좋겠는데.. ㅠㅠ</em></p>

<h6 id="html-2">HTML</h6>

<pre><code>&lt;figure&gt;
  &lt;iframe src="https://www.youtube.com/embed/4Fqg43ozz7A"&gt;&lt;/iframe&gt;
&lt;/figure&gt;
</code></pre>

<h6 id="css-2">CSS</h6>

<pre><code>figure {
  height: 0;
  padding-bottom: 56.25%; /* 16:9 */
  position: relative;
  width: 100%;
}
iframe {
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
} 
</code></pre>

<h4 id="flexible-embedded-media-demohttplearnshayhowecomadvanced-html-cssresponsive-web-designflexible-embed"><a href="http://learn.shayhowe.com/advanced-html-css/responsive-web-design#flexible-embed">Flexible Embedded Media Demo</a></h4>

<h2 id="resources--links">Resources &amp; Links</h2>

<ul>
  <li><a href="http://www.alistapart.com/articles/responsive-web-design/">Responsive Web Design</a> via A List Apart</li>
  <li><a href="http://dev.w3.org/csswg/css3-values/#viewport-relative-lengths">Viewport Percentage Lengths</a> via W3C</li>
  <li><a href="http://css-tricks.com/css-media-queries/">CSS Media Queries</a> via CSS-Tricks</li>
  <li><a href="http://www.lukew.com/presos/preso.asp?26">Mobile First Presentation</a> via Luke Wroblewski</li>
  <li><a href="http://dev.opera.com/articles/view/an-introduction-to-meta-viewport-and-viewport/">An Introduction to Meta Viewport and @viewport</a> via Dev.Opera</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML & CSS 초보자 가이드 - 5강 : 백그라운드와 그라디언트]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/beginners-guide-to-html-and-css-5-slash-10/"/>
    <updated>2013-07-22T21:08:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/beginners-guide-to-html-and-css-5-slash-10</id>
    <content type="html"><![CDATA[<p>원본 : <a href="http://learn.shayhowe.com/html-css/backgrounds-gradients">A Beginner’s Guide to HTML &amp; CSS - LESSON 5 : Backgrounds &amp; Gradients</a></p>

<p>백그라운드(배경)은 작게 쓰이거나 크게 쓰이거나 웹사이트 전체 디자인에 중요한 시각적 효과를 준다.</p>

<p>CSS3에서는 그라디언트 백그라운드, 하나의 엘리먼트에 여러 백그라운드 이미지 적용 등의 새로운 <a href="http://learn.shayhowe.com/html-css/backgrounds-gradients">백그라운드 특성</a>이 도입되었다.
<!-- more --></p>

<h2 id="adding-a-background-color">Adding a Background Color</h2>

<p>엘리먼트에 백그라운드 적용하는 가장 빠른 방법은 <code>background</code>나 <code>background-color</code> 속성으로 한 가지 색의 백그라운드를 적용하는 것이다. <code>background</code> 속성은 색상과 이미지를, <code>background-color</code>는 백그라운드 색상만을 위해 사용된다.</p>

<pre><code>div {
  background: #f60;
  background-color: #f60;
}
</code></pre>

<p>백그라운드 속성을 선언할 때 16진값, RGB, RGBa, HSL, HSLa의 키워드를 사용한다. 보통 16진수를 사용하며, 알파 채널을 통한 불투명도를 주는 경우는 RGBa와 HSLa를 사용한다. 만약 30% 불투명한 검정을 기대한다면 <code>rgba(0, 0, 0, 0.3)</code>를 사용하면 된다. RGBa와 HSLa는 모든 브라우저에서 지원되는 것은 아니기 때문에 다음과 같이 불투명값을 사용하는 선언 바로 위에 대체 CSS를 선언해야 한다.</p>

<pre><code>div { 
    background: #b2b2b2;
    background: rgba(0,0,0,0.3);
}
</code></pre>

<h2 id="adding-a-background-image">Adding a Background Image</h2>

<p>백그라운드 색상처럼 <code>background</code> 속성이나 <code>background-image</code> 속성을 사용하여 백그라운드 이미지를 추가할 수 있다. 어떤 속성을 사용하던지 간에 백그라운 이미지의 경로 즉, 이미지 소스를 정의하는 <code>url</code> 값을 사용해야 한다.</p>

<pre><code>div {
  background: url('alert.png');
  background-image: url('alert.png');
}
</code></pre>

<p><code>url</code> 값만 사용하면 컨테이너 엘리먼트의 좌상에서부터 수평과 수직 방향으로 반복될 것이다. 다행히 <code>background-repeat</code> 와 <code>background-position</code> 속성을 사용해서 이를 해결할 수 있다.</p>

<h3 id="background-repeat">Background Repeat</h3>

<p>기본적으로 백그라운 이미지는 수평과 수직 방향으로 무한 반복된다. <code>background</code> 속성의 <code>url</code> 값 뒤에 반복 값을 추가하거나 <code>background-repeat</code> 속성으로 반복 값을 지정할 수 있다.</p>

<pre><code>div {
  background: url('alert.png') no-repeat;
  background-image: url('alert.png');
  background-repeat: no-repeat;
}
</code></pre>

<p>백그라운드 반복(repeat)은 <code>repeat</code>, <code>repeat-x</code>, <code>repeat-y</code>, <code>no-repeat</code>의 네 가지 값을 갖는다. <code>repeat</code> 값이 디폴트이며, 수직과 수평 방향으로 이미지를 반복한다. <code>repeat-x</code>는 수평방향으로 이미지를 반복하며, <code>repeat-y</code>는 수직방향으로 반복한다. <code>no-repeat</code>는 백그라운드 이미지를 한번만 표시하며, 반복하지 않는다.</p>

<h3 id="background-position">Background Position</h3>

<p><code>background-position</code> 속성을 사용하면 백그라운드 이미지가 어디에 위치할지와 어디서부터 반복할지를 조정할 수 있다. 다른 백그라운드 속성과 마찬가지로 <code>background</code> 속성의 <code>url</code> 값 뒤에서 지정하거나 <code>background-position</code> 속성으로 별도로 지정할 수 있다.</p>

<pre><code>div {
  background: url('alert.png') 10px 10px no-repeat;
  background-image: url('alert.png');
  background-position: 10px 10px;
  background-repeat: no-repeat;
}
</code></pre>

<p>백그라운드 포지션은 수평 오프셋(첫번째)과 수직 오프셋(마지막)의 두 가지 값이 필요하다. <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 키워드 값을 사용할 수 있다. 이 키워드 값은 퍼센트와 매유 유사하게 작동한다. <code>top left</code> 키워드는 <code>0 0</code> 퍼센트와 동일하고, <code>right bottom</code>은 <code>100% 100%</code> 퍼센트와 동일하다.</p>

<p><code>50%</code> 값을 이용하면 백그라운드 이미지를 중앙에 정렬할 수 있다.엘리먼트의 상단에 백그라운드 이미지를 중양 정렬하려면 <code>50% 0</code> 값을 사용하면 된다. 정확한 조정을 위해 픽셀을 사용하는 것도 인기있는 방법이다.</p>

<p><img src="http://learn.shayhowe.com/assets/courses/html-css-guide/backgrounds-gradients/background-percentages.png" alt="Background Percentages" />
<strong>Fig. 5.01</strong> 백그라운드 이미지의 위치를 조정하기 위해 퍼센트와 키워드를 사용</p>

<h3 id="alert-message-background-example">Alert Message Background Example</h3>

<h6 id="html">HTML</h6>

<pre><code>&lt;p&gt;&lt;strong&gt;Warning!&lt;/strong&gt; You are walking on thin ice.&lt;/p&gt;
</code></pre>

<h6 id="css">CSS</h6>

<pre><code>p {
  background: #fff6cc url('warning.png') 15px 50% no-repeat;
  border-radius: 6px;
  border: 1px solid #ffd100;
  color: #000;
  padding: 10px 10px 10px 38px;
}
</code></pre>

<h4 id="demo">Demo</h4>
<ul>
  <li><a href="http://jsfiddle.net/nolboo/gWUuR/">jsfiddle 링크</a></li>
</ul>

<h2 id="gradient-backgrounds-with-css3">Gradient Backgrounds with CSS3</h2>

<p>그라디언트 백그라운드는 CSS3와 함께 도입되었으며, 모든 브라우저에서 지원되지는 않지만 최신 브라우저에서는 전부 지원된다.</p>

<p>그라디언트 백그라운드는 백그라운드 이미지처럼 다뤄지며, <code>background</code>나 <code>background-image</code> 속성을 이용하여 linear, radial 두 가지 형태로 만들 수 있다.</p>

<blockquote>
  <h4 id="browser-specific-property-values">Browser Specific Property Values</h4>
  <p><br />
브라우저들이 CSS3를 다른 특성들을 서서히 지원하였기 때문에 각 브라우저 제작사는 약간씩 다른 방법으로 새로운 속성을 적용하였다. 새로운 속성이 정확하게 작동하게 하기 위해 vendor prefix를 사용했다. 대부분의 브라우저가 그라디언트 백그라운드를 표준으로 정했지만 아직은 대체 지원을 할 필요가 있다.
<br /><br />
vendor prefixe가 점점 상관없어지고 있지만 오래된 브라우저 때문에 그것들을 사용하는 것이 더 안전한다.<br /><br /></p>

  <ul>
    <li>Mozilla Firefox: <code>-moz-</code> </li>
    <li>Microsoft Internet Explorer: <code>-ms-</code></li>
    <li>Opera: <code>-o-</code></li>
    <li>Webkit (Chrome &amp; Safari): <code>-webkit-</code></li>
  </ul>
</blockquote>

<h3 id="linear-gradient-background">Linear Gradient Background</h3>

<p>수년간 디자이너와 개발자들은 이미지 화일을 잘라내 선형(linear) 그라디언트 백그라운드로 사용해왔다. 잘 작동하기는 했지만 적용하는 시간이 걸렸고, 변경하기가 어려웠다. 다행히 그런 시절은 가버렸고 이젠 CSS안에서 <a href="http://dev.opera.com/articles/view/css3-linear-gradients/">linear gradient</a>를 지정할 수 있다. 색상을 변경하려고 이미지를 다시 자르고 서버에 업로드할 필요가 없으며, CSS 안에서 빠르게 변경할 수 있다.</p>

<pre><code>div {
  background: #70bf32;
  background: url('linear-gradient.png') 0 0 repeat-x;
  background: -webkit-linear-gradient(#a1e048, #6a942f);
  background:    -moz-linear-gradient(#a1e048, #6a942f);
  background:     -ms-linear-gradient(#a1e048, #6a942f);
  background:      -o-linear-gradient(#a1e048, #6a942f);
  background:         linear-gradient(#a1e048, #6a942f);
}
</code></pre>

<p>기본적으로 리니어 백그라운드는 엘리먼트의 위에서부터 아래로 전이된다. 그 방향은 색상 값 앞에 키워드나 각도(degree) 값을 사용하여 변경할 수 있다. 예를 들어 왼쪽에서 오른쪽으로 전이시키려면 <code>to right</code> 키워드 값을 사용하며, 좌상에서 우하로 전이시키려면 <code>to bottom right</code> 키워드 값을 사용한다.</p>

<pre><code>div {
  background: linear-gradient(to bottom right, #a1e048, #6a942f);
}
</code></pre>

<p>대각선 그라디언트를 사용할 때 엘리먼트가 정확하게 사각형이 아니라면 그라디언트는 한 구석에서 다른 쪽으로 직접 진행되지 않을 것이다. 대신에 그라디언트는 엘리먼트의 정중앙을 확인할 것이고 진행되야 할 곳으로부터 수식 코너에 닻을 내릴 것이다. 그리고 그 값 안에서 윤곽된 구성으로 움직일 것이다. 그라이디언트가 향하는 구석을 “magic corners”라 부르지만 절대적인 것은 아니다. 에릭 마이어가 <a href="http://meyerweb.com/eric/thoughts/2012/04/26/lineargradient-keywords/">outlining this syntax</a>란 훌륭한 작업을 했다.</p>

<p>키워드에 더해 degree 값을 사용할 수도 있으며, <code>left top</code>에서 부터 그라디언트가 시작하길 원하면 <code>315deg</code> 값을 사용할 수 있다.</p>

<blockquote>
  <h4 id="old-linear-gradient-keyword-syntax">Old Linear Gradient Keyword Syntax</h4>

  <p>예전엔 리니어 그라디언트의 키워드 문법은 <code>to</code> 키워드를 사용하지 않았다. 키워드(들)를 선언하는 대신 그라디언트의 시작점을 선언하였고 그 반대방향으로 진행되었다. 위의 대각선 리니어 그라디언트 예제에서 예전 문법은 <code>to bottom right</code>가 아닌 <code>top left</code>가 될 것이다.
<br /><br />
새로운 키워드 문법으로 다른 브라우저들 사이에서 지원될 수 있게 되었다. 새로운 문법이 작동되지 않으면 예전 문법이 작동되는지 확인해볼 필요가 있다. 그러나, 곧 업데이트되야 할 것이라는 것을 염두에 두어라.</p>
</blockquote>

<h3 id="radial-gradient-background">Radial Gradient Background</h3>

<p>리니어 그라디언트는 한 방향으로 퍼지는 그라디언트를 만들기엔 완벽하지만 종종 radial 그라디언트에 대한 요구도 있다. 리니어 백그라운드와 유사하지만 위치, 크기, 반경 값 등으로 좀 더 복잡할 수 있다. 여기선 기본적인 것만 다루고 <a href="http://dev.opera.com/articles/view/css3-radial-gradients/">여기서</a> 좀 더 깊게 살펴 볼 수 있다.</p>

<pre><code>div {
  background: #70bf32;
  background: url('radial-gradient.png') 50% 50% no-repeat;
  background: radial-gradient(circle, #a1e048, #6a942f);
}
</code></pre>

<blockquote>
  <h4 id="css3-gradient-background-generator">CSS3 Gradient Background Generator</h4>

  <p>CSS3 그라디언트를 직접 프로그래밍하는 것은 숙달하지 않으면 꽤 힘든 작업이다. 다행히 <a href="http://ie.microsoft.com/testdrive/graphics/cssgradientbackgroundmaker/default.html">CSS3 그라디언트 제너레이터</a>와 같은 것들이 나타났다. 제너레이터들마다 약간 다르게 동작하지만 어떤 것은 프리셋과 예제가 있고, 어떤 것은 확장할 수 있는 옵션 목록을 가지고 있다. 관심이 있다면 필요에 맞는 적절한 제너레이터를 조사해볼 것을 추천한다.</p>
</blockquote>

<h3 id="gradient-background-stops">Gradient Background Stops</h3>

<p>지금까지 하나의 색상에서 다른 색으로 전이되는 그라디언트에 관해 논의했으나, 두 가지 이상의 색상에서 전이되길 원하면 “color stop”을 사용할 수 있다. 두 개의 색상값을 선언하는 대신에 여러 개의 값을 선언할 수 있으며, 차례대로 하나에서 다음 색으로 전이할 것이다. 컬러 스톱에 길이 값을 추가하면 전이의 위치와 길이가 결정된다. 길이값이 선언되지 않으면 그라디언트는 선언된 모든 색상 사이에 평등하게 전이될 것이다.</p>

<pre><code>div {
  background: #6c9730;
  background: url('linear-gradient-stops.png') 0 0 repeat-y;
  background: linear-gradient(left, #8dc63f, #d8ad45, #3b4b94);
}
</code></pre>

<h3 id="navigation-background-example">Navigation Background Example</h3>

<h6 id="html-1">HTML</h6>

<pre><code>&lt;ul&gt;
  &lt;li class="play"&gt;&lt;a href="#"&gt;Play&lt;/a&gt;&lt;/li&gt;
  &lt;li class="back"&gt;&lt;a href="#"&gt;Skip Backward&lt;/a&gt;&lt;/li&gt;
  &lt;li class="stop"&gt;&lt;a href="#"&gt;Pause/Stop&lt;/a&gt;&lt;/li&gt;
  &lt;li class="forward"&gt;&lt;a href="#"&gt;Skip Forward&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<h6 id="css-1">CSS</h6>

<pre><code>ul {
  background: #f4f4f4;
  background: linear-gradient(#fff, #eee);
  border: 1px solid #ccc;
  border-radius: 6px;
  display: inline-block;
  height: 22px;
  list-style: none;
  margin: 0 0 20px 0;
  padding: 0 4px 0 0;
}
li {
  height: 16px;
  float: left;
  padding: 3px;
  text-indent: -9999px;
  width: 16px;
}
.play {
  background: #f4f4f4;
  background: linear-gradient(#fff, #eee);
  border: 1px solid #ccc;
  border-radius: 30px;
  left: -4px;
  padding: 7px;
  position: relative;
  top: -5px;
}
li a {
  background: url('controls.png') 0 0 no-repeat;
  display: block;
  height: 16px;
  width: 16px;
}
.play a:hover {
  background-position: 0 -16px;
}
.back a {
  background-position: -16px 0;
}
.back a:hover {
  background-position: -16px -16px;
}
.stop a {
  background-position: -32px 0;
}
.stop a:hover {
  background-position: -32px -16px;
}
.forward a {
  background-position: -48px 0;
}
.forward a:hover {
  background-position: -48px -16px;
}
</code></pre>

<h4 id="demo-1">Demo</h4>
<ul>
  <li><a href="http://jsfiddle.net/nolboo/yTM63/">jsfiddle 링크</a></li>
</ul>

<h2 id="multiple-background-images-with-css3">Multiple Background Images with CSS3</h2>

<p>예전엔 하나의 엘리먼트에 한 개 이상의 백그라운드를 원한다면 또다른 엘리먼트로 감싸고 그 엘리먼트에 백그라운드를 할당해야 했다. 이것 때문에 백그라운드를 추가하는 단순한 사용으로도 코드가 비대해지곤 했다. CSS3에선 백그라운드 값들을 연달아(chain) 선언하여 하나의 엘리먼트에 여러 개의 백그라운드 이미지를 사용할 수 있다.</p>

<pre><code>div {
  background:
    url('foreground.png') no-repeat 0 0,
    url('middle-ground.png') no-repeat 0 0,
    url('background.png') no-repeat 0 0;
}
</code></pre>

<p><code>background</code> 속성 값을 연달어 선언할 수 있을 뿐아니라, <code>background-repeat</code>, <code>background-position</code>와 같은 다른 백그라운드 관련 속성들도 연달아 선언할 수 있다.</p>

<h3 id="multiple-background-images-example">Multiple Background Images Example</h3>

<h6 id="html-2">HTML</h6>

<pre><code>&lt;div&gt;Dinosaur with Grass and Clouds&lt;/div&gt;
</code></pre>

<h6 id="css-2">CSS</h6>

<pre><code>div {
  background: 
    url('dyno.png') no-repeat 380px 18px, 
    url('grass.png') no-repeat 0 100%, 
    url('sky.jpg') no-repeat 0 0;
  border-radius: 6px;
  height: 200px;
}
</code></pre>

<h4 id="demo-2">Demo</h4>
<p><a href="http://jsfiddle.net/nolboo/vtgqy/">Dinosaur with Grass and Clouds</a></p>

<h2 id="new-css3-background-properties">New CSS3 Background Properties</h2>

<p>그라디언트 백그라운드와 여러 개의 백그라운드 이미지와 함께 <code>background-size</code>, <code>background-clip</code>, <code>background-origin</code>의 세 가지 새로운 CSS 속성이 추가되었다.</p>

<h3 id="css3-background-size">CSS3 Background Size</h3>

<p><code>background-size</code> 속성은 백그라운드 이미지에 특정한 크기를 줄 수 있다. 선언되는 첫번째 값은 이미지의 너비이며, 두번째 값은 높이이며, 어떠한 길이 값이나 키워드도 사용할 수 있다. 만약 하나의 값만 선언된다면 적절한 이미지 비율을 유지해주는 <code>auto</code> 키워드가 사용된다.</p>

<pre><code>div {
  background: url('shay.jpg') 0 0 no-repeat;
  background-size: 85% auto;
  border: 1px dashed #8c9198;
  height: 240px;
  width: 200px;
}
</code></pre>

<blockquote>
  <h4 id="cover--contain-values">Cover &amp; Contain Values</h4>

  <p><code>cover</code> 키워드 값은 (백그라운드가) 엘리먼트 전체를 완전히 덮는 비율적 크기로 재조정되어야 한다. 백그라운드를 얼마나 재조정하느냐는 백그라운드와 엘리먼트의 차원(dimension)에 달려있다. 백그라운드는 비율적으로 차원을 가지지만 이미지 퀄리티(질)는 다소간 왜곡되게 재조정될 수 있다. 항상 작업을 체크하라.<br /><br /></p>

  <p><code>contain</code> 키워드 값은 엘리먼트의 경계 범위 안에 백그라운드 이미지를 비율적 크기로 재조정할 것이다. 이것은 엘리먼트의 일부분이 백그라운드가 없는 것을 의미하지만, 전체 백그라운드 이미지는 보여진다. <code>cover</code> 키워드 값처럼 백그라운드 이미지의 크기 재조정은 이미지의 차원에 비율적일 것이나 이미지는 왜곡될 수 있다.</p>
</blockquote>

<p>역자참조링크 : </p>

<ul>
  <li><a href="http://dolly77.tistory.com/entry/CSS3-backgroundsize-%EC%86%8D%EC%84%B1%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0">background-size 속성 알아보기</a></li>
  <li><a href="http://blog.naver.com/PostView.nhn?blogId=poppymanye&amp;logNo=60161713731">background-size 속성 사용법</a></li>
</ul>

<h3 id="css3-background-clip--background-origin">CSS3 Background Clip &amp; Background Origin</h3>

<p><code>background-clip</code> 속성은 백그라운 이미지가 적용되는 영역을 지정하며, <code>background-origin</code> 속성은 <code>background-position</code>이 어디서부터 시작되는지 지정한다. 이 두 속성이 도입되면서 <code>border-box</code>, <code>padding-box</code>, <code>content-box</code>의 세 값이 포함되었으며, 각각 <code>background-clip</code>과 <code>background-origin</code> 속성값으로 사용될 수 있다.</p>

<pre><code>div {
  background: url('shay.jpg') 0 0 no-repeat;
  background-clip: padding-box;
  background-origin: border-box;
}
</code></pre>

<p><strong>Fig. 5.03</strong> The <code>border-box</code> 값은 엘리먼트의 경계선안까지 확장된다.
<img src="http://learn.shayhowe.com/assets/courses/html-css-guide/backgrounds-gradients/border-box.png" alt="Border Box Value" /></p>

<p><strong>Fig. 5.04</strong> <code>padding-box</code> 값은 엘리먼트의 패딩 안까지 확장되지만, 경계선 안까지만 포함된다.
<img src="http://learn.shayhowe.com/assets/courses/html-css-guide/backgrounds-gradients/padding-box.png" alt="Padding Box Value" /></p>

<p><strong>Fig. 5.05</strong> <code>content-box</code> 값은 엘리먼트의 경계선과 패딩 안까지 포함된다.
<img src="http://learn.shayhowe.com/assets/courses/html-css-guide/backgrounds-gradients/content-box.png" alt="Content Box Value" /></p>

<h2 id="resources--links">Resources &amp; Links</h2>

<ul>
  <li><a href="http://www.slideshare.net/maxdesign/css3-backgrounds">CSS3 Background</a> via Russ Weakley</li>
  <li><a href="http://dev.opera.com/articles/view/css3-linear-gradients/">CSS3 Linear Gradients</a> via Dev.Opera</li>
  <li><a href="http://dev.opera.com/articles/view/css3-radial-gradients/">CSS3 Radial Gradients</a> via Dev.Opera</li>
  <li><a href="http://ie.microsoft.com/testdrive/graphics/cssgradientbackgroundmaker/default.html">CSS Gradient Background Maker</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML & CSS 초보자 가이드 - 4강 : Typography]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/beginners-guide-to-html-and-css-4-slash-10/"/>
    <updated>2013-07-22T21:08:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/beginners-guide-to-html-and-css-4-slash-10</id>
    <content type="html"><![CDATA[<p>원본 : <a href="http://learn.shayhowe.com/html-css/typography">A Beginner’s Guide to HTML &amp; CSS - LESSON 4 : Typography”</a></p>

<p>웹 타이포그래피는 최근 몇년 동안 지속적으로 성장해왔다. 이러한 대중적 성장은 몇 가지 이유가 있지만, 웹 사이트에 자신의 웹 폰트를 (얼마나 쉽게) 적용(emded)할 수 있는가가 가장 큰 이유이다.</p>

<p>역자참조링크 : </p>

<ul>
  <li><a href="http://ko.wikipedia.org/wiki/%ED%83%80%EC%9D%B4%ED%8F%AC%EA%B7%B8%EB%9E%98%ED%94%BC">타이포그래피</a></li>
  <li><a href="http://ko.wikipedia.org/wiki/%EC%BA%98%EB%A6%AC%EA%B7%B8%EB%9E%98%ED%94%BC">캘리그래피</a></li>
  <li><a href="http://ko.wikipedia.org/wiki/%EB%82%99%EC%84%9C">그라피티</a></li>
</ul>

<p>과거엔 웹사이트에 사용할 수 있는 타입페이스(글꼴)의 수가 작고 한정되어 있었다. 이러한 글꼴들은 컴퓨터에 공통적으로 설치되어 화면에 적절하게 표현된다. 최근에는 임베딩 폰트를 사용할 수 있어 디자이너들이 휠씬 많은 글꼴을 선택할 수 있다.
<!-- more -->
폰트 임베딩의 문이 새로운 글꼴들에 활짝 열리면서 디자이너들에게 타이포그래피의 기본적인 원칙을 아는 것이 필요하게 되었다. 이러한 기본 원칙을 HTML과 CSS로 변환하는 것은 온라인 타이포그래피와 <a href="http://dev.opera.com/articles/view/29-text-styling-with-css/">텍스트 스타일링</a>의 핵심에 기여한다.</p>

<blockquote>
  <h4 id="typeface-vs-font">Typeface vs. Font</h4>
  <p><br /></p>

  <p>타입페이스와 폰트는 자주 혼용해서 사용되기 때문에 혼선을 준다. 아래에 각 용어가 무엇을 뜻하는지와 두 용어가 어떻게 사용되어 컨텍스트를 더하는지 적었다.<br /><br /></p>

  <p><strong>typeface</strong> 는 보이는 것이다. 문자가 어떻게 보이고, 느끼고, 읽히는지에 대한 예술적 인상이다.<br /><br /></p>

  <p><strong>font</strong> 는 타입페이스를 포함하는 화일이다. 컴퓨터에서 하나의 폰트를 사용하는 것은 컴퓨터가 그 타입페이스에 접근할 수 있는 것이다.<br /><br /></p>

  <p>타입페이스와 폰트의 차이는 <a href="http://fontfeed.com/archives/font-or-typeface/" title="Font or Typeface?">노래와 MP3</a>의 차이와 같다. 타입페이스는 예술 작품이라는 측면에서 노래와 매우 유사하다. 한 명의 아티스트나 아티스트들에 의해 만들어지고 해석은 열려있다. 반면에 폰트는 예술적 감상이 아닌 예술적 가치를 전달하는 방법이라는 측면에서 MP3와 매우 유사하다.</p>
</blockquote>

<h2 id="formatting-content">Formatting Content</h2>

<h3 id="headings">Headings</h3>

<p><code>h1</code>은 가장 중요한 헤딩이며 나머지 <code>h2</code>~<code>h6</code>는 <code>h1</code>을 지원하고 필요에 따라 여러 번 사용할 수 있다.</p>

<h3 id="paragraphs">Paragraphs</h3>

<p>단락마다 <code>p</code> 태그로 둘러싸인 컨텐츠</p>

<h3 id="bolding-text">Bolding Text</h3>

<p><code>strong</code> 엘리먼트는 텍스트를 굵은체로 만들 뿐아니라 문맥적으로도 중요한 텍스트임을 알린다.</p>

<h3 id="italicizing-text">Italicizing Text</h3>

<p><code>em</code> 엘리먼트는 텍스트를 기울임체로 만들어 주고 문맥적으로 강조된 중요성을 의미한다.</p>

<h2 id="text-color">Text Color</h2>

<p>디자이너나 개발자가 웹사이트를 만들 때 일반적으로 제일 먼저 하는 것이 텍스트 색상과 글꼴을 고르는 것이다. 페이지의 외관이란 측면에서 이 두 가지는 가장 적은 시간에 가장 큰 효과를 줄 수 있다. 브라우저의 디폴트 값을 제거하고 자신만의 텍스트 색상과 글꼴을 사용하여 즉시 페이지의 기조를 정하게 된다.</p>

<p>텍스트 색상을 지정할 때 필요한 유일한 것은 <code>color</code> 속성이다. <code>color</code> 속성은 하나의 값만 허용된다. 그러나, 형식은 여러가지가 사용되며, 키워드, 16진값, RGB, RGBa, HSL, HSLa 등이 있다. 가장 많이 볼 수 있는 것은 최소의 노력으로 가장 큰 조작을 할 수 있는 16진값(<a href="http://www.quackit.com/css/css_color_codes.cfm">hexadecimal</a>)이다.</p>

<p>RGBa값은 투명 색상을 제공하기 때문에 CSS3와 함께 부상하고 있으나, 모든 브라우저에서 지원되지 않기 때문에 16진값 대체(fallback)과 적절하게 사용되어야 한다.</p>

<pre><code>body {
  color: #555;
}
</code></pre>

<blockquote>
  <h4 id="shorthand-hexadecimal-color-values">Shorthand Hexadecimal Color Values</h4>

  <p>16진 색상 값은 숏핸드 값을 사용할 수 있다. 16진 색상은 파운드 기호(#)와 뒤따르는 6개의 문자로 선언된다. 이 문자들은 첫 두 글자, 중간 두 글자, 마지막 두 글자로 두개의 문자씩 짝을 이루는 패턴을 가지고 사용되면서 각각 하나의 특정한 색상을 지정한다. 이러한 패턴은 6개에서 3개로 축약될 수 있다. 예를 들면 <code>#555555</code>는 <code>#555</code>로 축약될 수 있으며, <code>#ff6600</code>은 <code>#f60</code>으로, <code>#ffff00</code>은 <code>#ff0</code> 등으로 축약될 수 있다.</p>
</blockquote>

<h2 id="font-properties">Font Properties</h2>

<p>CSS는 텍스트의 룩앤픽을 편집할 수 있는 수많은 속성을 제공하며, 크게 <code>font</code> 기반 속성과 <code>text</code> 기반 속성의 두 가지 범주로 나뉜다. 이 범주의 대부분의 속성은 <code>font-*</code> 나 <code>text-*</code>로 접두될 것이다.</p>

<h3 id="font-family">Font Family</h3>

<p><code>font-family</code> 속성은 텍스트가 디스플레이될 때 사용되는 폰트와 대체 폰트를 선언한다. <code>font-family</code> 값은 <code>,</code>로 구분되는 여러 개의 폰트 이름을 포함한다. 가장 왼쪽에 선언된 첫번째 폰트는 가장 우선적인 폰트이다. 첫번째 폰트를 사용할 수 없다면 왼쪽에서 오른쪽 순으로 선언된 대체 폰트가 사용된다. 두 개이상의 단어로 된 폰트 이름은 인용부호로 감싸져야 한다. 가장 마지막 폰트는 특정 형식의 시스템 디폴트 폰트를 지칭하는 키워드 값이어야 한다.</p>

<pre><code>p {
  font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif;
}
</code></pre>

<h3 id="font-size">Font Size</h3>

<p><code>font-size</code> 속성은 픽셀, em, 퍼센트, 포인트, <code>font-size</code>  키워드 등의 <a href="http://css-tricks.com/css-font-size/">길이값</a>을 사용하여 텍스트의 크기를 지정할 수 있다. 픽셀 값이 점점 더 자주 사용되고 있다. 전에는 사용자가 브라우저 안의 페이지를 확대할 때 상대적으로 확장되는 em과 퍼센트 값이 꽤 인기가 있었다. 최근엔 대부분의 브라우저가 픽셀을 확장할 수 있기 때문에 em과 퍼센트 값을 사용할 필요가 없어졌다.</p>

<pre><code>p {
  font-size: 13px;
}
</code></pre>

<h3 id="font-style">Font Style</h3>

<p>텍스트를 기울이거나 그 반대로 하기위해 <code>font-style</code> 속성이 사용된다. <code>font-style</code> 속성은 <code>normal</code>, <code>italic</code>, <code>oblique</code>, <code>inherit</code> 4가지 키워드 값을 받아들이며, <code>normal</code>, <code>italic</code>이 가장 대중적으로 사용된다. <code>italic</code>은 텍스트를 이탤릭으로 지정할 때 <code>normal</code>은 보통으로 되돌릴 때 사용된다.</p>

<pre><code>p {
  font-style: italic;
}
</code></pre>

<h3 id="font-variant">Font Variant</h3>

<p>자주는 아니지만 때때로 텍스트를 작은 대문자로 지정할 필요가 있을 때 <code>font-variant</code> 속성을 사용한다. <code>font-variant</code> 속성은 <code>normal</code>, <code>small-caps</code>, <code>inherit</code>의 3가지 값을 허용한다. 타입페이스가 작은 대문자를 지원하지 않으면 아무런 변화가 없을 것이다. 이 속성을 이용하기 전에 타입페이스 지원여부를 체크해야한다.</p>

<pre><code>p {
  font-variant: small-caps;
}
</code></pre>

<h3 id="font-weight">Font Weight</h3>

<p>텍스트를 굵게하거나 굵은 정도를 지정할 때 <code>font-weight</code> 속성을 사용한다. 일반적으로 말하면 <code>font-weight</code> 속성은 <code>normal</code>, <code>bold</code>, <code>bolder</code>, <code>lighter</code>, <code>inherit</code>의 키워드 속성 값과 사용된다. 이 중 <code>bold</code>와 <code>normal</code>이 굵게 바꾸거나 보통으로 되돌릴 때 우선적으로 추천된다.</p>

<p>위의 키워드에 추가하여 <code>100</code>, <code>200</code>, <code>300</code>, <code>400</code>, <code>500</code>, <code>600</code>, <code>700</code>, <code>800</code>, <code>900</code>의 숫자 값이 있다. 굵은 정도를 나타내는 weight의 순서는 가장 가는 <code>100</code>에서 가장 두꺼운 <code>900</code>으로 확장된다. 이 값들은 normal (<code>400</code>)과 bold(<code>700</code>) 이상의 여러 weight를 값는 타입페이스와 특별히 관련되므로, 숫자 값을 사용하기 전에 타입페이스가 지원하는 것을 정확히 체크하라. 그렇지 않으면 작동하지 않을 수 있다.</p>

<pre><code>p {
  font-weight: bold;
}
</code></pre>

<h3 id="line-height">Line Height</h3>

<p>줄간격(leading)으로 알려진 두 텍스트 줄 사이의 거리는 <code>line-height</code> 속성으로 선언한다. 갸장 읽기 쉬운 <code>line-height</code>는 <code>font-size</code>의 1.5배이며 <code>line-height</code>를 150%로 설정하면 된다. 그러나, 그리드와 작업할 때는 <code>line-height</code>를 픽셀로 사용하는 것을 선호할 수 있다.</p>

<p><code>line-height</code>를 엘리먼트의 <code>height</code>와 같게 설정하면 텍스트가 수직적 중앙에 위치한다. 버튼, 알림 메시지, 한 줄 텍스트 블럭 등에서 흔히 볼 수 있다.</p>

<pre><code>p {
  line-height: 20px;
}
</code></pre>

<h3 id="shorthand-font-properties">Shorthand Font Properties</h3>

<p>위의 모든 폰트 기반 속성은 하나의 <code>font</code> 속성과 <a href="http://www.impressivewebs.com/css-font-shorthand-property-cheat-sheet/">숏핸드 값</a>으로 합칠 수 있다. 속성의 순서는 왼쪽부터 <code>font-style</code>, <code>font-variant</code>, <code>font-weight</code>, <code>font-size</code>, <code>line-height</code>, <code>font-family</code> 순이며, 컴마없이 나열한다.(폰트 이름들은 예외이며 컴마로 나열된다.) <code>font-size</code>와 <code>line-height</code> 속성값은 값 사이는 /로 나눈다.</p>

<p><code>font-size</code>와 <code>font-family</code> 속성값을 제외한 나머지 속성값은 선택적이기 때문에 <code>font-size</code>와 <code>font-family</code> 값만을 가진 <code>font</code> 속성을 종종 볼 수 있다.</p>

<pre><code>p {
  font: italic small-caps bold 13px/20px 'Helvetica Neue',
  Arial, Helvetica, sans-serif;
}
</code></pre>

<h3 id="font-properties-example">Font Properties Example</h3>

<h6 id="html">HTML</h6>

<pre><code>&lt;h2&gt;&lt;a href="#" title="Sample Blog Post Title"&gt;Sample Blog Post Title&lt;/a&gt;&lt;/h2&gt;

&lt;p class="byline"&gt;Posted by Shay Howe on February 5th, 2012&lt;/p&gt;

&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla fringilla vehicula nisi vitae rutrum. Donec laoreet, arcu in elementum, dui mi auctor tortor, et lorem massa orci… &lt;a href="#" title="Sample Blog Post Title"&gt;Continue reading →&lt;/a&gt;&lt;/p&gt;
</code></pre>

<h6 id="css">CSS</h6>

<pre><code>h2, p {
  color: #555;
  font: 13px/20px Arial, 'Helvetica Neue', 'Lucida Grande', sans-serif;
}
a {
  color: #8ec63f;
}
a:hover {
  color: #f7941d;
}
h2 {
  font-size: 22px;
  font-weight: bold;
  margin-bottom: 6px;
}
.byline {
  color: #8c8c8c;
  font-family: Georgia, Times, 'Times New Roman', serif;
  font-style: italic;
}
</code></pre>

<h2 id="text-properties">Text Properties</h2>

<p>이제 반 왔다.</p>

<h3 id="text-align">Text Align</h3>

<p>텍스트 정렬은 페이지의 리듬과 흐름을 만드는 중요한 부분이며, <code>text-align</code> 속성으로 지정한다. <code>left</code>, <code>right</code>, <code>center</code>, <code>justify</code>, <code>inherit</code>의 5가지 값을 갖는다. <code>text-align</code> 속성은 <code>float</code> 속성과 혼동하지 말아야 한다. <code>text-align</code>의 <code>left</code>와 <code>right</code> 값은 엘리먼트 안의 텍스트를 정렬하는 반면 <code>float</code>의 <code>left</code>와 <code>right</code> 값은 엘리먼트 전체를 이동시킨다.</p>

<pre><code>p {
  text-align: center;
}
</code></pre>

<h3 id="text-decoration">Text Decoration</h3>

<p><code>text-decoration</code> 속성은 텍스트를 치장해주며, <code>none</code>, <code>underline</code>, <code>overline</code>, <code>line-through</code>, <code>blink</code>, <code>inherit</code> 키워드 값을 갖는다. 가장 인기있는 사용법은 링크에 밑줄을 치는 것이다. <code>blink</code> 값은 극도로 어지럽히므로 추천하지 않는다. 시맨틱적으로 <code>line-though</code> 값은 문서에서 제거된 텍스트를 나타내는 <code>del</code> 엘리먼트와 정확하지않거나 상관없는 텍스트를 나타내는 <code>s</code> 엘리먼트 대신 사용될 수 있다.</p>

<pre><code>p {
  text-decoration: underline;
}
</code></pre>

<h3 id="text-indent">Text Indent</h3>

<p><code>text-indent</code> 속성은 텍스트를 안과 밖으로 들여쓸 수 있게 한다.</p>

<pre><code>p {
  text-indent: 20px;
}
</code></pre>

<h3 id="text-shadow">Text Shadow</h3>

<p><code>text-shadow</code> 속성은 텍스트에 하나 또는 여러 개의 그림자를 추가할 수 있게 한다. 4개의 값들이 왼쪽에서 오른쪽 순으로 나열되어야 한다. 처음 3개 값은 길이이며 마지막 값은 색상이다. 3개의 길이 값 중 첫번째는 그림자의 horizontal offset, 두번째는 vertical offset, 세번째는 blur radius를 결정한다. 네번째 즉, 마지막 값은 그림자의 색상이며, <code>color</code> 속성에서 사용되는 모든 컬러 값을 사용할 수 있다.</p>

<p>여러 개의 텍스트 그림자들은 컴마로 구분된다.</p>

<pre><code>p {
  text-shadow: 0 1px 0 rgba(0, 0, 0, 0.3);
}
</code></pre>

<h3 id="text-transform">Text Transform</h3>

<p><code>text-transform</code>은 <code>font-variant</code> 속성과 유사하다. <code>font-variant</code>는 타입페이스의 작은 대문자를 가져오지만 <code>text-transform</code> 속성은 인라인으로 텍스트를 변경한다. <code>none</code>, <code>capitalize</code>, <code>uppercase</code>, <code>lowercase</code>, <code>inherit</code> 값을 갖는다.</p>

<p><code>capitalize</code> 값은 각 단어의 첫번째 글자를 대문자로 만들고, <code>uppercase</code> 값은 모든 글자를 대문자로 만들며, <code>lowercase</code>는 모든 문자를 소문자로 만든다. <code>none</code>은 상속되는 값을 없애고 디폴트 값으로 되돌린다.</p>

<pre><code>p {
  text-transform: uppercase;
}
</code></pre>

<h3 id="letter-spacing">Letter Spacing</h3>

<p><code>letter-spacing</code> 속성으로 페이지의 글자 간격을 조정할 수 있다. <code>none</code> 속성은 자간을 보통 거리로 되돌린다.</p>

<pre><code>p {
  letter-spacing: -.5em;
}
</code></pre>

<p>역자참조링크 : </p>

<ul>
  <li><a href="http://j.mp/17oGhiK">1em은 현재 사용되는 글꼴의 16포인트 크기의 대문자 “M”의 넓이</a></li>
</ul>

<h3 id="word-spacing">Word Spacing</h3>

<p>단어들의 간격을 조정할 수 있다.</p>

<pre><code>p {
  word-spacing: .25em;
}
</code></pre>

<h3 id="text-properties-example">Text Properties Example</h3>

<h6 id="html-1">HTML</h6>

<pre><code>&lt;h2&gt;&lt;a href="#" title="Sample Blog Post Title"&gt;Sample Blog Post Title&lt;/a&gt;&lt;/h2&gt;

&lt;p class="byline"&gt;Posted by Shay Howe on February 5th, 2012&lt;/p&gt;

&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla fringilla vehicula nisi vitae rutrum. Donec laoreet, arcu in elementum, dui mi auctor tortor, et lorem massa orci… &lt;a href="#" title="Sample Blog Post Title"&gt;Continue reading →&lt;/a&gt;&lt;/p&gt;
</code></pre>

<h6 id="css-1">CSS</h6>

<pre><code>h2, p {
  color: #555;
  font: 13px/20px Arial, 'Helvetica Neue', 'Lucida Grande', sans-serif;
}
a {
  color: #8ec63f;
}
a:hover {
  color: #f7941d;
}
h2 {
  font-size: 22px;
  font-weight: bold;
  letter-spacing: -.9px;
  margin-bottom: 6px;
}
h2 a {
  text-shadow: 1px 1px 0 #75a334;
}
h2 a:hover {
  text-shadow: 1px 1px 0 #d48019;
}
p {
  text-indent: 15px;
}
.byline {
  color: #8c8c8c;
  font-family: Georgia, Times, 'Times New Roman', serif;
  font-style: italic;
  text-indent: 0;
}
p a {
  font-size: 11px;
  font-weight: bold;
  text-decoration: underline;
  text-transform: uppercase;
}
</code></pre>

<h2 id="web-safe-fonts">Web Safe Fonts</h2>

<p>모든 컴퓨터, 태블릿, 폰 혹은 브라우징이 가능한 기기에는 디폴트로 미리 설치된 몇 개의 특정 폰트들이 있다. 모든 기기에 설치되면 폰트들은 온라인에서 무료로 사용될 수 있으며 브라우저 기기와 상관없이 적절하게 보여질 것이다. 이러한 폰트들이 “web safe fonts.”이다. 그 목록은 아래와 같다.</p>

<ul>
  <li>Arial</li>
  <li>Courier New, Courier</li>
  <li>Garamond</li>
  <li>Georgia</li>
  <li>Lucida Sans, Lucida Grande, Lucida</li>
  <li>Palatino Linotype</li>
  <li>Tahoma</li>
  <li>Times New Roman ,Times</li>
  <li>Trebuchet</li>
  <li>Verdana</li>
</ul>

<h2 id="embedding-web-fonts">Embedding Web Fonts</h2>

<p>최근에 web safe fonts에 대한 대안이 뜨고있다. 이제는 폰트를 서버에 업로드하여 CSS <code>@font-face</code> 속성을 통해 웹사이트에 포함시킬 수 있다. 이것은 온라인 타이포그래피에 경이로운 일이며, 이제 활자가 온라인으로 올라왔다.</p>

<pre><code>@font-face {
  font-family: 'Bryant Normal';
  src: url('bryant-normal.eot');
  src: url('bryant-normal.eot') format('embedded-opentype'),
       url('bryant-normal.woff') format('woff'),
       url('bryant-normal.ttf') format('truetype'),
       url('bryant-normal.svg') format('svg');
}
body {
  font-family: 'Bryant Normal', 'Helvetica Neue', Arial, Helvetica, sans-serif;
}
</code></pre>

<p>그러나 몇 가지 작은 함정이 있다. 웹사이트에 모든 타입페이스를 사용할 수 있다는 것이 합법적인 권리를 승인받았다는 것을 의미하지는 않는다. 타입페이스는 예술 작품이므로 그것을 라이센스 없이 서버에 올릴 수 없다.</p>

<p>다행히 새로운 타입페이스의 가치가 인식되고 회사들이 웹사이트에 새로운 폰트들을 라이센스하여 포함할 수 있도록 하고 있다. <a href="https://typekit.com/">Typekit</a>과 <a href="http://fontdeck.com/">Fontdeck</a>과 같은 회사들은 폰트 라이센싱을 서브스크립션 모델로 팔고있고, <a href="http://www.google.com/webfonts">Google Fonts</a>는 무료로 폰트를 라이센싱하고 있다.</p>

<p>또 다른 함정은 브라우저 지원이다. <code>@font-face</code> 속성은 오래된 브라우저에서 지원되지 않을 수 있다. 다행히 폰트를 사용할 때 <code>font-family</code> 속성에서 대체 폰트를 지정할 수 있다.</p>

<h2 id="citations-amp-quotes">Citations &amp; Quotes</h2>

<p><code>cite</code>, <code>q</code>, <code>blockquote</code> 엘리먼트를 사용한다.</p>

<p><code>cite</code> 엘리먼트는 a title of work를 참조할 때 사용되고, <code>q</code> 엘리먼트는 짧은 인라인 인용에, <code>blockquote</code>는 더 길고 외부 인용에 사용된다.</p>

<h3 id="citing-a-title-of-work">Citing a Title of Work</h3>

<p><code>cite</code> 엘리먼트는 <code>cite</code> 속성과 혼동하지 말아야 한다. <strong>element</strong>는 시맨틱 문맥을 제공하고 <strong>attribute</strong>는 참조 소스로서 URI 값을 가진다. <code>cite</code> 엘리먼트는 특별히 a title of work을 위해 예약되어 있으며 소스와 관련된 다른 컨텍스트를 포함하지 말아야 한다. A title of work는 하나의 책, 영화, 노래 등이다. 관련된 원본 소스의 하이퍼링크를 포함할 수 있다.</p>

<pre><code>&lt;p&gt;&lt;cite&gt;&lt;a href="http://www.amazon.com/Steve-Jobs-Walter-Isaacson/dp/1451648537" title="Steve Jobs"&gt;Steve Jobs&lt;/a&gt;&lt;/cite&gt; by Walter Isaacson is truly inspirational.&lt;/p&gt;
</code></pre>

<blockquote>
  <h4 id="citing-a-title-of-work-demo">Citing a Title of Work Demo</h4>

  <p><a href="http://www.amazon.com/Steve-Jobs-Walter-Isaacson/dp/1451648537">Steve Jobs</a> by Walter Isaacson is truly inspirational.</p>
</blockquote>

<h3 id="dialog-amp-prose-quotation">Dialog &amp; Prose Quotation</h3>

<p><code>q</code> 엘리먼트는 대화나 문장을 시맨틱하게 지정할 때 사용되며 다른 인용 목적으로 사용되지 말아야 한다.</p>

<pre><code>&lt;p&gt;Steve Jobs once said, &lt;q&gt;“One home run is much better than two doubles.”&lt;/q&gt;&lt;/p&gt;
</code></pre>

<h3 id="dialog-amp-prose-citation">Dialog &amp; Prose Citation</h3>

<p><code>q</code> 엘리먼트에서 선택적으로 사용하는 속성은 <code>cite</code> 속성이다. <code>cite</code> 속성은 URI를 인용부호로 감싸는 형태이다. 이 속성은 엘리먼트의 외양을 변화시키지 않으며, 단순히 스크린 리더와 같은 기기에 가치를 제공한다. 속성은 브라우저 내에서 볼 수 없기 때문에 가능하다면 소스를 포함한 하이퍼링크를 제공하는 것이 추천된다.</p>

<pre><code>&lt;p&gt;&lt;a href="http://www.businessweek.com/magazine/content/06_06/b3970001.htm" title="Steve Jobs' Magic Kingdom"&gt;Steve Jobs&lt;/a&gt; once said, &lt;q cite="http://www.businessweek.com/magazine/content/06_06/b3970001.htm"&gt;“One home run is much better than two doubles.”&lt;/q&gt;&lt;/p&gt;
</code></pre>

<h3 id="external-quotation">External Quotation</h3>

<p>커다란 텍스트 블럭을 인용하기 위해, 외부 소스와 여러 줄을 차지하는 <code>blockquote</code> 엘리먼트가 사용된다. <code>blockquote</code>는 헤딩과 단락 등의 다른 블럭 레벨 엘리먼트를 포함할 수 있는 블럭 레벨 엘리먼트이다.</p>

<pre><code>&lt;blockquote&gt;
  &lt;p&gt;“In most people’s vocabularies, design is a veneer. It’s interior decorating. It’s the fabric of the curtains, of the sofa. But to me, nothing could be further from the meaning of design. Design is the fundamental soul of a human-made creation that ends up expressing itself in successive outer layers of the product.”&lt;/p&gt;
  &lt;p&gt;— Steve Jobs in Fortune Magazine&lt;/p&gt;
&lt;/blockquote&gt;
</code></pre>

<h3 id="external-citation">External Citation</h3>

<p><code>blockquote</code> 엘리먼트 안에서 사용된 긴 인용들은 항상 인용처를 포함해야 한다. 이 인용처는 저자와 소스처럼 지극히 단순할 수 있으나 여러 개의 인용처와 추가 적인 레퍼런스를 위한 링크를 포함하는 훨씬 많은 정보일 수 있다.</p>

<p><code>cite</code> 속성은 <code>blockquote</code> 엘리먼트 안에 포함될 수 있으며, <code>cite</code> 엘리먼트는 인용문 다음에 위치하여 관련된 title of work을 지정하는 것을 도울 수 있다.</p>

<p><code>cite</code> 속성과 <code>cite</code> 엘리먼트는 순수하게 시맨틱하고 유저에게 어떠한 시각적인 참조를 추가하지 않기에 하이퍼링크가 선호된다. These hyperlinks should highlight both the origin of the quote (author, artist, etcetera) and the title of work in which it first appeared.</p>

<pre><code>&lt;blockquote cite="http://money.cnn.com/magazines/fortune/
fortune_archive/2000/01/24/272277/index.htm"&gt;
  &lt;p&gt;“In most people’s vocabularies, design is a veneer. It’s interior decorating. It’s the fabric of the curtains, of the sofa. But to me, nothing could be further from the meaning of design. Design is the fundamental soul of a human-made creation that ends up expressing itself in successive outer layers of the product.”&lt;/p&gt;
  &lt;p&gt;— &lt;a href="http://en.wikipedia.org/wiki/Steve_Jobs" title="Steve Jobs"&gt;Steve Jobs&lt;/a&gt; in &lt;cite&gt;&lt;a href="http://money.cnn.com/magazines/fortune/fortune_archive/2000/01/24/272277/index.htm" title="Apple's One-Dollar-a-Year Man"&gt;Fortune Magazine&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</code></pre>

<h4 id="automating-quotation-marks-with-css">Automating Quotation Marks with CSS</h4>

<p>HTML에 인용부호를 추가하기 보다는 CSS에서 자동으로 추가하는 방법이 있다. 예전에는 브라우저의 언어 지원 때문에 CSS에서 적절하게 표현되지 못했지만 최근 브라우저의 언어 지원이 더 좋아졌다.</p>

<p>아래는 <code>q</code> 엘리먼트에 <code>before</code>, <code>after</code> 가상엘리먼트와 속성을 이용하여 인용부호를 추가하는 방법이다. 좀 더 자세한 것은 <a href="http://css-tricks.com/pseudo-element-roundup/">가상 엘리먼트</a> 와 <a href="http://html5doctor.com/blockquote-q-cite/">인용부호 사용하는 방법</a>.</p>

<pre><code>q {
  quotes: '“' '”' '‘' '’';
}
q:before {
  content: '“';
  content: open-quote;
}
q:after {
  content: '”';
  content: close-quote;
}
</code></pre>

<h2 id="resources-amp-links">Resources &amp; Links</h2>

<ul>
  <li><a href="http://dev.opera.com/articles/view/29-text-styling-with-css/">Text styling with CSS</a> via Dev.Opera</li>
  <li><a href="http://html5doctor.com/blockquote-q-cite/">Quoting and citing with blockquote, q, cite, and the cite attribute</a> via HTML5 Doctor</li>
  <li><a href="http://www.impressivewebs.com/css-font-shorthand-property-cheat-sheet/">CSS Font Shorthand Property Cheat Sheet</a> via Impressive Webs</li>
  <li><a href="http://www.amazon.com/Elements-Typographic-Style-Robert-Bringhurst/dp/0881791326">The Elements of Typographic Style</a> by Robert Bringhurst</li>
</ul>

<h3 id="section">역자참조링크</h3>

<ul>
  <li><a href="http://www.creativebloq.com/typography/what-is-typography-123652">What is typography? Learn the basic rules and terms of type!</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML & CSS 초보자 가이드 - 3강 : Box Model & Positioning]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/22/beginners-guide-to-html-and-css-3-slash-10/"/>
    <updated>2013-07-22T21:08:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/22/beginners-guide-to-html-and-css-3-slash-10</id>
    <content type="html"><![CDATA[<p>원본 : <a href="http://learn.shayhowe.com/html-css/box-model">A Beginner’s Guide to HTML &amp; CSS - LESSON 3 : Box Model &amp; Positioning</a></p>

<p>HTML과 CSS를 완전히 이해하는데 필요한 하나의 원칙은 박스모델이다. </p>

<p><strong>“페이지의 모든 엘리먼트는 사각형 박스이다.”</strong></p>

<p>박스 모델을 이해하는 것은 어렵고 까다로울 수 있으나 일반적인 웹사이트를 만들기 위해서는 필요하다. 더불어 레이아웃을 만들기 위해, 페이지에 엘리먼트를 배치하는 방법을 아는 것도 똑같이 중요하다.
<!-- more --></p>

<h2 id="box-sizing">Box Sizing</h2>

<p>이전의 강의를 통해 페이지에 모든 엘리먼트는, 블럭이나 인라인 레벨이건, 모두 사각형 박스라는 것을 알았을 것이다. 박스는 다른 크기를 가질 수 있으며, 마진, 패딩, 경계선 등이 크기를 변경할 수도 있다. 이것들을 통틀어 <em>the box model</em> 이라 한다. 박스 모델의 한 예를 보자.</p>

<p>Fig. 3.01
<img src="http://learn.shayhowe.com/assets/courses/html-css-guide/box-model/square-elements.jpg" alt="" /></p>

<h2 id="the-box-model">The Box Model</h2>

<p>알다시피 모든 엘리먼트는 높이(height)와 너비(width)를 가지는 사각형 박스이며, 다른 마진(margin), 패딩(padding), 보더(boarder)로 구성되어 있다. 이 모든 값들이 합쳐져 <a href="http://css-tricks.com/the-css-box-model/">박스모델</a>을 만든다.</p>

<p>박스는 엘리먼트의 <code>height</code>와 <code>width</code>의 속성값을 주는 것으로 시작된다. <code>padding</code>과 <code>border</code>가 차례로 <code>height</code> 와 <code>width</code>를 둘러싼다. 그런 다음 <code>margin</code>이 <code>border</code>를 둘러싼다. 그러나, 마진은 박스의 실제 크기에는 포함되지 않으며, 박스모델을 정의하는 것에는 도움을 준다.</p>

<pre><code>div {
  background: #fff;
  border: 6px solid #ccc;
  height: 100px;
  margin: 20px;
  padding: 20px;
  width: 400px;
}
</code></pre>

<p>박스모델에서 엘리먼트의 전체 너비는 다음 공식을 사용한다:</p>

<p><code>margin-right</code> + <code>border-right</code> + <code>padding-right</code> + <code>width</code> + <code>padding-left</code> + <code>border-left</code> + <code>margin-left</code></p>

<p>엘리먼트의 전체 높이 공식은</p>

<p><code>margin-top</code> + <code>border-top</code> + <code>padding-top</code> + <code>height</code> + <code>padding-bottom</code> + <code>border-bottom</code> + <code>margin-bottom</code></p>

<p>Fig. 3.02 박스모델
<img src="http://learn.shayhowe.com/assets/courses/html-css-guide/box-model/box-model.png" alt="" /></p>

<p>공식을 사용하여 위 그림의 전체 높이와 너비를 계산하면</p>

<p><strong>Width</strong>: <code>492px</code> = <code>20px</code> + <code>6px</code> + <code>20px</code> + <code>400px</code> + <code>20px</code> + <code>6px</code> + <code>20px</code><br />
<strong>Height</strong>: <code>192px</code> = <code>20px</code> + <code>6px</code> + <code>20px</code> + <code>100px</code> + <code>20px</code> + <code>6px</code> + <code>20px</code></p>

<h2 id="height--width">Height &amp; Width</h2>

<p>모든 엘리먼트는 상속된 <code>height</code>와 <code>width</code>를 갖는다. 어떤 엘리먼트가 페이지의 레이아웃과 디자인에 핵심요소(key)가 된다면 특정한 <code>height</code>와 <code>width</code>가 필요할 것이고 이때 블럭 레벨 엘리먼트의 디폴트 값은 (새로 지정된 값으로) 덮어씌워질 것이다.(overrided)</p>

<p>역자참조링크 : <a href="http://www.clearboth.org/28_inheritance_and_cascade/">상속과 캐스케이딩</a></p>

<h3 id="css-height-property">CSS Height Property</h3>

<p>엘리먼트의 <code>height</code>의 디폴트 값은 컨텐츠에 의해 결정된다. 컨텐츠를 수용하기 위해 필요한 만큼 수직으로 늘어나거나 줄어들 것이다. 블럭 엘리먼트의 높이를 지정하기 위해는 <code>height</code> 속성이 사용된다.</p>

<pre><code>div {
  height: 100px;
}
</code></pre>

<h3 id="css-width-property">CSS Width Property</h3>

<p>엘리먼트의 <code>width</code>의 디폴트값은 보여지는 방식에 달려있다.
블럭 레벨 엘리먼트는 width = 100% 가 디폴트이며, 가능한 모든 너비를 차지한다. inline 엘리먼트는 컨텐츠가 차지하는 만큼 수평적으로 늘어나고 줄어든다. 인라인 레벨 엘리먼트는 정해진 값을 가질 수 없으므로,  <code>height</code> 속성처럼 <code>width</code> 속성은 블럭 레벨 엘리먼트와만 관계가 있다.</p>

<pre><code>div {
  width: 400px;
}
</code></pre>

<h2 id="margin--padding">Margin &amp; Padding</h2>

<p><code>margin</code> 과 <code>padding</code>은 브라우저마다 엘리먼트마다 가독성을 이유로 다른 디폴트 값을 가진다. 이러한 디폴트값을 모두 0로 맞추기 위해 제1강에서 <a href="http://learn.shayhowe.com/html-css/terminology-syntax-intro#reset">CSS reset</a>을 사용하는 것을 논의했다. </p>

<h3 id="css-margin-property">CSS Margin Property</h3>

<p><code>margin</code> 속성으로 엘리먼트를 둘러싼 여백의 크기를 정할 수 있다. 마진은 경계선(border)의 바깥에 위치하며 완전히 투명하다. 마진으로 페이지의 특정 위치에 엘리먼트가 배치되는 것을 돕거나 다른 엘리먼트가 충분한 거리를 두도록 여백만을 줄 수도 있다.</p>

<pre><code>div {
  margin: 20px;
}
</code></pre>

<h3 id="css-padding-property">CSS Padding Property</h3>

<p><code>padding</code> 속성은 <code>margin</code> 속성과 매우 유사하나 엘리먼트의 경계선(<code>border</code>)안에 위치한다. 패딩은 엘리먼트의 백그라운드를 상속한다. <code>margin</code> 속성은 엘리먼트를 배치하기 위한 것이지만 패딩은 엘리먼트 안의 여백을 제공한다.</p>

<pre><code>div {
  padding: 20px;
}
</code></pre>

<p>Fig. 3.03
<img src="http://learn.shayhowe.com/assets/courses/html-css-guide/box-model/margin-padding.png" alt="" /></p>

<h3 id="margin--padding-declarations">Margin &amp; Padding Declarations(선언)</h3>

<p><code>margin</code> 과 <code>padding</code> 값은 롱핸드와 숏핸드 형식으로 줄 수 있다. </p>

<p>엘리먼트의 네 변을 하나의 값으로 설정하거나 상하, 좌우, 상우하좌로 한번에 설정할 수 있다.(숏핸드)</p>

<pre><code>margin: 20px; 상하좌우 모두 20px
margin: 10px 20px; 상하 10px, 좌우 20px
margin: 10px 20px 0 15px; 상부터 시계 방향으로 상우하좌 순
</code></pre>

<p>한 개의 속성을 사용해서 한 번에 한 변의 값을 설정할 수 있다. 각 속성은 <code>margin</code> 혹은 <code>padding</code>으로 시작하며 -와 적용할 <code>top</code>, <code>right</code>, <code>bottom</code>, or <code>left</code> 으로 적용할 변을 뒤따라 지정한다. 예를 들어 <code>padding-left</code>는 엘리먼트의 왼쪽 패딩에 값을 적용한다.(롱핸드)</p>

<pre><code>div {
  margin-top: 10px;
  padding-left: 6px;
}
</code></pre>

<h2 id="borders">Borders(경계선)</h2>

<p>경계선은 <code>padding</code>과 <code>margin</code>사이에 위치하며, 엘리먼트 주위의 아웃라인을 제공한다. 모든 경계선은 너비, 스타일, 색상의 세가지 값이 필요하다. 숏핸드 값은 너비, 스타일, 색상 순으로 주어진다. 롱핸드의 경우 <code>border-width</code>, <code>border-style</code>, <code>border-color</code> 값으로 나뉘어진다.</p>

<p>대부분 단순한 사이즈, 실선, 한가지 색의 경계를 볼 수 있을 것이다. 그러나 <a href="http://www.quackit.com/html/codes/html_borders.cfm">수많은</a> 사이즈와 모양과 색상이 가능하다.</p>

<pre><code>div {
  border: 6px solid #ccc;
}
</code></pre>

<blockquote>
  <h4 id="length-value">Length Value</h4>

  <p>마진, 패딩, 경계선과 쓸 수 있는 <a href="https://developer.mozilla.org/en/CSS/length">길이 값</a>은 상대적인, 절대적인 값으로 여러 가지가 있다.
<br />
<br />
<strong>상대 값</strong>은 값이 적용되는 엘리먼트와 상관관계가 있다. <code>em</code>과 퍼센티지 등이 있다.
<br />
<br />
<strong>절대 값</strong>은 엘리먼트와 상관없이 측정 단위로 고정된다. 픽셀, 포인트, 인치, 센티미터 등이 있다.</p>
</blockquote>

<h2 id="floating-elements">Floating Elements</h2>

<p>박스모델로 엘리먼트의 모양새를 다듬는 것은 페이지 레이아웃을 코딩하는 전체에서 반을 차지한다. 나머지 반은 페이지의 다른 엘리먼트들을 적절하게 정렬하는 방법을 아는 것이다. 다른 엘리먼트 옆에 엘리먼트를 배치하는 방법 중 하나는 <code>float</code> 속성을 이용하는 것이다. <code>float</code> 속성은 엘리먼트들을 왼쪽과 오른쪽으로 연속으로 배치하게 한다.</p>

<p><strong>역자 링크</strong> : 역자는 <code>float</code> 개념이 처음에 많이 헷갈렸다. 그래서 도움을 얻을만한 글들을 몇 개 링크한다.^^</p>

<ul>
  <li><a href="http://celestarry.egloos.com/3595449">float 속성의 이해와 웹 페이지 레이아웃 잡기</a></li>
  <li><a href="http://tranbot.net/ALA/css-floats-101/">CSS 플로트 기초</a></li>
  <li><a href="http://techbug.tistory.com/181">CSS Float 속성의 모든것 (All About Floats)</a></li>
  <li><a href="http://naradesign.net/wp/2008/05/27/144/">float을 clear하는 4가지 방법</a></li>
  <li><a href="http://blog.wystan.net/2009/01/12/relationships-between-position-float-display">position, float, display 속성간의 관계</a></li>
</ul>

<p>블럭 엘리먼트인 <code>section</code>과 <code>aside</code>로 일반적인 페이지 레이아웃을 잡을 때 기본적으로는 수직적으로 쌓여버릴 것이다. 나란히 옆으로 배치하고 싶다면 각각 특정 <code>width</code>를 준 후에 하나는 왼쪽으로 다른 하나는 오른쪽으로 플로트하면 된다.</p>

<p>Fig. 3.04
<img src="http://learn.shayhowe.com/assets/courses/html-css-guide/box-model/floats.png" alt="" /></p>

<p><a href="http://coding.smashingmagazine.com/2007/05/01/css-float-theory-things-you-should-know/">엘리먼트를 플로팅</a>할 때 주목해야 할 몇가지 것들이 있다. 첫번째는 플로팅 엘리먼트가 부모 컨테이너의 가장자리에 붙어버린다는 것이다. 만약 부모 엘리먼트가 없다면 페이지의 가장자리에 붙어버릴 것이다. 추가적으로 하나의 엘리먼트를 폴로트하면 다른 엘리먼트는 페이지 흐름 안에서 자연스럽게 이어붙을 것이다.</p>

<pre><code>section {
  float: left;
  margin: 10px;
  width: 600px;
}
aside {
  float: right;
  margin: 10px;
  width: 320px;
}
</code></pre>

<h3 id="clearing-floated-elements">Clearing Floated Elements</h3>

<p>엘리먼트가 플로트될 때마다 페이지의 보통 흐름이 깨지고 다른 엘리먼트는 필요한대로 플로팅된 것 주위로 랩핑된다. 켄텐츠 옆에 이미지를 플로팅한 것과 같이 좋을 때도 있지만 때론 좋지 않다.</p>

<p>하나나 여러 개의 엘리먼트를 플로팅한 후 <code>clear</code> 속성을 이용하여 도큐먼트를 보통 흐름으로 되돌린다.</p>

<p>위의 예젱에서는 <code>section</code>과 <code>aside</code>를 플로트한 후 두 플로트된 엘리먼트 밑에 위치하는 <code>footer</code>에 클리어를 적용했다.</p>

<pre><code>footer {
  clear: both;
}
</code></pre>

<h2 id="positioning-elements">Positioning Elements</h2>

<p>플로팅하는 것 외에 엘리먼트를 정렬할 때 <code>position</code> 속성을 사용할 수도 있다. <code>position</code> 속성은 <a href="http://www.alistapart.com/articles/css-positioning-101/">다른 기능</a>을 하는 여러 값을 가진다.</p>

<p>디폴트 <code>position</code> 값은 <code>static</code>이다. <code>realtive</code> 값은 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code>과 같은 오프셋 값을 사용할 수 있다. <code>absolute</code>와 <code>fixed</code>는 <code>relative</code> 값을 가진 부모 엘리먼트와 함께 사용된다.</p>

<p>Fig. 3.05</p>

<p><img src="http://learn.shayhowe.com/assets/courses/html-css-guide/box-model/position.png" alt="" /></p>

<p>위의 예에서, <code>header</code> 엘리먼트는 고정된 엘리먼트로 동작하기 위해 <code>relative</code>로 배치되고, 그 안에 <code>absolute</code>로 배치되는 엘리먼트의 주된 컨테이너 역할을 한다. <code>ul</code> 엘리먼트는 <code>header</code> 엘리먼트의 위쪽과 오른쪽에서 <code>10px</code> 떨어진 절대 위치에 배치된다.</p>

<p>코드는 다음과 같을 것이다.</p>

<h6 id="html">HTML</h6>
<pre><code>&lt;header&gt;
  &lt;ul&gt;...&lt;/ul&gt;
&lt;/header&gt;
</code></pre>

<h6 id="css">CSS</h6>
<pre><code>header {
  position: relative;
}
ul {
  position: absolute;
  right: 10px;
  top: 10px;
}
</code></pre>

<h3 id="box-offset-properties">Box Offset Properties</h3>

<p>엘리먼트의 <code>position</code>이 <code>static</code>으로 설정되지 않는 한, 박스 오프셋 속성이 사용될 수 있다. 오프셋 값은 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 등이 있다.</p>

<p>예를 들면, <code>bottom: 32px;</code>은 <code>realtive</code> 배치 속성값을 가진 부모 엘리먼트의 바닥에서 32 픽셀에 위치될 것이다. 반대로 <code>bottom: -32px;</code>은 <code>realtive</code> 배치 속성값을 가진 부모 엘리먼트의 아래 32 픽셀에 위치될 것이다</p>

<blockquote>
  <h4 id="grids--frameworks">Grids &amp; Frameworks</h4>
  <p><br />
사이트의 레이아웃을 만들 때 고려하는 툴과 실제예는 셀 수없이 많다. 그 중 그리드와 프레임워크가 가장 선두에 있다.
<br />
<br />
<strong>Grid</strong>는 - vertical과 baseline 모두 - 웹사이트에 일련의 흐름을 더해주고 모든 것을 정렬하는 훌륭한 방법을 제공한다. 수년동안 인기있는 수십 개의 서로 다른 <a href="http://vandelaydesign.com/blog/design/resources-grid-based-design/">추천 그리드</a>가 있으며, 자신의 프로젝트에 가장 알맞는 것을 선택할 수 있다.
<br />
<br />
<strong>Framework</strong>는 미리 선정된 표준 세트를 바탕으로 웹사이트를 빠르게 만들 수 있는 방법을 제공한다. 프로젝트에 따라 프레임워크는 훌륭한 시작점을 제공하거나 완벽한 솔루션을 제공하기도 한다.</p>
</blockquote>

<h2 id="resources--links">Resources &amp; Links</h2>

<ul>
  <li><a href="https://developer.mozilla.org/en/CSS/length">CSS Length Values</a> via Mozilla Developer Network</li>
  <li><a href="http://www.quackit.com/html/codes/html_borders.cfm">HTML Borders</a> via Quackit.com</li>
  <li><a href="http://css-tricks.com/the-css-box-model/">The CSS Box Model</a> via CSS-Tricks</li>
  <li><a href="http://coding.smashingmagazine.com/2007/05/01/css-float-theory-things-you-should-know/">CSS Float Theory</a> via Smashing Magazine</li>
  <li><a href="http://www.alistapart.com/articles/css-positioning-101/">CSS Positioning 101</a> via A List Apart</li>
  <li><a href="http://vandelaydesign.com/blog/design/resources-grid-based-design/">Resources for Grid-Based Design</a> via Vandelay Design</li>
</ul>

]]></content>
  </entry>
  
</feed>
