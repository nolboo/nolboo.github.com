<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: github | Nolboo's Blog]]></title>
  <link href="http://nolboo.github.io/blog/categories/github/atom.xml" rel="self"/>
  <link href="http://nolboo.github.io/"/>
  <updated>2013-11-15T20:23:12+09:00</updated>
  <id>http://nolboo.github.io/</id>
  <author>
    <name><![CDATA[Nolboo Kim]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[완전 초보를 위한 깃허브]]></title>
    <link href="http://nolboo.github.io/blog/2013/10/06/github-for-beginner/"/>
    <updated>2013-10-06T20:14:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/10/06/github-for-beginner</id>
    <content type="html"><![CDATA[<p>원문 :  </p>

<ol>
  <li><a href="http://j.mp/1g3el6I">GitHub For Beginners: Don’t Get Scared, Get Started</a></li>
  <li><a href="http://j.mp/GzCMeO">GitHub For Beginners: Commit, Push And Go</a></li>
</ol>

<p>[중략] 깃의 필요성 등에 대해 역설함.</p>

<p>컴퓨터를 사용하는 모든 지식 근로자는 깃허브를 사용할 이유가 있다. 만약, 당신이 깃허브 사용법을 이해하는 것을 포기했다면, 이 글은 당신을 위한 것이다.</p>

<p>깃허브에 대한 중 주된 오해 중 하나는 그것이 컴퓨터 언어나 컴파일러나 마찬가지로 코딩과 관련된 개발툴이라는 것이다. 그러나, 페이스북이나 플리커와 같은 소셜 네트워크와 크게 다르지 않다. 프로필을 만들고 공유할 프로젝트를 올릴 수 있고, 다른 계정들을 팔로우하여 다른 사용자들과 소통할 수 있다. 많은 사용자가 프로그램과 코드 프로젝트를 저장하지만, 당신이 자랑할만한 프로젝트 폴더의 텍스트 문서나 다른 형식의 화일을 저장하는 것을 막는 것도 없다.</p>

<p>[중간요약] : 깃허브에 올리는 모든 것은 사용자가 지적재산권을 갖으며, 코드에 대한 어떤 지식이 없어도 깃허브를 사용할 수 있다.</p>

<h2 id="what-is-git-">What Is Git?(깃이 뭐지?)</h2>
<p>깃허브의 심장에서 작동되는 소프트웨어인 깃(Git: 재수없고 멍청한 놈, 자식)을 만든 유명한 소프트웨어 개발자 리누스 토발즈에 감사한다. 깃은 프로젝트의 어떤 부분도 겹쳐쓰지 않게 프로젝트의 변경을 관리하는 버전관리 소프트웨어이다.</p>

<!-- more -->

<p>왜 깃같은 것을 사용해야 하나? 당신과 동료가 동시에 같은 웹사이트에서 페이지를 업데이트하고 있다고 하자. 당신이 무언가를 변경하고 저장한 다음 웹사이트에 그것을 업로드한다. 지금까지는 좋았다. 문제는 동료가 동시에 같은 페이지에서 작업할 때이다. 누군가의 작업은 겹쳐쓰여질 것이고 지워질 것이다. </p>

<p>깃과 같은 버전관리 앱은 그런 일을 방지한다. 당신과 동료는 같은 페이지에 각자의 수정사항을 각각 업로드할 수 있고, 깃은 두 개의 복사본을 저장한다. 나중에, 당신들은 그대로 어떤 작업도 잃어버리지 않고 변경사항들을 병합할 수 있다. 깃은 이전에 만들어진 모든 변경사항의 “스냅샷”을 저장하기 때문에 이전 시점의 어떤 버전으로 되돌릴 수도 있다.</p>

<p>깃을 사용할 때 어려운 점은 90년대 해커와 같이 코드를 타이핑하는 명령어(커맨드 라인 - 맥 사용자라면 터미널)를 사용하여 접근해야하는 것이다. 이것은 요즘 컴퓨터 사용자에겐 까다로운 일일 수는 있다. 이제 깃허브를 들여다보자.</p>

<p>깃허브는 두 가지 방식으로 깃을 더 편리하게 해준다. 먼저, <a href="http://github.com/">깃허브 소트프웨어를 다운로드</a>하면, 로컬에서 당신의 프로젝트를 관리할 수 있게하는 비주얼 인터페이스를 제공한다. 두번째는, Github.com에 계정을 생성하면 웹에서 프로젝트를 버전관리할 수 있으며, 평가측정 등의 소셜 네트워크 기능을 사용할 수 있다.</p>

<p>다른 깃허브 사용자의 프로젝트를 둘러볼 수 있고, 그것들을 변경하거나 배우기 위해 자신만의 복사본을 다운로드할 수도 있다. 다른 사용자도 당신의 공개 프로젝트에 대해 같은 걸 할 수 있으며 에러를 발견해서 해결책을 제안할 수도 있다. 어느 경우든, 깃이 모든 변경사항에 대한 “스냅샷”을 저장하기 때문에 어떤 데이타도 잃어버리지 않는다.</p>

<p>깃을 배우지 않고 깃허브를 사용할 수 있지만, 사용하는 것과 이해하는 것은 큰 자이점이 있다. 깃을 이해하기 전에도 깃허브를 사용할 수 있으며, 나도 진짜로 이해하는 것은 아니다. 이 튜토리얼에선, 커맨드 라인에서 깃을 사용하는 것을 배울 것이다.</p>

<h2 id="words-people-use-when-they-talk-about-git-">Words People Use When They Talk About Git(기본 어휘)</h2>

<p>이 튜토리얼에서 반복적으로 사용하려고 하는 몇 개의 용어가 있다. 나도 배우기 시작하기 전에는 들어본 적이 없는 것들이다. 여기 중요한 것들이 있다:</p>

<p><strong>커맨트 라인(Command Line):</strong> 깃 명령어를 입력할 때 사용하는 컴퓨터 프로그램. 맥에선 터미널이라고 한다. PC에선 기본적인 프로그램이 아니어서 처음엔 깃을 다운로드해야 한다(다음 섹션에서 다룰 것이다). 두 경우 모두 마우스를 사용하는 것이 아닌 프롬프트로 알려진 텍스트 기반 명령어를 입력한다.</p>

<p><strong>저장소(Repository):</strong> 프로젝트가 거주(live)할 수 있는 디렉토리나 저장 공간. 깃허브 사용자는 종종 “repo”로 줄여서 사용한다. 당신의 컴퓨터 안의 로컬 폴더가 될 수도 있고, 깃허브나 다른 온라인 호스트의 저장 공간이 될 수도 있다. 저장소 안에 코드 화일, 텍스트 화일, 이미지 화일을 저장하고, 이름붙일 수 있다.</p>

<p><strong>버전관리(Version Control):</strong> 기본적으로, 깃이 서비스되도록 고안된 목적. MS 워드 작업할 때, 저장하면 이전 화일 위에 겹쳐쓰거나 여러 버전으로 나누어 저장한다. 깃을 사용하면 그럴 필요가 없다. 프로젝트 히스토리의 모든 시점의 “스냅샷”을 유지하므로, 결코 잃어버리거나 겹쳐쓰지 않을 수 있다.</p>

<p><strong>커밋(Commit):</strong> 깃에게 파워를 주는 명령이다. 커밋하면, 그 시점의 당신의 저장소의 “스냅샷”을 찍어, 프로젝트를 이전의 어떠한 상태로든 재평가하거나 복원할 수 있는 체크포인트를 가질 수 있다.</p>

<p><strong>브랜치(Branch):</strong> 여러 명이 하나의 프로젝트에서 깃 없이 작업하는 것이 얼마나 혼란스러울 것인가? 일반적으로, 작업자들은 메인 프로젝트의 브랜치를 따와서(branch off), 자신이 변경하고 싶은 자신만의 버전을 만든다. 작업을 끝낸 후, 프로젝트의 메인 디렉토리인 “master”에 브랜치를 다시 “Merge”한다.</p>

<h2 id="git-specific-commands-">Git-Specific Commands(주요 명령어)</h2>

<p>깃은 리눅스와 같은 큰 프로젝트를 염두에 두고 디자인되었기 때문에, 깃 명령어는 아주 많다. 그러나, 깃의 기본을 사용할 때에는 몇 개의 명령어만 알면된다. 모두 “git”이란 단어로 시작된다.</p>

<p><strong>git init:</strong> 깃 저장소를 초기화한다. 저장소나 디렉토리 안에서 이 명령을 실행하기 전까지는 그냥 일반 폴더이다. 이것을 입력한 후에야 추가적인 깃 명령어들을 줄 수 있다.</p>

<p><strong>git config:</strong> “configure”의 준말, 처음에 깃을 설정할 때 가장 유용하다.</p>

<p><strong>git help:</strong> 명령어를 잊어버렸다? 커맨드 라인에 이걸 타이핑하면 21개의 가장 많이 사용하는 깃 명령어들이 나타난다. 좀 더 자세하게 “git help init”이나 다른 용어를 타이핑하여 특정 깃 명령어를 사용하고 설정하는 법을 이해할 수도 있다.</p>

<p><strong>git status:</strong> 저장소 상태를 체크. 어떤 화일이 저장소 안에 있는지, 커밋이 필요한 변경사항이 있는지, 현재 저장소의 어떤 브랜치에서 작업하고 있는지 등을 볼 수 있다.</p>

<p><strong>git add:</strong> 이 명령이 저장소에 새 화일들을 추가하진 <em>않는다</em>. 대신, 깃이 새 화일들을 지켜보게 한다. 화일을 추가하면, 깃의 저장소 “스냅샷”에 포함된다.</p>

<p><strong>git commit:</strong> 깃의 가장 중요한 명령어. 어떤 변경사항이라도 만든 후, 저장소의 “스냅샷”을 찍기 위해 이것을 입력한다. 보통 “git commit -m “Message hear.” 형식으로 사용한다. <code>-m</code>은 명령어의 그 다음 부분을 메시지로 읽어야 한다는 것을 말한다.</p>

<p><strong>git branch:</strong> 여러 협업자와 작업하고 자신만의 변경을 원한다? 이 명령어는 새로운 브랜치를 만들고, 자신만의 변경사항과 화일 추가 등의 커밋 타임라인을 만든다. 당신의 제목이 명령어 다음에 온다. 새 브랜치를 “cats”로 부르고 싶으면, <code>git branch cats</code>를 타이핑한다.</p>

<p><strong>git checkout:</strong> 글자 그대로, 현재 위치하고 있지 않은 저장소를 “체크아웃”할 수 있다. 이것은 체크하길 원하는 저장소로 옮겨가게 해주는 탐색 명령이다. master 브랜치를 들여다 보고 싶으면, <code>git checkout master</code>를 사용할 수 있고, <code>git checkout cats</code>로 또 다른 브랜치를 들여다 볼 수 있다.</p>

<p><strong>git merge:</strong> 브랜치에서 작업을 끝내고, 모든 협업자가 볼 수 있는 master 브랜치로 병합할 수 있다. <code>git merge cats</code>는 “cats” 브랜치에서 만든 모든 변경사항을 master로 추가한다.</p>

<p><strong>git push:</strong> 로컬 컴퓨터에서 작업하고 당신의 커밋을 깃허브에서 온라인으로도 볼 수 있기를 원한다면, 이 명령어로 깃허브에 변경사항을 “push”한다.</p>

<p><strong>git pull:</strong> 로컬 컴퓨터에서 작업할 때, 작업하고 있는 저장소의 최신 버전을 원하면, 이 명령어로 깃허브로부터 변경사항을 다운로드한다(“pull”).</p>

<h2 id="setting-up-github-and-git-for-the-first-time--">Setting Up GitHub And Git For The First Time(처음으로 깃/깃허브 설정하기)</h2>

<p>먼저, <a href="https://github.com/">GitHub.com</a>에 가입한다. 다른 소셜 네트워크에 가입하는 것처럼 간단하다.</p>

<p>로컬 컴퓨터에서 작업하려면 깃을 설치해야 한다. <a href="http://git-scm.com/downloads">필요에 따라</a> 윈도우, 맥, 리눅스 용 깃을 설치하라.</p>

<p>이제 커맨드 라인으로 넘어갈 시점이다. 윈도우에선 방금 설치한 Git Bash 앱으로, OS X에선 터미널로 시작한다. 깃에 자신을 소개할 차례이다. 다음 코드를 타이핑한다:</p>

<pre><code>git config --global user.name "Your Name Here"
</code></pre>

<p>물론, “Your Name Here”의 인용부호 안에 자신의 이름을 넣어야 한다.</p>

<p>다음엔, 당신의 이메일을 말해준다. 조금 전에 GitHub.com을 가입할 때 사용한 이메일이어야 한다. 다음과 같이 한다:</p>

<pre><code>git config --global user.email "your_email@youremail.com"
</code></pre>

<p>이것이 로컬 컴퓨터에서 깃을 사용할 때 필요한 모든 것이다. 원한다면, 깃과 소통할 때마다 GitHub.com 계정에 로드인하는 것을 요청하지 않도록 깃을 설정할 수 있다. 이것과 관련된 풀 튜토리얼은 <a href="https://help.github.com/articles/set-up-git">깃허브에 있다</a>.</p>

<p><img src="http://readwrite.com/files/Screen%20Shot%202013-09-25%20at%205.01.04%20PM.png" alt="" /></p>

<h2 id="creating-your-online-repository--">Creating Your Online Repository(온라인 저장소 만들기)</h2>

<p>이제 프로젝트가 거주할 장소를 만들 시점이다. 깃과 깃허브는 당신의 프로젝트와 그 화일들, 깃이 저장한 화일들의 모든 버전에 접근할 수 있는 디지털 디렉토리나 저장공간을 저장소(repository 줄여서 repo)라고 한다.</p>

<p>GitHub.com으로 돌아가서 사용자명 다음에 있는 작은 책 아이콘을 클릭한다. 혹은, 모든 아이콘이 다 똑같아 보인다면 <a href="https://github.com/new">new repository page</a>로 간다. 저장소에 짧고 기억할만한 이름을 준다. 재미삼아 public으로 해본다.</p>

<p><img src="http://readwrite.com/files/Screen%20Shot%202013-09-25%20at%205.06.48%20PM.png" alt="" /></p>

<p>“Initialize this repository with a README.” 앞의 체크박스는 신경쓰지 않는다. Readme 화일은 보통 프로젝트에 관해 설명하는 텍스트 화일이다. 여기선 연습삼아 로컬에서 자신의 Readme 화일을 만들 것이다.</p>

<p>녹색의 “Create Repository” 버튼을 클릭한다. 이제 프로젝트가 거주할 온라인 공간을 가진 것이다.</p>

<h2 id="creating-your-local-repository--">Creating Your Local Repository(로컬 저장소 만들기)</h2>

<p>온라인에서 거주하는 프로젝트의 공간을 방금 만들었다. 그러나, 그 곳이 작업할 공간은 아니다. 컴퓨터에서 작업할 것이므로, 로컬 디렉토리에 만들 저장소에 실제로 미러링해야 한다.</p>

<p>먼저 다음을 타이핑한다:</p>

<pre><code>mkdir ~/MyProject
</code></pre>

<p><code>mkdir</code>은 make directory의 준말이다. 깃 명령어는 아니고 비주얼 인터페이스 이전 시대에 일반적인 탐색 명령어이다. <code>~/</code>는 나중에 찾기쉽게 컴퓨터 화일 구조의 최상위 단계에 저장소를 만드는 것이다. 브라우저에서 <code>~/</code>를 입력하면 로컬 컴퓨터의 최상위 단계 디렉토리가 보일 것이다. 맥의 크롬인 경우 Users 폴더를 보여준다.</p>

<p>깃허브 저장소와 동일하게 MyProject로 이름짓는 것을 주목한다. 당신도 그렇게 해라.</p>

<p>타이핑한다:</p>

<pre><code>cd ~/MyProject
</code></pre>

<p><code>cd</code>는 change directory를 뜻하며, 역시 탐색 명령어이다. 방금 디렉토리를 만들었고, 그 디렉토리로 옮겨 들어갔다.</p>

<p>이제 마침내 깃 명령어를 사용한다. 다음 줄에 타이핑한다:</p>

<pre><code>git init
</code></pre>

<p><code>init</code>은 “initialize(초기화)”를 뜻한다. 이 코드를 입력하면 이 디렉토리를 로컬 깃 저장소라고 컴퓨터에게 말해주는 것이다. 폴더를 열면 - 이 새로운 깃 디렉토리는 전용 저장소 안에 숨겨진 화일 하나이기 때문에 - 어떤 차이를 보지 못할 것이다.</p>

<p><img src="http://readwrite.com/files/Screen%20Shot%202013-09-25%20at%205.10.04%20PM.png" alt="" /></p>

<p>그러나, 컴퓨터는 이제 이 디렉토리를 Git-ready로 인식하고, 깃 명령어를 입력할 수 있다. 이제 프로젝트가 거주할 온라인과 로컬 저장소를 모두 가졌다.</p>

<p>이제는 깃허브에 첫번째 커밋을 만들어서 프로젝트의 첫 부분을 추가하자. 다음 화면과 같은 MyProject라는 저장소를 만들었었다.</p>

<p><img src="http://readwrite.com/files/Screen%20Shot%202013-09-25%20at%205.10.04%20PM_0.png" alt="" /></p>

<p>다음을 입력한다:</p>

<pre><code>touch Readme.txt
</code></pre>

<p>역시 깃 명령어가 아니다. 또 하나의 기본 탐색 명령어이다. <code>touch</code>는 “create 만드는 것”을 뜻한다. 그 뒤에 무엇을 적던지 간에 만들어지는 것의 이름이다. 파인더나 시작메뉴에서 해당 폴더로 가보면 Readme.txt 화일이 만들어진 것을 볼 것이다.</p>

<p>다음을 입력:</p>

<pre><code>git status
</code></pre>

<p>커맨드 라인에서 다음과 유사한 몇 개의 텍스트 줄을 응답할 것이다:</p>

<pre><code># On branch master
# Untracked files:
#   (use "git add ..." to include in what will be committed)
#
#         Readme.txt
</code></pre>

<p><img src="http://readwrite.com/files/Screen%20Shot%202013-09-25%20at%205.24.55%20PM.png" alt="" /></p>

<p>뭐지? 먼저, 당신은 프로젝트의 master 브랜치 상에 있다. “branched off”하지 않았기 때문에 당연하다. 두번째론, Readme.txt이 “untracked” 화일로 리스트되었다. 현재는 깃이 무시한다는 것을 뜻한다. 깃이 주목하게 하기 위해, 다음을 입력한다:</p>

<pre><code>git add Readme.txt
</code></pre>

<p>커맨드 라인이 주는 힌트를 보면 첫번째 화일을 추가했다는 것을 알 수 있다. 지금까지의 프로젝트 “스냅샷”을 찍거나, “커밋”할 시점이다.</p>

<pre><code>git commit -m “Add Readme.txt”
</code></pre>

<p><img src="http://readwrite.com/files/Screen%20Shot%202013-09-25%20at%205.28.11%20PM.png" alt="" /></p>

<p>-m 플래그는 이미 말했듯이, 뒤따르는 텍스트는 메시지로 읽어야 한다. 커밋 메시지가 현재형인 것을 주목한다. 버전관리는 시간에 대해 유연성을 가지므로 현재형으로 작성해야 한다. 더 이전 버전으로 되돌아갈 수 있으므로 <em>커밋을 했던</em> 것을 적는 것이 아니라, <em>커밋한</em> 것을 적어야 한다.</p>

<p>이제, 로컬에서 작은 작업을 하고 깃허브에 첫 커밋을 ‘push’할 때이다.</p>

<p>“잠깐, 온라인 저장소를 로컬 저장소와 연결하지 않았다.”라고 생각할지 모르겠다. 당신이 맞다. 로컬 저장소와 온라인 저장소의 첫번째 실제 연결을 만들어보자.</p>

<h2 id="connect-your-local-repository-to-your-github-repository----">Connect Your Local Repository To Your GitHub Repository(로컬 저장소와 깃허브 저장소 연결하기)</h2>

<p>먼저, 깃에게 온라인 어딘가가 실제 원격(remote) 저장소인지를 말해주어야 한다. <code>git add</code> 명령어를 사용하기 전까지는 깃이 우리 화일을 인식하지 않는 것과 마찬가지로, 원격 저장소도 인식하지 않을 것이다.</p>

<p><code>https://github.com/username/myproject.git</code>에 “MyProject”라는 이름의 깃허브 저장소가 있다고 가정해보자. 물론, <code>username</code>은 자신의 깃허브 사용자명으로 바꿔야 한며, 저장소 제목도 자신의 깃허브 저장소 제목으로 바꿔야한다.</p>

<pre><code>git remote add origin https://github.com/username/myproject.git
</code></pre>

<p>첫 부분은 익숙하다; <code>git add</code>를 이미 화일과 써봤다. 화일이 비롯된(originated) 곳에서 새로운 위치를 가리키기 위해 <code>origin</code>이란 단어를 더했다.(해석이 약간 명료하지 못함. 원문: We’ve tacked the word origin onto it to indicate a new place from which files will originate.) <code>remote</code>는 <code>origin</code>의 설명자(descriptor)이며, <code>origin</code>이 로컬 컴퓨터가 아닌 온라인 어딘가를 가리킨다는 것이다. </p>

<p>역자주: 간단히 말하면, 온라인에 있는 <code>https://github.com/username/myproject.git</code> 저장소를 <code>origin</code>으로 지정한다.</p>

<p>이제 깃이 원격 저장소가 있는 곳과 로컬 저장소가 변경사항을 어디로 보낼지 알게되었다. 확인하기 위해, 다음을 입력:</p>

<pre><code>git remote -v
</code></pre>

<p><img src="http://readwrite.com/files/Screen%20Shot%202013-09-25%20at%205.36.22%20PM.png" alt="" /></p>

<p>이 명령어는 로컬 저장소가 알고있는 원격 <code>origin</code>에 대한 모든 항목을 보여준다. 지금까지 함께 하였다면, 단 하나이어야 한다. 두 개가 리스트된 것은 정보를 <em>push</em>하고 <em>fetch</em>할 수 있는 것을 뜻한다.</p>

<p>이제 깃허브 원격 저장소로 변경사항을 업로드나 “push” 해보자. 쉽다. 입력:</p>

<pre><code>git push
</code></pre>

<p>커맨드 라인에서 여러 줄에 걸쳐 연달아 내놓을 것이고, 마지막으로 “everything up-to-date.”과 같은 것을 밷아낼 것이다.</p>

<p><img src="http://readwrite.com/files/Screen%20Shot%202013-09-25%20at%205.52.53%20PM.png" alt="" /></p>

<p>단순 명령어만 입력했기 때문에 주의(warning) 메시지가 나온다. 내 저장소의 master 브랜치를 지정하도록 하려면 <code>git push origin master</code>로 입력할 수 있다. 지금은 하나의 브랜치만 있기 때문에 그렇게 하지 않았다.</p>

<p>깃허브에 다시 로그인한다. 이제 오늘 만든 커밋이 얼마나 되는지 깃허브가 추적하는 것을 알 수 있다. 저장소를 클릭해보면 로컬 저장소에서 만들었던 동일한 Reame.txt를 가지고 있을 것이다.</p>

<h2 id="all-together-now">All Together Now!</h2>

<p>축하한다, 이제 공식적으로 깃 사용자가 되었다! 저장소를 만들고 변경사항을 커밋할 수 있다. 이것이 대부분의 입문 튜토리얼의 끝나는 지점이다. </p>

<p>[중략] 이 정도면 회사에서 사장이 깃을 사용할 것을 요구하면 당장 디자인 화일을 깃허브에 올릴 정도는 될 것이라고 이야기하면서 디자인 화일 명 하나를 중심으로 여태 해온 것을 반복함.</p>

<h2 id="section">역자 요약</h2>

<pre><code>git config --global user.name "이름"
git config --global user.email "깃허브 메일주소" // 매번 물어보는 귀찮음을 피하기 위해 설정.

mkdir ~/MyProject   // 로컬 디렉토리 만들고
cd ~/myproject      // 디렉토리로 들어가서
git init            // 깃 명령어를 사용할 수 있는 디렉토리로 만든다.
git status          // 현재 상태를 훑어보고
git add 화일명.확장자  // 깃 주목 리스트에 화일을 추가하고 or
git add .           // 이 명령은 현재 디렉토리의 모든 화일을 추가할 수 있다.
git commit -m “현재형으로 설명” // 커밋해서 스냅샷을 찍는다.

git remote add origin https://github.com/username/myproject.git // 로컬과 원격 저장소를 연결한다.
git remote -v // 연결상태를 확인한다.
git push origin master // 깃허브로 푸시한다.
</code></pre>

<h2 id="git-resources">Git Resources</h2>

<ul>
  <li><a href="http://git-scm.com/book">Pro Git</a>. 깃을 배우고 사용하는 법에 대한 오픈소스 북. 분량이 많지만, 기본을 배우기 위해서는 3장까지만 읽으면 된다.</li>
  <li><a href="http://www.codeschool.com/courses/try-git">Try Git</a>. 코드스쿨과 깃허브가 팀을 짜서 이 속성 튜토리얼을 만들었다. 기본에 대해 좀 더 연습하길 원하면 도움이 될 것이다.</li>
  <li><a href="http://www.youtube.com/GitHubGuides">GitHub Guides</a>. 비주얼 학습자라면 깃허브의 공식 유투브 채널에서 시간을 보낼만하다. 특히 <a href="http://www.youtube.com/watch?v=8oRjP8yj2Wo&amp;list=PLg7s6cbtAD165JTRsXh8ofwRw0PqUnkVH">Git Basics</a> 네개의 시리즈에서 많은 것을 얻을 수 있다.</li>
  <li><a href="http://gitref.org/">Git Reference</a>. 명령어를 잊어버렸을 때는 용어 참조하기 좋은 사이트다. </li>
  <li><a href="http://rogerdudler.github.io/git-guide">Git - the simple guide</a>. 이 튜토리얼은 짧고 달콤하다. 깃의 기초에 대해 되살리고 싶다면 필요할 것이다.</li>
  <li><a href="https://help.github.com/articles/github-glossary">GitHub Glossary</a>. 역자가 추가한 깃허브 공식 용어 사전</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[깃허브로 협업하는 법]]></title>
    <link href="http://nolboo.github.io/blog/2013/08/29/how-to-collaborate-on-github/"/>
    <updated>2013-08-29T18:35:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/08/29/how-to-collaborate-on-github</id>
    <content type="html"><![CDATA[<p>원문 : <a href="http://net.tutsplus.com/tutorials/tools-and-tips/how-to-collaborate-on-github/">How to Collaborate On GitHub</a></p>

<p>필요한 부분만 완전 요약하여 번역하였으니 원문을 반드시 참조하세요!</p>

<h2 id="learn-the-ecosystem-of-the-project">Learn the Ecosystem of the Project</h2>

<p>공헌하기 위해서는 프로젝트와 관련된 모든 문서를 읽어라. 예를 들면, 깃허브는 표준화된 <code>CONTRIBUTING.md</code>를 가지고 있다. <a href="https://github.com/jquery/jquery/blob/master/CONTRIBUTING.md">jQuery 공헌 가이드</a>는 완벽한 예제이다. 프로젝트 생태계를 이해하는 또 다른 방법은 기존 코드베이스와 <code>git log</code>를 살펴보는 것이다. 프로젝트의 문서를 전부 읽고 어휘를 습득하라.</p>

<h2 id="the-pull-request-workflow-for-code-contribution">The Pull-Request Workflow for Code Contribution</h2>

<p>깃허브의 일반적인 워크플로우는 꽤 단순하다.
<!-- more -->
1. 자신의 계정으로 target 저장소를 fork한다.
2. 로컬 컴퓨터에 저장소를 clone한다.
3. “topic 브랜치”로 check out하고 소스를 변경한다.
4. 자신의 fork에 topic 브랜치를 push한다.
5. 토론을 통해 pull request를 만들기위해 깃허브의 diff 뷰어를 사용한다.
6. 요청된 변경을 만든다.
7. pull 요청이 (보통 master 브랜치 안으로) merge되고 topic 브랜치는 upstream(target) 저장소에서 지워진다.</p>

<p>워크플로우에서 각 프로젝트마다 많은 차이가 있다. 예로, topic 브랜치의 이름 규약은 서로 다르다. 어떤 프로젝트는 깃허브 이슈의 ID #가 345일 때 <code>bug_345</code>와 같은 규약을 사용한다. 어떤 프로젝트에선 더 짧은 커밋 메시지를 선호한다.</p>

<h3 id="step-1-forking">Step 1: Forking</h3>

<p>깃허브에서 저장소를 fork한다.</p>

<p><img src="http://cdn.tutsplus.com/net.tutsplus.com/uploads/2013/08/github_header.png" alt="" /></p>

<p><img src="http://cdn.tutsplus.com/net.tutsplus.com/uploads/2013/08/forking.png" alt="" /></p>

<h3 id="step-2-cloning">Step 2: Cloning</h3>

<p>우측 사이드바의 URL을 사용하여 저장소를 clone한다.</p>

<pre><code>git clone git@github.com:jcutrell/jquery.git
</code></pre>

<p><img src="http://cdn.tutsplus.com/net.tutsplus.com/uploads/2013/08/clone_url.png" alt="" /></p>

<h3 id="step-3-adding-the-upstream-remote">Step 3: Adding the Upstream Remote</h3>

<p>클론한 디렉토리로 변경하고, 이 지점에서 upstream remote를 추가한다.</p>

<pre><code>cd jquery
git remote add upstream git@github.com:jquery/jquery.git
</code></pre>

<p>이렇게 하면 로컬에서 소스 변경을 Pull하고 merge할 수 있다. 이렇게:</p>

<pre><code>git fetch upstream
git merge upstream/master
</code></pre>

<h3 id="step-4-checking-out-a-topic-branch">Step 4: Checking Out a Topic Branch</h3>

<p>자신의 변경사항을 만들기 전에, topic 브랜치로 checkout한다.</p>

<pre><code>git checkout -b enhancement_345
</code></pre>

<h3 id="step-5-committing">Step 5: Committing</h3>

<p>이제 소스를 변경하고 변경에 대한 추적하는 커밋을 만든다.</p>

<pre><code>git commit -am "adding a smileyface to the documentation."
</code></pre>

<h3 id="step-6-pushing">Step 6: Pushing</h3>

<p>자신의 fork에 topic 브랜치를 push한다.</p>

<pre><code>git push origin enhancment_345
</code></pre>

<h3 id="step-7-creating-a-pull-request">Step 7: Creating a Pull Request</h3>

<p>최종적으로 pull 요청을 만들 것이다. 먼저 자신의 fork로 간다. “your recently pushed branches”에서 “Compare and Pull Request”를 선택한다. 그렇지 않으면 뜨랍다운에서 브랜치를 선택하고, 저장소 섹션의 우상에 있는 “Pull Request” 나 “Compare”를 클릭한다.</p>

<p><img src="http://cdn.tutsplus.com/net.tutsplus.com/uploads/2013/08/compare_pull_request.png" alt="" /></p>

<p><img src="http://cdn.tutsplus.com/net.tutsplus.com/uploads/2013/08/switch_branches.png" alt="" /></p>

<p><a href="http://zachholman.com/talk/how-github-uses-github-to-build-github/">“How GitHub Uses GitHub to Build GitHub”</a>에 따르면 pull 요청은 대화이다.</p>

<h2 id="github-issues--pull-requests--project-management-zen">GitHub Issues + Pull Requests = Project Management Zen</h2>

<p>이슈의 가장 놀라운 특징은 pull 요청과의 통합이다. 사용자는 키밋 메시지에 이슈 숫자 IO를 포함하여 커밋 메시지에서 이슈를 참조할 수 있다. 예를 들면:</p>

<pre><code>git commit -am "Adding a header; fixes #3"
</code></pre>

<p>위의 커밋 메시지는 pull 요청이 받아들여지면 이슈 #3를 자동으로 닫는다.</p>

<h2 id="seek-out-secondary-channels-of-collaboration">Seek Out Secondary Channels of Collaboration</h2>

<p>pull 요청만이 공헌할 수 있는 유일한 방법이라고 생각하지 마라. 포럼이나 IRC 대화에서도 가능하다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[옥토프레스로 블로깅하기]]></title>
    <link href="http://nolboo.github.io/blog/2013/07/21/start-octopress/"/>
    <updated>2013-07-21T23:16:00+09:00</updated>
    <id>http://nolboo.github.io/blog/2013/07/21/start-octopress</id>
    <content type="html"><![CDATA[<h2 id="section">이전 동기와 간단한 과정 소개</h2>

<p>워드프레스닷컴의 두 개의 블로그 중 학습을 위해 번역과 요약을 주로 올리던 <code>nolboos.wordpress.com</code> 블로그가 워드프레스닷컴에 의해 <a href="http://en.support.wordpress.com/suspended-blogs/">중지</a>되었다. 워드프레스 설치 호스팅 서비스를 세 곳이나 친절하게 알려주긴 했지만 도메인이나 비용, 속도 등 여러 사항이 걸리고, 아마존 이외에는 이용하던 호스팅 서비스도 없어 난감해 하고 있었다. 예전부터 Github Page로 블로그를 올리는 방법을 염두에 두고 있었는데 <a href="https://twitter.com/sungchi">@sungchi</a>님이 Github(http://sungchi.github.io/)와 <a href="http://tryghost.org/">Ghost</a>를 추천하셨다. 고스트는 아직 개발 중이어서 고려대상에서 제외하였고 깃허브는 블로그글을 쓸 때마다 메인페이지에 링크를 다는 불편함 등이 있었다. 게으른 놀부는 불편함을 없애주는 방법을 찾기 시작했고, 두 개가 눈에 들어왔다. </p>

<p><a href="http://haroopress.com/">하루프레스</a>와 <a href="http://octopress.org/">옥토프레스</a>
<!-- more -->
옥토프레스가 먼저 나왔고 해외에서 사용자 수가 점차적으로 늘어가고 있는 것 같으나 개발이 일년 이상 중지되어 있는 것 같았고, 하루프레스는 한국분이 <a href="https://twitter.com/Rhiokim">@Rhiokim</a> 만들어서인지 디자인이나 기능적인 측면에서 좀 더 끌리는 면이 있었다. 그래서 하루프레스를 설치하기 시작하였다. 그러나, 중간에 Xcode를 요구하는 에러메시지가 나와 물어보았더니 Xcode가 반드시 있어야 한다는 <a href="https://twitter.com/n0lb00/status/356388684259528705">답</a>이 돌아왔다. 디스크 용량을 걱정해야 하는 상황에선 Xcode 설치는 무리였다. 낙망하고 별 수 없이 옥토프레스를 설치하기 시작하였다.</p>

<h2 id="section-1">사전 경험 얻기</h2>

<p>검색을 해봐도 옥토프레스에 대한 한글 블로그 글이 거의 없었고,(해커들을 위한 블로그 시스템이라 설명을 안하나?ㅠㅠ) <a href="http://doomed-lover.com/archives/migrating-to-octopress/">옥토프레스 이전 과정</a>에서 몇 가지 사전 지식을 얻을 수 있었다.</p>

<ul>
  <li><a href="https://github.com/thomasf/exitwp">Exitwp</a> : 워드프레스 블로그를 지킬 블로그 엔진으로 쉽게 이전. 마크다운으로 변환</li>
  <li>동영상 임베딩 등은 플러그인을 사용하지말고 원 코드를 사용하는 것이 좋다.</li>
  <li>블로그의 제목, 태그는 모두 영문 사용을 기본으로 하는 것이 좋을듯.</li>
</ul>

<h2 id="httpjekyllrbcomdocsmigrations">기존 블로그 글을 <a href="http://jekyllrb.com/docs/migrations/">지킬로 마이그레이션</a></h2>

<pre><code>$ gem install jekyll-import --pre
</code></pre>

<p>공개/비공개 포스트를 구별하지 않으니 확인해야 한다.</p>

<pre><code>$ gem install hpricot
</code></pre>

<p><code>https://YOUR-USER-NAME.wordpress.com/wp-admin/export.php</code>에서 내려받은 <code>wordpress.xml</code>을 변환</p>

<pre><code>$ ruby -rubygems -e 'require "jekyll/jekyll-import/wordpressdotcom";
JekyllImport::WordpressDotCom.process({ :source =&gt; "wordpress.xml" })'
</code></pre>

<p><code>_posts</code>, <code>_pages</code>, <code>_nav_menu_items</code>의 세 개의 디렉토리에 <code>.html</code> 화일들이 추출된다.</p>

<h2 id="section-2">설치</h2>

<p>git과 Ruby를 <a href="http://octopress.org/docs/setup/">설치</a>하고 테마를 적용하였다.(글이 너무 길어지니 이 부분은 링크에서 보세요)</p>

<p>이제 <a href="http://octopress.org/docs/deploying/github/">깃허브에 올려보자</a>.</p>

<p>원하던 블로그 도메인인 <code>nolboo.github.com</code>으로 <a href="https://github.com/repositories/new">새 저장소</a>를 만든다.</p>

<pre><code>$ rake setup_github_pages //저장소 URL을 물어보면 내 경우엔 `https://github.com/nolboo/nolboo.github.com.git`을 입력

$ rake generate
$ rake deploy
</code></pre>

<p>위의 과정까지 마치면 <code>nolboo.github.com</code>이나 <code>nolboo.github.io</code>로 가보면 기본테마가 적용된 최초의 블로그를 볼 수 있다. 의외로 간단하다. </p>

<h2 id="httpoctopressorgdocsconfiguring"><a href="http://octopress.org/docs/configuring/">설정하기</a></h2>

<p><code>Rakefile</code>과 <code>_config.yml</code>만 변경하는 것으로 충분하나 설정 화일 리스트는 다음과 같다.</p>

<pre><code>_config.yml       # Main config (Jekyll's settings)
Rakefile          # Configs for deployment
config.rb         # Compass config
config.ru         # Rack config
</code></pre>

<p><code>Rakefile</code>도 <code>rsync</code>를 사용하지 않는 한 변경할 것이 없다.</p>

<h3 id="section-3">블로그 설정</h3>

<p><code>_config.yml</code>은 세 섹션으로 되어있다. <em><code>url</code>, <code>title</code>, <code>subtitle</code>, <code>author</code>는 반드시 변경해야 하고, 서드파티 서비스를 활성화시켜주어야 한다.</em></p>

<h4 id="section-4">주요 설정</h4>

<pre><code>url:                # For rewriting urls for RSS, etc
title:              # Used in the header and title tags
subtitle:           # A description used in the header
author:             # Your name, for RSS, Copyright, Metadata
simple_search:      # Search engine for simple site search
description:        # A default meta description for your site
</code></pre>

<p>위의 것만 확인하면서 변경하였다.</p>

<p>플러그인에서는 일단 <code>disqus_short_name</code>에 숏네임을 하나 정해서 넣어주었고, <code>google_analytics_tracking_id</code>에 추적 ID를 생성해서 입력했다.</p>

<h2 id="section-5">블로깅 하기</h2>

<p>블로그 포스트는 <code>source/_posts</code> 디렉토리에 지킬 방식인 <code>YYYY-MM-DD-post-title.markdown</code> 형식의 이름으로 저장되어야 한다. 이를 편하게 해주는 rake 명령은 다음과 같다.</p>

<pre><code>$ rake new_post["title"]
</code></pre>

<p><em>Title은 영문으로 주는 것이 좋다.</em>
해당 <code>.markdown</code> 화일을 에디터로 열어보면 다음과 같은 YAML 헤더를 볼 수 있다.</p>

<pre><code>---
layout: post
title: "Zombie Ninjas Attack: A survivor's retrospective"
date: 2011-07-03 5:59
comments: true
external-url:
categories:
---
</code></pre>

<p>비공개로 할 경우에는 <code>published: false</code>를 추가한다. linklog 스타일로 포스팅할 때는 <code>external-url</code>에 링크를 추가하면 된다.</p>

<p>카테고리는 다음과 같은 방식으로 지정한다.</p>

<pre><code># 한 개 추가
categories: Sass

# 여러 개 추가하기 1
categories: [CSS3, Sass, Media Queries]

# 여러 개 추가하기 2
categories:
- CSS3
- Sass
- Media Queries
</code></pre>

<p>블로그의 인덱스 페이지에서 글의 일부만 보여주려면 <code>&lt;!-- more --&gt;</code> 주석을 넣어주면 “Continue →” 버튼으로 전체 글로 링크된다.</p>

<h2 id="section-6">제너레이트와 미리보기</h2>

<pre><code>rake generate   # public 디렉토리에 포스트와 페이지를 제너레이트한다.
rake preview    # http://localhost:4000 에 웹서버를 마운트하고 볼 수 있게 한다.
</code></pre>

<p>이제 웹 브라우저에서 <code>http://localhost:4000</code> 주소를 입력하여 미리볼 수 있다.</p>

<h2 id="section-7">출판하기</h2>

<pre><code>$ rake deploy
</code></pre>

<h2 id="section-8">블로깅 워크플로우</h2>

<pre><code>1. $ rake new_post["title"] //title은 영문으로 간단하게
2. 에디터로 .markdown 화일 편집하고 
3. title: 에 멋진 한글 제목을 달고 categories: [CSS3, Sass, Media Queries] 지정
4. $ rake generate &amp;&amp; rake preview //localhost:4000에서 미리보기와 수정
5. 소스 백업(*아래 참조*)
6. $ rake deploy
</code></pre>

<p>깃허브에 반영되는 것은 시간이 좀 걸리니 바로 안 나타난다고 조급해하지 말자.</p>

<p><strong>5번 출판하기 전에 <code>source</code> 브랜치에 소스를 직접 푸시하는 것을 잊지마라.</strong></p>

<pre><code>git add .
git commit -m 'your message'
git push origin source
</code></pre>

<h2 id="section-9">맺는말</h2>

<p>마크다운을 이용할 수 있을 정도의 사용자라면 쉽게 써보려고 했지만 많이 부족한 것 같다. 옥토프레스가 내가 원하는 블로깅 워크플로우에 가장 근접하게 사용할 수 있을 것 같다. 이제 워드프레스닷컴에서 홀대받았던 나머지 글들을 계속 올리고 추가적인 포스팅도 꾸준히 할 것이다.</p>

<h2 id="section-10">추가 참조 링크</h2>

<ul>
  <li><a href="https://github.com/imathis/octopress/wiki/3rd-party-plugins">3rd party plugins</a></li>
  <li><a href="http://www.tomordonez.com/blog/2012/06/04/creating-a-github-blog-using-octopress/">Creating a Github Blog Using Octopress</a></li>
  <li><a href="http://webdesign.tutsplus.com/tutorials/applications/getting-started-with-octopress/">Getting Started with Octopress</a></li>
  <li><a href="http://paulsturgess.co.uk/blog/2013/04/24/hello-octopress-and-github-pages/">Hello Octopress &amp; Github Pages</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
